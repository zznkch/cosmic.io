<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Devil - Mission Edition</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff007a;
            --neon-purple: #bc13fe;
            --neon-green: #39ff14;
            --neon-yellow: #ffd700;
            --neon-red: #ff3333;
            --neon-orange: #ff5500;
            --bg-dark: #050505;
            --bg-darker: #01010a;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
        }

        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: var(--bg-darker);
            font-family: 'Orbitron', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            color: white;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg-darker);
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Orientation warning */
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(20px);
        }

        .orientation-warning h2 {
            color: var(--neon-pink);
            margin-bottom: 20px;
            font-size: clamp(1.5rem, 5vw, 2rem);
        }

        .orientation-warning p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 4vw, 1.2rem);
        }

        /* UI Styles am√©lior√©s */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.95), rgba(5, 0, 20, 0.98));
            backdrop-filter: blur(15px);
            z-index: 100;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 20px;
            padding-top: calc(20px + var(--safe-area-top));
            padding-bottom: calc(20px + var(--safe-area-bottom));
        }

        /* HUD am√©lior√© avec LVL en haut */
        .hud {
            position: fixed;
            top: max(20px, var(--safe-area-top));
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 clamp(15px, 3vw, 25px);
        }

        .score-display {
            font-family: 'Orbitron', monospace;
            font-size: clamp(20px, 5vw, 32px);
            font-weight: 900;
            color: var(--neon-blue);
            text-shadow: 
                0 0 10px var(--neon-blue),
                0 0 20px var(--neon-blue),
                0 0 30px rgba(0, 242, 255, 0.5);
            background: linear-gradient(to right, rgba(0, 0, 0, 0.7), rgba(0, 20, 40, 0.7));
            padding: clamp(8px, 2vw, 12px) clamp(15px, 3vw, 25px);
            border-radius: 15px;
            border: 2px solid var(--neon-blue);
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 20px rgba(0, 242, 255, 0.3),
                inset 0 0 20px rgba(0, 242, 255, 0.1);
            letter-spacing: 2px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .lives-container {
            display: flex;
            gap: clamp(8px, 2vw, 15px);
            background: linear-gradient(to right, rgba(0, 20, 40, 0.7), rgba(0, 0, 0, 0.7));
            padding: clamp(8px, 2vw, 12px) clamp(15px, 3vw, 25px);
            border-radius: 15px;
            border: 2px solid var(--neon-blue);
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 20px rgba(0, 242, 255, 0.3),
                inset 0 0 20px rgba(0, 242, 255, 0.1);
        }

        .heart {
            width: clamp(22px, 6vw, 35px);
            height: clamp(22px, 6vw, 35px);
            position: relative;
            transition: transform 0.3s, filter 0.3s;
        }

        .heart svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 8px var(--neon-blue));
            transition: all 0.3s;
        }

        .heart.lost svg {
            fill: #222;
            filter: none;
        }

        .heart.pulse svg {
            animation: heartPulse 0.5s ease-in-out;
        }

        @keyframes heartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        /* LVL Display en haut */
        .lvl-display {
            position: fixed;
            top: max(20px, var(--safe-area-top));
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(to right, 
                rgba(188, 19, 254, 0.3), 
                rgba(0, 242, 255, 0.3));
            padding: clamp(8px, 2vw, 10px) clamp(15px, 3vw, 25px);
            border-radius: 15px;
            border: 2px solid var(--neon-purple);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(188, 19, 254, 0.3);
            pointer-events: none;
            z-index: 40;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px var(--neon-purple);
            font-size: clamp(18px, 4vw, 24px);
        }

        /* Combo display */
        .combo-display {
            position: fixed;
            top: 50%;
            right: clamp(10px, 2vw, 20px);
            transform: translateY(-50%);
            font-family: 'Orbitron', monospace;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: bold;
            color: var(--neon-orange);
            text-shadow: 
                0 0 10px var(--neon-orange),
                0 0 20px rgba(255, 85, 0, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: clamp(8px, 2vw, 10px) clamp(12px, 3vw, 20px);
            border-radius: 15px;
            border: 2px solid var(--neon-orange);
            backdrop-filter: blur(10px);
            pointer-events: none;
            z-index: 40;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-display.active {
            opacity: 1;
            animation: comboPulse 0.5s ease-in-out;
        }

        @keyframes comboPulse {
            0%, 100% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.1); }
        }

        /* Boutons style mission */
        .mission-btn {
            position: relative;
            width: clamp(90px, 25vw, 140px);
            height: clamp(90px, 25vw, 140px);
            background: linear-gradient(135deg, var(--neon-green), var(--neon-blue));
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            margin: clamp(20px, 5vw, 40px);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 30px var(--neon-green),
                0 0 60px rgba(57, 255, 20, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            animation: playBtnGlow 2s infinite alternate;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(18px, 4vw, 28px);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @keyframes playBtnGlow {
            0% { box-shadow: 0 0 30px var(--neon-green), 0 0 60px rgba(57, 255, 20, 0.3); }
            100% { box-shadow: 0 0 40px var(--neon-blue), 0 0 80px rgba(0, 242, 255, 0.4); }
        }

        .mission-btn:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 
                0 0 40px var(--neon-blue),
                0 0 80px rgba(0, 242, 255, 0.5);
        }

        .mission-btn:active {
            transform: scale(0.95);
        }

        .go-btn {
            position: relative;
            width: clamp(120px, 30vw, 180px);
            height: clamp(120px, 30vw, 180px);
            background: linear-gradient(135deg, var(--neon-red), var(--neon-orange));
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            margin: clamp(20px, 5vw, 40px);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 40px var(--neon-red),
                0 0 80px rgba(255, 51, 51, 0.4),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            animation: goBtnGlow 1.5s infinite alternate;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(24px, 5vw, 36px);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        @keyframes goBtnGlow {
            0% { box-shadow: 0 0 40px var(--neon-red), 0 0 80px rgba(255, 51, 51, 0.4); }
            100% { box-shadow: 0 0 50px var(--neon-orange), 0 0 100px rgba(255, 85, 0, 0.5); }
        }

        .next-btn {
            position: relative;
            width: clamp(80px, 20vw, 120px);
            height: clamp(80px, 20vw, 120px);
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            margin: clamp(15px, 4vw, 30px);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 30px var(--neon-blue),
                0 0 60px rgba(0, 242, 255, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            animation: nextBtnGlow 2s infinite alternate;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(16px, 3vw, 22px);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @keyframes nextBtnGlow {
            0% { box-shadow: 0 0 30px var(--neon-blue), 0 0 60px rgba(0, 242, 255, 0.3); }
            100% { box-shadow: 0 0 40px var(--neon-purple), 0 0 80px rgba(188, 19, 254, 0.4); }
        }

        /* Contr√¥les mobiles am√©lior√©s - RESPONSIVE */
        #mobile-controls {
            position: fixed;
            bottom: max(30px, var(--safe-area-bottom));
            width: 100vw;
            display: flex;
            justify-content: space-between;
            padding: 0 clamp(20px, 5vw, 40px);
            z-index: 60;
            gap: clamp(20px, 5vw, 40px);
            pointer-events: none;
        }

        .control-group {
            pointer-events: auto;
        }

        .joystick-container {
            position: relative;
            width: clamp(140px, 30vw, 220px);
            height: clamp(140px, 30vw, 220px);
            touch-action: none;
        }

        .joystick-boundary {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                rgba(0, 242, 255, 0.1), 
                rgba(0, 100, 200, 0.05));
            border: 3px solid var(--neon-blue);
            border-radius: 50%;
            box-shadow: 
                0 0 30px rgba(0, 242, 255, 0.4),
                inset 0 0 30px rgba(0, 242, 255, 0.2);
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(60px, 15vw, 100px);
            height: clamp(60px, 15vw, 100px);
            background: radial-gradient(circle at 30% 30%, 
                var(--neon-blue), 
                #0080ff);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 
                0 0 30px rgba(0, 242, 255, 0.9),
                inset 0 0 15px rgba(255, 255, 255, 0.8);
            transition: all 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
            z-index: 2;
            will-change: transform, box-shadow;
        }

        .joystick-thumb.active {
            box-shadow: 
                0 0 40px rgba(0, 242, 255, 1),
                inset 0 0 20px rgba(255, 255, 255, 1);
            transform: translate(-50%, -50%) scale(1.15);
        }

        .action-btn {
            width: clamp(120px, 25vw, 160px);
            height: clamp(120px, 25vw, 160px);
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 0, 122, 0.8), 
                rgba(188, 19, 254, 0.6));
            border: 3px solid var(--neon-pink);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 
                0 0 30px rgba(255, 0, 122, 0.6),
                0 0 60px rgba(255, 0, 122, 0.3),
                inset 0 0 20px rgba(255, 255, 255, 0.3);
            transition: all 0.1s;
            align-self: flex-end;
            margin-bottom: clamp(20px, 5vw, 40px);
            position: relative;
            cursor: pointer;
            animation: fireBtnGlow 2s infinite alternate;
            touch-action: manipulation;
        }

        @keyframes fireBtnGlow {
            0% { box-shadow: 0 0 30px rgba(255, 0, 122, 0.6), 0 0 60px rgba(255, 0, 122, 0.3); }
            100% { box-shadow: 0 0 40px rgba(188, 19, 254, 0.7), 0 0 80px rgba(188, 19, 254, 0.4); }
        }

        .action-btn.active {
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 0, 122, 1), 
                rgba(188, 19, 254, 0.8));
            transform: scale(0.95);
            box-shadow: 
                0 0 40px rgba(255, 0, 122, 0.9),
                0 0 80px rgba(255, 0, 122, 0.5),
                inset 0 0 25px rgba(255, 255, 255, 0.4);
        }

        .target-icon {
            width: 70%;
            height: 70%;
            position: relative;
            animation: targetRotate 4s linear infinite;
        }

        @keyframes targetRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Style pour l'√©cran de d√©marrage am√©lior√© */
        .start-content {
            text-align: center;
            max-width: min(900px, 90vw);
            padding: clamp(20px, 5vw, 40px);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8), 
                rgba(5, 0, 20, 0.9));
            border-radius: 30px;
            border: 3px solid var(--neon-blue);
            box-shadow: 
                0 0 50px rgba(0, 242, 255, 0.3),
                inset 0 0 30px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(20px);
        }
        
        .start-content h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 8vw, 5rem);
            background: linear-gradient(to right, var(--neon-pink), var(--neon-blue), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 0, 122, 0.5);
            margin-bottom: clamp(15px, 3vw, 20px);
            line-height: 1.2;
            letter-spacing: 3px;
            text-transform: uppercase;
            animation: titleGlow 3s infinite alternate;
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 0 30px rgba(255, 0, 122, 0.5); }
            50% { text-shadow: 0 0 40px rgba(0, 242, 255, 0.6); }
            100% { text-shadow: 0 0 30px rgba(188, 19, 254, 0.5); }
        }
        
        .start-content p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: clamp(25px, 5vw, 40px);
            line-height: 1.6;
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
        }

        /* Styles pour les √©crans de tutoriel */
        .tutorial-screen {
            text-align: center;
            max-width: min(900px, 90vw);
            padding: clamp(20px, 5vw, 40px);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8), 
                rgba(5, 0, 20, 0.9));
            border-radius: 30px;
            border: 3px solid var(--neon-blue);
            box-shadow: 
                0 0 50px rgba(0, 242, 255, 0.3),
                inset 0 0 30px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(20px);
        }

        .tutorial-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.8rem, 6vw, 4rem);
            color: var(--neon-blue);
            margin-bottom: clamp(20px, 4vw, 30px);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 15px var(--neon-blue);
        }

        .tutorial-subtitle {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.2rem, 4vw, 2.5rem);
            color: var(--neon-green);
            margin-bottom: clamp(15px, 3vw, 20px);
            text-shadow: 0 0 10px var(--neon-green);
        }

        .tutorial-text {
            color: white;
            font-size: clamp(0.9rem, 2.5vw, 1.3rem);
            margin-bottom: clamp(20px, 4vw, 30px);
            line-height: 1.6;
            text-align: left;
            padding: 0 clamp(10px, 3vw, 20px);
        }

        .tutorial-controls {
            display: flex;
            justify-content: center;
            gap: clamp(20px, 4vw, 40px);
            margin: clamp(20px, 4vw, 40px) 0;
            flex-wrap: wrap;
        }

        .tutorial-control-demo {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(10px, 2vw, 15px);
            padding: clamp(15px, 3vw, 20px);
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 2px solid var(--neon-blue);
            min-width: min(200px, 90%);
        }

        .control-label {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            color: var(--neon-green);
            font-weight: bold;
        }

        .control-description {
            color: #ddd;
            font-size: clamp(0.8rem, 2vw, 1rem);
            text-align: center;
            max-width: min(250px, 90%);
        }

        .enemy-examples {
            display: flex;
            justify-content: center;
            gap: clamp(15px, 3vw, 20px);
            margin: clamp(20px, 4vw, 30px) 0;
            flex-wrap: wrap;
        }

        .enemy-example {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(8px, 1.5vw, 10px);
            padding: clamp(10px, 2vw, 15px);
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid var(--neon-red);
            min-width: min(150px, 45%);
        }

        .enemy-name {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.9rem, 2vw, 1rem);
            color: var(--neon-red);
            font-weight: bold;
        }

        .enemy-behavior {
            color: #ddd;
            font-size: clamp(0.7rem, 1.8vw, 0.9rem);
            text-align: center;
            max-width: min(140px, 100%);
        }

        .lives-explanation {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(15px, 3vw, 20px);
            margin: clamp(20px, 4vw, 30px) 0;
            padding: clamp(15px, 3vw, 20px);
            background: rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            border: 2px solid var(--neon-blue);
        }

        .life-icon {
            width: clamp(35px, 8vw, 50px);
            height: clamp(35px, 8vw, 50px);
        }

        .life-icon svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 8px var(--neon-blue));
        }

        .life-text {
            color: white;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            text-align: center;
            max-width: min(500px, 90%);
        }

        /* √âcran Mission Failed am√©lior√© */
        .mission-failed {
            text-align: center;
            max-width: min(700px, 90vw);
            padding: clamp(25px, 5vw, 40px);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.9), 
                rgba(40, 0, 0, 0.9));
            border-radius: 30px;
            border: 3px solid var(--neon-red);
            box-shadow: 
                0 0 60px rgba(255, 51, 51, 0.4),
                inset 0 0 30px rgba(255, 51, 51, 0.2);
            backdrop-filter: blur(20px);
        }

        .mission-failed h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 8vw, 4.5rem);
            color: var(--neon-red);
            text-shadow: 
                0 0 20px var(--neon-red),
                0 0 40px rgba(255, 51, 51, 0.7);
            margin-bottom: clamp(20px, 4vw, 30px);
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: failedGlow 2s infinite alternate;
        }

        @keyframes failedGlow {
            0% { text-shadow: 0 0 20px var(--neon-red), 0 0 40px rgba(255, 51, 51, 0.7); }
            100% { text-shadow: 0 0 30px var(--neon-red), 0 0 60px rgba(255, 51, 51, 0.9); }
        }

        .score-results {
            background: linear-gradient(to right, 
                rgba(255, 51, 51, 0.1), 
                rgba(255, 0, 122, 0.1));
            border-radius: 20px;
            padding: clamp(20px, 4vw, 30px);
            margin: clamp(20px, 4vw, 30px) 0;
            border: 2px solid rgba(255, 51, 51, 0.3);
            box-shadow: 
                0 0 30px rgba(255, 51, 51, 0.2),
                inset 0 0 20px rgba(255, 51, 51, 0.1);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: clamp(15px, 3vw, 20px) 0;
            font-size: clamp(1rem, 3vw, 1.3rem);
            padding: clamp(8px, 2vw, 10px) 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .score-item:last-child {
            border-bottom: none;
        }

        .score-label {
            color: #ddd;
            font-weight: bold;
        }

        .score-value {
            color: var(--neon-yellow);
            font-weight: bold;
            font-size: clamp(1.1rem, 3vw, 1.5rem);
            text-shadow: 0 0 10px var(--neon-yellow);
        }

        .highscore-value {
            color: var(--neon-green);
            font-weight: bold;
            font-size: clamp(1.3rem, 3.5vw, 1.8rem);
            text-shadow: 
                0 0 15px var(--neon-green),
                0 0 30px rgba(57, 255, 20, 0.5);
            animation: highscorePulse 2s infinite alternate;
        }

        @keyframes highscorePulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        /* Mode pause */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0.85), 
                rgba(0, 20, 40, 0.9));
            backdrop-filter: blur(15px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 90;
            flex-direction: column;
            gap: clamp(20px, 4vw, 30px);
        }

        .pause-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2.5rem, 8vw, 4rem);
            background: linear-gradient(to right, var(--neon-blue), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 242, 255, 0.5);
            margin-bottom: clamp(15px, 3vw, 20px);
        }

        .pause-stats {
            background: rgba(0, 0, 0, 0.5);
            padding: clamp(20px, 4vw, 25px);
            border-radius: 20px;
            border: 2px solid var(--neon-blue);
            min-width: min(300px, 80%);
        }

        .pause-stats div {
            margin: clamp(12px, 2.5vw, 15px) 0;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            display: flex;
            justify-content: space-between;
        }

        .pause-stats span:first-child {
            color: var(--neon-blue);
        }

        .pause-stats span:last-child {
            color: var(--neon-yellow);
            font-weight: bold;
        }

        .hidden { 
            display: none !important; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }

        /* Animation d'invincibilit√© am√©lior√©e */
        .player-invincible {
            animation: playerBlink 0.5s infinite alternate;
        }

        @keyframes playerBlink {
            0% { 
                opacity: 0.3;
                filter: brightness(2) drop-shadow(0 0 20px var(--neon-blue));
            }
            100% { 
                opacity: 1;
                filter: brightness(1) drop-shadow(0 0 10px var(--neon-blue));
            }
        }

        /* Mode paysage sur mobile - cache le jeu */
        @media (orientation: landscape) and (max-width: 768px) {
            .orientation-warning {
                display: flex;
            }
            
            #game-container:not(.allow-portrait) {
                display: none;
            }
            
            #mobile-controls {
                opacity: 0.3;
            }
        }

        @media (max-height: 700px) {
            #mobile-controls {
                bottom: max(15px, var(--safe-area-bottom));
                padding: 0 clamp(15px, 3vw, 25px);
            }
            
            .joystick-container {
                width: clamp(110px, 25vw, 180px);
                height: clamp(110px, 25vw, 180px);
            }
            
            .action-btn {
                width: clamp(100px, 22vw, 140px);
                height: clamp(100px, 22vw, 140px);
                margin-bottom: clamp(15px, 3vw, 30px);
            }
            
            .hud {
                top: max(10px, var(--safe-area-top));
            }
            
            .start-content h1 {
                font-size: clamp(1.8rem, 6vw, 3rem);
            }
        }

        @media (max-width: 350px) {
            .hud {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            
            .score-display, .lives-container {
                width: auto;
            }
            
            .tutorial-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .enemy-examples {
                flex-direction: column;
                align-items: center;
            }
            
            .enemy-example {
                width: 90%;
            }
        }

        @media (min-width: 1024px) and (orientation: landscape) {
            .orientation-warning {
                display: none;
            }
            
            #mobile-controls {
                display: none;
            }
            
            .hud {
                top: max(30px, var(--safe-area-top));
                padding: 0 40px;
            }
            
            .score-display {
                font-size: 36px;
                padding: 15px 30px;
            }
            
            .heart {
                width: 40px;
                height: 40px;
            }
            
            .lvl-display {
                font-size: 28px;
                padding: 12px 30px;
                top: max(30px, var(--safe-area-top));
            }
            
            .combo-display {
                font-size: 28px;
                padding: 15px 25px;
                right: 30px;
            }
            
            .mission-btn {
                width: 160px;
                height: 160px;
                font-size: 32px;
                margin: 50px;
            }
            
            .go-btn {
                width: 200px;
                height: 200px;
                font-size: 42px;
                margin: 50px;
            }
            
            .next-btn {
                width: 140px;
                height: 140px;
                font-size: 26px;
                margin: 40px;
            }
            
            .start-content h1 {
                font-size: clamp(3rem, 8vw, 5.5rem);
            }
        }
    </style>
</head>
<body>

<div class="orientation-warning">
    <div>
        <h2>üîÑ Tournez votre appareil</h2>
        <p>Pour une meilleure exp√©rience de jeu, veuillez utiliser votre appareil en mode portrait.</p>
    </div>
</div>

<div id="game-container">
    <div class="hud">
        <div class="score-display" id="score-display">0</div>
        <div class="lives-container" id="lives-container">
            <div class="heart" id="heart-1">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-2">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-3">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
        </div>
    </div>

    <div class="lvl-display" id="lvl-display">LVL 1</div>
    <div class="combo-display" id="combo-display">COMBO x0</div>

    <!-- √âcran de d√©marrage principal -->
    <div id="start-screen" class="overlay">
        <div class="start-content">
            <h1>NEON DEVIL<br>MISSION EDITION</h1>
            <p>Survive dans l'ar√®ne n√©on. √âliminez les vagues d'ennemis. Devenez une l√©gende.</p>
            <button class="mission-btn" onclick="Game.showTutorial(1)" id="play-btn" aria-label="Jouer">
                START
            </button>
        </div>
    </div>

    <!-- √âcrans de tutoriel -->
    <div id="tutorial-1" class="overlay hidden">
        <div class="tutorial-screen">
            <div class="tutorial-title">CONTROLES</div>
            <div class="tutorial-subtitle">JOYSTICK DE D√âPLACEMENT</div>
            <div class="tutorial-text">
                <p>Le joystick √† gauche contr√¥le votre vaisseau :</p>
                <p>‚Ä¢ Glissez votre doigt pour d√©placer le vaisseau</p>
                <p>‚Ä¢ Plus vous tirez loin, plus vous allez vite</p>
                <p>‚Ä¢ Rel√¢chez pour revenir au centre</p>
                <p>‚Ä¢ √âvitez les ennemis en man≈ìuvrant</p>
            </div>
            <div class="tutorial-controls">
                <div class="tutorial-control-demo">
                    <div class="joystick-container">
                        <div class="joystick-boundary"></div>
                        <div class="joystick-thumb"></div>
                    </div>
                    <div class="control-label">JOYSTICK</div>
                    <div class="control-description">D√©placez votre vaisseau dans toutes les directions</div>
                </div>
            </div>
            <button class="next-btn" onclick="Game.showTutorial(2)" id="next-btn-1" aria-label="Suivant">
                NEXT
            </button>
        </div>
    </div>

    <div id="tutorial-2" class="overlay hidden">
        <div class="tutorial-screen">
            <div class="tutorial-title">CONTROLES</div>
            <div class="tutorial-subtitle">BOUTON DE TIR</div>
            <div class="tutorial-text">
                <p>Le bouton √† droite contr√¥le vos armes :</p>
                <p>‚Ä¢ Touchez pour tirer des projectiles</p>
                <p>‚Ä¢ Maintenez pour tir automatique</p>
                <p>‚Ä¢ Touchez les ennemis pour les d√©truire</p>
                <p>‚Ä¢ Chaque touche rapporte des points</p>
            </div>
            <div class="tutorial-controls">
                <div class="tutorial-control-demo">
                    <div class="action-btn">
                        <div class="target-icon">
                            <div class="target-cross"></div>
                            <div class="target-center"></div>
                        </div>
                    </div>
                    <div class="control-label">BOUTON DE TIR</div>
                    <div class="control-description">Tirez sur les ennemis pour les d√©truire</div>
                </div>
            </div>
            <div style="display: flex; gap: 20px; margin-top: 30px;">
                <button class="next-btn" onclick="Game.showTutorial(1)" aria-label="Retour">
                    BACK
                </button>
                <button class="next-btn" onclick="Game.showTutorial(3)" aria-label="Suivant">
                    NEXT
                </button>
            </div>
        </div>
    </div>

    <div id="tutorial-3" class="overlay hidden">
        <div class="tutorial-screen">
            <div class="tutorial-title">LES ENNEMIS</div>
            <div class="tutorial-subtitle">TYPES D'ALIENS</div>
            <div class="tutorial-text">
                <p>Diff√©rents types d'ennemis vous attaqueront :</p>
                <p>‚Ä¢ Chaque type a un comportement unique</p>
                <p>‚Ä¢ Certains sont rapides, d'autres r√©sistants</p>
                <p>‚Ä¢ Ils vous poursuivent sans rel√¢che</p>
                <p>‚Ä¢ Votre vaisseau tire automatiquement sur le plus proche</p>
            </div>
            <div class="enemy-examples">
                <div class="enemy-example">
                    <div style="width: 50px; height: 50px; background: var(--neon-pink); border-radius: 50%; margin: 10px;"></div>
                    <div class="enemy-name">CERCLE</div>
                    <div class="enemy-behavior">Mouvement circulaire, vitesse moyenne</div>
                </div>
                <div class="enemy-example">
                    <div style="width: 50px; height: 50px; background: var(--neon-purple); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); margin: 10px;"></div>
                    <div class="enemy-name">TRIANGLE</div>
                    <div class="enemy-behavior">Rapide, poursuit agressivement</div>
                </div>
                <div class="enemy-example">
                    <div style="width: 50px; height: 50px; background: var(--neon-yellow); margin: 10px;"></div>
                    <div class="enemy-name">CARR√â</div>
                    <div class="enemy-behavior">R√©sistant, mouvement impr√©visible</div>
                </div>
            </div>
            <div style="display: flex; gap: 20px; margin-top: 30px;">
                <button class="next-btn" onclick="Game.showTutorial(2)" aria-label="Retour">
                    BACK
                </button>
                <button class="next-btn" onclick="Game.showTutorial(4)" aria-label="Suivant">
                    NEXT
                </button>
            </div>
        </div>
    </div>

    <div id="tutorial-4" class="overlay hidden">
        <div class="tutorial-screen">
            <div class="tutorial-title">SYST√àME DE VIES</div>
            <div class="tutorial-subtitle">VOTRE VAISSEAU</div>
            <div class="tutorial-text">
                <p>Vous disposez de 3 vies pour survivre :</p>
                <p>‚Ä¢ Chaque contact avec un ennemi vous co√ªte une vie</p>
                <p>‚Ä¢ Apr√®s avoir perdu une vie, vous √™tes invincible 2 secondes</p>
                <p>‚Ä¢ Perdez vos 3 vies et la mission √©choue</p>
                <p>‚Ä¢ √âvitez les ennemis √† tout prix !</p>
            </div>
            <div class="lives-explanation">
                <div style="display: flex; gap: 20px;">
                    <div class="life-icon">
                        <svg viewBox="0 0 32 29.6">
                            <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                            c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                        </svg>
                    </div>
                    <div class="life-icon">
                        <svg viewBox="0 0 32 29.6">
                            <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                            c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                        </svg>
                    </div>
                    <div class="life-icon">
                        <svg viewBox="0 0 32 29.6">
                            <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                            c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                        </svg>
                    </div>
                </div>
                <div class="life-text">
                    Votre vaisseau a 3 vies. √âvitez les contacts avec les ennemis pour survivre le plus longtemps possible et obtenir un score √©lev√© !
                </div>
            </div>
            <div style="display: flex; gap: 20px; margin-top: 30px;">
                <button class="next-btn" onclick="Game.showTutorial(3)" aria-label="Retour">
                    BACK
                </button>
                <button class="go-btn" onclick="Game.startMission()" aria-label="Commencer la mission">
                    GO!
                </button>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <div class="mission-failed">
            <h1>MISSION FAILED</h1>
            <div class="score-results">
                <div class="score-item">
                    <span class="score-label">SCORE:</span>
                    <span class="score-value" id="final-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">BEST SCORE:</span>
                    <span class="highscore-value" id="best-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">LVL:</span>
                    <span class="score-value" id="final-level">1</span>
                </div>
                <div class="score-item">
                    <span class="score-label">COMBO MAX:</span>
                    <span class="score-value" id="final-combo">x0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">ENNEMIS TU√âS:</span>
                    <span class="score-value" id="final-kills">0</span>
                </div>
            </div>
            <button class="mission-btn" onclick="Game.startMission()" id="restart-btn" aria-label="Recommencer">
                RETRY
            </button>
        </div>
    </div>

    <div id="pause-screen" class="pause-overlay hidden">
        <div class="pause-title">PAUSE</div>
        <div class="pause-stats">
            <div>
                <span>Score:</span>
                <span id="pause-score">0</span>
            </div>
            <div>
                <span>Niveau:</span>
                <span id="pause-level">1</span>
            </div>
            <div>
                <span>Vies:</span>
                <span id="pause-lives">3</span>
            </div>
            <div>
                <span>Ennemis restants:</span>
                <span id="pause-enemies">0</span>
            </div>
        </div>
        <button class="mission-btn" onclick="Game.resume()" id="resume-btn" aria-label="Reprendre">
            RESUME
        </button>
    </div>

    <canvas id="canvas"></canvas>

    <!-- CONTROLES TOUJOURS VISIBLES -->
    <div id="mobile-controls">
        <div class="control-group">
            <div class="joystick-container" id="joystick-container">
                <div class="joystick-boundary"></div>
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="action-btn" id="btn-fire">
                <div class="target-icon">
                    <div class="target-cross"></div>
                    <div class="target-center"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * CONFIGURATION & CONSTANTES - OPTIMIS√âES POUR RESPONSIVE
 */
const CFG = {
    GRAVITY: 0.12,
    FRICTION: 0.93,
    SPEED: 5.0,
    PLAYER_SIZE: 45,
    ENEMY_SPEED_MULTIPLIER: 0.8,
    PROJECTILE_SPEED: 18,
    FIRE_RATE: 3,
    JOYSTICK_RADIUS: 70,
    JOYSTICK_DEADZONE: 0.05,
    JOYSTICK_RESPONSE_CURVE: 1.5,
    WORLD_WIDTH: 4000,
    WORLD_HEIGHT: 2000,
    COLORS: {
        player: '#00f2ff',
        enemyCircle: '#ff007a',
        enemyTriangle: '#bc13fe',
        enemySquare: '#ffd700',
        enemyStar: '#39ff14',
        enemyHexagon: '#ff00ff',
        enemySpiral: '#ff5500',
        enemyDrone: '#aa00ff',
        projectile: '#ff3333',
        nebula1: 'rgba(188, 19, 254, 0.1)',
        nebula2: 'rgba(0, 242, 255, 0.1)',
        nebula3: 'rgba(255, 0, 122, 0.1)'
    },
    PARTICLE_COUNT: {
        stars: 400,
        nebulas: 15,
        backgroundParticles: 100
    }
};

/**
 * MOTEUR DE JEU - AM√âLIOR√â AVEC TUTORIEL
 */
const Game = {
    canvas: document.getElementById('canvas'),
    ctx: null,
    width: window.innerWidth,
    height: window.innerHeight,
    player: null,
    enemies: [],
    projectiles: [],
    particles: [],
    stars: [],
    nebulas: [],
    backgroundParticles: [],
    level: 1,
    score: 0,
    lives: 3,
    keys: {},
    cameraX: 0,
    cameraY: 0,
    isRunning: false,
    spawnTimer: 0,
    enemyCount: 0,
    shotsFired: 0,
    fireCooldown: 0,
    isMobile: false,
    isPortrait: false,
    joystickActive: false,
    joystickX: 0,
    joystickY: 0,
    joystickOrigin: {x: 0, y: 0},
    joystickMaxRadius: CFG.JOYSTICK_RADIUS,
    joystickTouchId: null,
    bestScore: 0,
    gameOver: false,
    explosionParticles: [],
    lastTime: 0,
    deltaTime: 0,
    touchEvents: [],
    combo: 0,
    comboTimeout: null,
    maxCombo: 0,
    enemiesKilled: 0,
    timePlayed: 0,
    shakeIntensity: 0,
    shakeDuration: 0,
    lastJoystickUpdate: 0,
    joystickSmoothing: 0.8,
    autoFireInterval: null,
    currentTutorial: 0,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.detectDevice();
        this.resize();
        
        // Charger le meilleur score
        this.loadBestScore();
        
        // √âv√©nements de redimensionnement
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('orientationchange', () => {
            setTimeout(() => this.resize(), 100);
            this.checkOrientation();
        });
        
        // Input Listeners
        this.setupInput();
        this.setupMobileControls();
        this.generateBackground();
        
        // V√©rifier l'orientation initiale
        this.checkOrientation();
        
        this.loop(0);
    },

    showTutorial(tutorialNum) {
        this.currentTutorial = tutorialNum;
        
        // Cacher tous les √©crans
        document.getElementById('start-screen').classList.add('hidden');
        for (let i = 1; i <= 4; i++) {
            document.getElementById(`tutorial-${i}`).classList.add('hidden');
        }
        
        // Montrer le tutoriel demand√©
        document.getElementById(`tutorial-${tutorialNum}`).classList.remove('hidden');
    },

    checkOrientation() {
        const isPortrait = window.innerHeight > window.innerWidth;
        const isMobile = this.isMobile;
        
        if (isMobile && !isPortrait) {
            document.querySelector('.orientation-warning').style.display = 'flex';
            document.getElementById('game-container').classList.add('allow-portrait');
        } else {
            document.querySelector('.orientation-warning').style.display = 'none';
            document.getElementById('game-container').classList.remove('allow-portrait');
        }
    },

    loadBestScore() {
        const savedScore = localStorage.getItem('neonDevilBestScore');
        this.bestScore = savedScore ? parseInt(savedScore) : 0;
        this.updateBestScoreDisplay();
    },

    saveBestScore() {
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('neonDevilBestScore', this.bestScore.toString());
        }
    },

    updateBestScoreDisplay() {
        document.getElementById('best-score').textContent = this.bestScore;
    },

    detectDevice() {
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isPortrait = window.innerHeight > window.innerWidth;
        
        // Ajuster les param√®tres selon l'appareil
        if (this.isMobile) {
            CFG.SPEED = 4.5;
            CFG.PLAYER_SIZE = Math.min(45, window.innerWidth * 0.05);
            CFG.JOYSTICK_RADIUS = Math.min(70, window.innerWidth * 0.1);
            CFG.PROJECTILE_SPEED = 16;
            CFG.PARTICLE_COUNT.stars = Math.min(400, Math.floor(window.innerWidth * window.innerHeight * 0.0001));
            CFG.JOYSTICK_DEADZONE = 0.03;
            CFG.JOYSTICK_RESPONSE_CURVE = 1.3;
        }
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.isPortrait = this.height > this.width;
        
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        // Ajuster les param√®tres en fonction de la taille de l'√©cran
        if (this.isMobile) {
            CFG.PLAYER_SIZE = Math.max(30, Math.min(45, this.width * 0.04));
            CFG.JOYSTICK_RADIUS = Math.max(40, Math.min(70, this.width * 0.08));
        }
        
        // Recalculer la position du joystick
        this.calculateJoystickOrigin();
        
        // Mettre √† jour le warning d'orientation
        this.checkOrientation();
    },

    calculateJoystickOrigin() {
        const joystickContainer = document.querySelector('.joystick-container');
        if (!joystickContainer) return;
        
        const rect = joystickContainer.getBoundingClientRect();
        this.joystickOrigin.x = rect.left + rect.width / 2;
        this.joystickOrigin.y = rect.top + rect.height / 2;
        this.joystickMaxRadius = Math.min(rect.width / 2 - 20, CFG.JOYSTICK_RADIUS);
    },

    setupInput() {
        // Clavier
        window.addEventListener('keydown', e => {
            if (!this.isRunning) return;
            
            this.keys[e.code] = true;
            if (e.code === 'Space' && this.fireCooldown <= 0) {
                e.preventDefault();
                if (this.player && !this.player.invincible) {
                    this.player.fire();
                    this.fireCooldown = CFG.FIRE_RATE;
                }
            }
            if (e.code === 'Escape' || e.code === 'KeyP') {
                if (this.isRunning && !this.gameOver) {
                    this.togglePause();
                }
            }
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
    },

    setupMobileControls() {
        const joystickContainer = document.getElementById('joystick-container');
        const fireBtn = document.getElementById('btn-fire');
        const joystickThumb = document.getElementById('joystick-thumb');
        
        if (!joystickContainer) return;
        
        this.calculateJoystickOrigin();
        
        // Gestion du joystick
        const handleJoystickStart = (clientX, clientY, touchId = null) => {
            if (!this.isRunning) return;
            
            this.joystickActive = true;
            if (touchId !== null) this.joystickTouchId = touchId;
            joystickThumb.classList.add('active');
            this.updateJoystickPosition(clientX, clientY, true);
        };
        
        const handleJoystickMove = (clientX, clientY) => {
            if (!this.joystickActive || !this.isRunning) return;
            this.updateJoystickPosition(clientX, clientY, false);
        };
        
        const handleJoystickEnd = (touchId = null) => {
            if (touchId !== null && this.joystickTouchId !== touchId) return;
            
            this.joystickActive = false;
            this.joystickX = 0;
            this.joystickY = 0;
            this.joystickTouchId = null;
            joystickThumb.classList.remove('active');
            joystickThumb.style.transform = 'translate(-50%, -50%)';
        };
        
        // Touch events
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            handleJoystickStart(touch.clientX, touch.clientY, touch.identifier);
        }, { passive: false, capture: true });
        
        document.addEventListener('touchmove', (e) => {
            if (!this.joystickActive || !this.joystickTouchId) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleJoystickMove(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        }, { passive: false, capture: true });
        
        document.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        }, { capture: true });
        
        document.addEventListener('touchcancel', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        }, { capture: true });
        
        // Mouse events pour desktop
        joystickContainer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleJoystickStart(e.clientX, e.clientY);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!this.joystickActive) return;
            e.preventDefault();
            e.stopPropagation();
            handleJoystickMove(e.clientX, e.clientY);
        });
        
        document.addEventListener('mouseup', (e) => {
            if (this.joystickActive) {
                e.preventDefault();
                e.stopPropagation();
                handleJoystickEnd();
            }
        });
        
        // Bouton de tir
        const handleFireStart = () => {
            if (!this.isRunning) return;
            
            if (this.fireCooldown <= 0 && this.player && !this.player.invincible) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
                this.startAutoFire();
            }
            fireBtn.classList.add('active');
        };
        
        const handleFireEnd = () => {
            fireBtn.classList.remove('active');
            this.stopAutoFire();
        };
        
        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireStart();
        }, { passive: false });
        
        fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireStart();
        });
        
        fireBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mouseleave', handleFireEnd);
    },

    startAutoFire() {
        if (this.autoFireInterval) clearInterval(this.autoFireInterval);
        
        this.autoFireInterval = setInterval(() => {
            if (this.isRunning && this.player && !this.player.invincible && this.fireCooldown <= 0) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
            }
        }, 150);
    },
    
    stopAutoFire() {
        if (this.autoFireInterval) {
            clearInterval(this.autoFireInterval);
            this.autoFireInterval = null;
        }
    },

    updateJoystickPosition(clientX, clientY, isStart = false) {
        const joystickThumb = document.getElementById('joystick-thumb');
        const now = Date.now();
        
        if (now - this.lastJoystickUpdate < 16 && !isStart) return;
        this.lastJoystickUpdate = now;
        
        this.calculateJoystickOrigin();
        
        let deltaX = clientX - this.joystickOrigin.x;
        let deltaY = clientY - this.joystickOrigin.y;
        let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        let normalizedDistance = Math.min(distance / this.joystickMaxRadius, 1);
        let responseFactor = Math.pow(normalizedDistance, CFG.JOYSTICK_RESPONSE_CURVE);
        
        if (distance > this.joystickMaxRadius) {
            deltaX = (deltaX / distance) * this.joystickMaxRadius;
            deltaY = (deltaY / distance) * this.joystickMaxRadius;
            distance = this.joystickMaxRadius;
            normalizedDistance = 1;
            responseFactor = 1;
        }
        
        if (distance < this.joystickMaxRadius * CFG.JOYSTICK_DEADZONE) {
            deltaX = 0;
            deltaY = 0;
            normalizedDistance = 0;
            responseFactor = 0;
        }
        
        joystickThumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        
        this.joystickX = (deltaX / this.joystickMaxRadius) * responseFactor;
        this.joystickY = (deltaY / this.joystickMaxRadius) * responseFactor;
    },

    togglePause() {
        if (this.isRunning && !this.gameOver) {
            this.isRunning = false;
            document.getElementById('pause-screen').classList.remove('hidden');
            document.getElementById('pause-score').textContent = this.score;
            document.getElementById('pause-level').textContent = this.level;
            document.getElementById('pause-lives').textContent = this.lives;
            document.getElementById('pause-enemies').textContent = this.enemies.length;
            document.getElementById('resume-btn').focus();
            this.stopAutoFire();
        }
    },

    resume() {
        this.isRunning = true;
        document.getElementById('pause-screen').classList.add('hidden');
        this.canvas.focus();
    },

    startMission() {
        console.log("Mission d√©marre!");
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.enemies = [];
        this.projectiles = [];
        this.particles = [];
        this.explosionParticles = [];
        this.enemyCount = 0;
        this.enemiesKilled = 0;
        this.shotsFired = 0;
        this.fireCooldown = 0;
        this.isRunning = true;
        this.gameOver = false;
        this.cameraX = -CFG.WORLD_WIDTH / 2 + this.width / 2;
        this.cameraY = -CFG.WORLD_HEIGHT / 2 + this.height / 2;
        this.lastTime = 0;
        this.timePlayed = 0;
        this.combo = 0;
        this.maxCombo = 0;
        
        // R√©initialiser le joystick
        this.joystickActive = false;
        this.joystickX = 0;
        this.joystickY = 0;
        const joystickThumb = document.getElementById('joystick-thumb');
        if (joystickThumb) {
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            joystickThumb.classList.remove('active');
        }
        
        // Arr√™ter le tir automatique
        this.stopAutoFire();
        
        // Cacher tous les √©crans de tutoriel et overlay
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('pause-screen').classList.add('hidden');
        for (let i = 1; i <= 4; i++) {
            document.getElementById(`tutorial-${i}`).classList.add('hidden');
        }
        
        // Position initiale au centre du monde
        this.player = new Player(0, 0);
        this.spawnTimer = 0;
        this.updateHUD();
        this.updateLevelDisplay();
        this.updateComboDisplay();
        
        this.updateHearts();
        
        // Nettoyer les classes d'invincibilit√©
        this.canvas.classList.remove('player-invincible');
        
        this.canvas.focus();
    },

    generateBackground() {
        // G√©n√©rer les √©toiles
        this.stars = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.stars; i++) {
            this.stars.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: Math.random() * 3 + 0.5,
                speed: Math.random() * 0.8 + 0.2,
                opacity: Math.random() * 0.8 + 0.2,
                twinkleSpeed: Math.random() * 0.05 + 0.01,
                twinkleOffset: Math.random() * Math.PI * 2
            });
        }
        
        // G√©n√©rer les n√©buleuses
        this.nebulas = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.nebulas; i++) {
            const size = Math.random() * 800 + 400;
            this.nebulas.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: size,
                color: [CFG.COLORS.nebula1, CFG.COLORS.nebula2, CFG.COLORS.nebula3][Math.floor(Math.random() * 3)],
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: Math.random() * 0.002 - 0.001
            });
        }
        
        // G√©n√©rer les particules de fond
        this.backgroundParticles = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.backgroundParticles; i++) {
            this.backgroundParticles.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: Math.random() * 4 + 1,
                color: [CFG.COLORS.player, CFG.COLORS.enemyCircle, CFG.COLORS.enemyStar][Math.floor(Math.random() * 3)],
                speed: Math.random() * 2 + 0.5,
                direction: Math.random() * Math.PI * 2,
                opacity: Math.random() * 0.3 + 0.1
            });
        }
    },

    canSpawnEnemyAt(x, y, size) {
        if (!this.player) return true;
        
        const playerDist = Math.sqrt(
            Math.pow(x - this.player.x, 2) + 
            Math.pow(y - this.player.y, 2)
        );
        if (playerDist < 300) return false;
        
        for (const enemy of this.enemies) {
            const dist = Math.sqrt(
                Math.pow(x - enemy.x, 2) + 
                Math.pow(y - enemy.y, 2)
            );
            const minDist = (size/2) + (enemy.size/2) + 30;
            if (dist < minDist) {
                return false;
            }
        }
        return true;
    },

    spawnEnemy() {
        const edge = Math.floor(Math.random() * 4);
        let baseX, baseY, vx, vy;
        
        const spawnMargin = 200;
        const worldLeft = -CFG.WORLD_WIDTH/2;
        const worldRight = CFG.WORLD_WIDTH/2;
        const worldTop = -CFG.WORLD_HEIGHT/2;
        const worldBottom = CFG.WORLD_HEIGHT/2;
        
        switch(edge) {
            case 0: // Haut
                baseX = Math.random() * CFG.WORLD_WIDTH + worldLeft;
                baseY = worldTop - spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = Math.random() * 2 + 1;
                break;
            case 1: // Droite
                baseX = worldRight + spawnMargin;
                baseY = Math.random() * CFG.WORLD_HEIGHT + worldTop;
                vx = -Math.random() * 2 - 1;
                vy = (Math.random() - 0.5) * 2;
                break;
            case 2: // Bas
                baseX = Math.random() * CFG.WORLD_WIDTH + worldLeft;
                baseY = worldBottom + spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = -Math.random() * 2 - 1;
                break;
            case 3: // Gauche
                baseX = worldLeft - spawnMargin;
                baseY = Math.random() * CFG.WORLD_HEIGHT + worldTop;
                vx = Math.random() * 2 + 1;
                vy = (Math.random() - 0.5) * 2;
                break;
        }
        
        const enemyTypes = ['circle', 'triangle', 'square', 'star', 'hexagon', 'spiral', 'drone'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const size = 25 + Math.random() * 20 + this.level * 2;
        const x = baseX;
        const y = baseY;
        
        if (this.canSpawnEnemyAt(x, y, size)) {
            this.enemies.push(new Enemy(x, y, vx, vy, type, size));
            this.enemyCount++;
            return true;
        }
        return false;
    },

    updateHUD() {
        document.getElementById('score-display').textContent = this.score;
    },

    updateLevelDisplay() {
        document.getElementById('lvl-display').textContent = `LVL ${this.level}`;
    },

    updateComboDisplay() {
        const comboDisplay = document.getElementById('combo-display');
        comboDisplay.textContent = `COMBO x${this.combo}`;
        
        if (this.combo > 1) {
            comboDisplay.classList.add('active');
        } else {
            comboDisplay.classList.remove('active');
        }
    },

    incrementCombo() {
        this.combo++;
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
        }
        
        this.updateComboDisplay();
        
        if (this.comboTimeout) {
            clearTimeout(this.comboTimeout);
        }
        
        this.comboTimeout = setTimeout(() => {
            if (this.combo > 3) {
                this.createComboText();
            }
            this.combo = 0;
            this.updateComboDisplay();
        }, 3000);
    },

    createComboText() {
        if (!this.player) return;
        
        for (let i = 0; i < 10; i++) {
            this.particles.push(new Particle(
                this.player.x,
                this.player.y,
                CFG.COLORS.enemyStar,
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 8,
                20,
                true
            ));
        }
    },

    updateHearts() {
        for (let i = 1; i <= 3; i++) {
            const heart = document.getElementById(`heart-${i}`);
            if (i <= this.lives) {
                heart.classList.remove('lost');
                if (i === this.lives) {
                    heart.classList.add('pulse');
                    setTimeout(() => heart.classList.remove('pulse'), 500);
                }
            } else {
                heart.classList.add('lost');
                heart.classList.remove('pulse');
            }
        }
    },

    createShipExplosion(x, y) {
        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 3 + Math.random() * 6;
            const size = 4 + Math.random() * 6;
            
            this.explosionParticles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: size,
                life: 1.0,
                color: CFG.COLORS.player,
                decay: 0.015 + Math.random() * 0.015
            });
        }
        
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 50;
            const size = 2 + Math.random() * 4;
            
            setTimeout(() => {
                const ex = x + Math.cos(angle) * distance;
                const ey = y + Math.sin(angle) * distance;
                
                for (let j = 0; j < 15; j++) {
                    const a = Math.random() * Math.PI * 2;
                    const s = 1 + Math.random() * 3;
                    
                    this.explosionParticles.push({
                        x: ex,
                        y: ey,
                        vx: Math.cos(a) * s,
                        vy: Math.sin(a) * s,
                        size: size,
                        life: 0.8,
                        color: '#ff5500',
                        decay: 0.02 + Math.random() * 0.02
                    });
                }
            }, Math.random() * 500);
        }
        
        this.screenShake(10, 500);
    },

    screenShake(intensity, duration) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
    },

    die() {
        if (this.gameOver || !this.player) return;
        
        if (this.player.invincible) return;
        
        this.lives--;
        this.updateHearts();
        
        if (this.lives > 0) {
            this.spawnExplosion(this.player.x, this.player.y, CFG.COLORS.enemyCircle);
            
            this.player.invincible = true;
            this.player.invincibleTimer = 120;
            
            this.player.x = 0;
            this.player.y = 0;
            this.player.vx = 0;
            this.player.vy = 0;
            
            this.canvas.classList.add('player-invincible');
            
            this.combo = 0;
            this.updateComboDisplay();
            
            this.stopAutoFire();
        } else {
            this.gameOver = true;
            this.isRunning = false;
            
            this.createShipExplosion(this.player.x, this.player.y);
            
            this.canvas.classList.remove('player-invincible');
            
            this.stopAutoFire();
            
            setTimeout(() => {
                this.player = null;
                
                this.saveBestScore();
                
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('best-score').textContent = this.bestScore;
                document.getElementById('final-level').textContent = this.level;
                document.getElementById('final-combo').textContent = `x${this.maxCombo}`;
                document.getElementById('final-kills').textContent = this.enemiesKilled;
                
                setTimeout(() => document.getElementById('restart-btn').focus(), 100);
            }, 1500);
        }
    },

    spawnExplosion(x, y, color) {
        for(let i=0; i<20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    },

    findNearestEnemy() {
        let nearest = null;
        let nearestDist = Infinity;
        
        for (const enemy of this.enemies) {
            const dx = enemy.x - this.player.x;
            const dy = enemy.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist) {
                nearestDist = dist;
                nearest = enemy;
            }
        }
        
        return nearest;
    },

    loop(timestamp) {
        this.deltaTime = Math.min(timestamp - this.lastTime, 32);
        this.lastTime = timestamp;
        
        if (this.isRunning) {
            this.timePlayed += this.deltaTime;
        }
        
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        if (this.isMobile && !this.isPortrait) {
            requestAnimationFrame((t) => this.loop(t));
            return;
        }
        
        if(this.isRunning && this.player) {
            this.update();
            this.draw();
        } else if (this.gameOver) {
            this.updateExplosionParticles();
            this.drawBackground();
            this.draw();
        } else {
            this.drawBackground();
        }
        
        requestAnimationFrame((t) => this.loop(t));
    },

    update() {
        if (!this.player || !this.isRunning) return;
        
        if (this.fireCooldown > 0) {
            this.fireCooldown -= 1;
        }
        
        if (!this.joystickActive) {
            this.joystickX *= 0.7;
            this.joystickY *= 0.7;
            
            if (Math.abs(this.joystickX) < 0.01) this.joystickX = 0;
            if (Math.abs(this.joystickY) < 0.01) this.joystickY = 0;
        }
        
        if ((this.keys['Space'] || this.keys['ShiftLeft']) && this.fireCooldown <= 0 && !this.player.invincible) {
            this.player.fire();
            this.fireCooldown = CFG.FIRE_RATE;
        }
        
        this.spawnTimer++;
        const spawnRate = Math.max(5, 40 - this.level * 2);
        if(this.spawnTimer >= spawnRate) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }
        
        this.player.update();
        
        if (this.player && !this.player.invincible) {
            let targetCamX = this.player.x - this.width / 2;
            let targetCamY = this.player.y - this.height / 2;
            
            const maxCamX = CFG.WORLD_WIDTH/2 - this.width;
            const maxCamY = CFG.WORLD_HEIGHT/2 - this.height;
            const minCamX = -CFG.WORLD_WIDTH/2;
            const minCamY = -CFG.WORLD_HEIGHT/2;
            
            targetCamX = Math.max(minCamX, Math.min(targetCamX, maxCamX));
            targetCamY = Math.max(minCamY, Math.min(targetCamY, maxCamY));
            
            this.cameraX += (targetCamX - this.cameraX) * 0.08;
            this.cameraY += (targetCamY - this.cameraY) * 0.08;
        }
        
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            enemy.update();
            
            if(this.player && !this.player.invincible && this.circleIntersect(this.player, enemy)) {
                this.die();
                enemy.markForRemoval = true;
            }
            
            if (enemy.x < -CFG.WORLD_WIDTH/2 - 200 || enemy.x > CFG.WORLD_WIDTH/2 + 200 ||
                enemy.y < -CFG.WORLD_HEIGHT/2 - 200 || enemy.y > CFG.WORLD_HEIGHT/2 + 200) {
                enemy.markForRemoval = true;
            }
        }
        
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.update();
            
            for (let j = this.enemies.length - 1; j >= 0; j--) {
                const enemy = this.enemies[j];
                if (this.circleIntersect(proj, enemy)) {
                    this.score += 100 * this.combo;
                    this.enemiesKilled++;
                    this.incrementCombo();
                    this.spawnExplosion(enemy.x, enemy.y, enemy.color);
                    enemy.markForRemoval = true;
                    this.projectiles.splice(i, 1);
                    this.enemyCount--;
                    this.updateHUD();
                    this.screenShake(3, 100);
                    break;
                }
            }
            
            if (proj.life <= 0) {
                this.projectiles.splice(i, 1);
            }
        }
        
        this.enemies = this.enemies.filter(en => !en.markForRemoval);
        
        this.particles = this.particles.filter(p => p.update());
        
        this.updateBackgroundParticles();
        
        if (this.shakeDuration > 0) {
            this.shakeDuration -= this.deltaTime;
        } else {
            this.shakeIntensity = 0;
        }
        
        if(this.score >= this.level * 1500) {
            this.level++;
            this.updateLevelDisplay();
            this.screenShake(5, 200);
            
            for (let i = 0; i < 30; i++) {
                this.particles.push(new Particle(
                    this.player ? this.player.x : 0,
                    this.player ? this.player.y : 0,
                    CFG.COLORS.nebula2,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    25,
                    true
                ));
            }
        }
    },

    updateBackgroundParticles() {
        for (const p of this.backgroundParticles) {
            p.x += Math.cos(p.direction) * p.speed;
            p.y += Math.sin(p.direction) * p.speed;
            
            if (p.x < -CFG.WORLD_WIDTH/2 || p.x > CFG.WORLD_WIDTH/2) {
                p.direction = Math.PI - p.direction;
            }
            if (p.y < -CFG.WORLD_HEIGHT/2 || p.y > CFG.WORLD_HEIGHT/2) {
                p.direction = -p.direction;
            }
        }
    },

    updateExplosionParticles() {
        for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
            const p = this.explosionParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= p.decay;
            
            if (p.life <= 0) {
                this.explosionParticles.splice(i, 1);
            }
        }
    },

    circleIntersect(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius1 = obj1.size ? obj1.size/2 : (obj1.radius || 0);
        const radius2 = obj2.size ? obj2.size/2 : (obj2.radius || 0);
        return distance < radius1 + radius2;
    },

    drawBackground() {
        const gradient = this.ctx.createRadialGradient(
            this.width/2, this.height/2, 0,
            this.width/2, this.height/2, Math.max(this.width, this.height)/2
        );
        gradient.addColorStop(0, '#050510');
        gradient.addColorStop(0.5, '#03031a');
        gradient.addColorStop(1, '#010125');
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        if (this.shakeIntensity > 0) {
            const shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
            const shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
            this.ctx.translate(shakeX, shakeY);
        }
        
        this.ctx.save();
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        this.nebulas.forEach(nebula => {
            this.ctx.save();
            this.ctx.translate(nebula.x, nebula.y);
            this.ctx.rotate(nebula.rotation);
            
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, nebula.size);
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'transparent');
            
            this.ctx.fillStyle = gradient;
            this.ctx.globalAlpha = 0.3;
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, nebula.size, nebula.size * 0.5, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.restore();
            
            nebula.rotation += nebula.rotationSpeed;
        });
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        this.stars.forEach(star => {
            const twinkle = Math.sin(this.timePlayed * 0.001 * star.twinkleSpeed + star.twinkleOffset) * 0.3 + 0.7;
            this.ctx.globalAlpha = star.opacity * twinkle;
            const x = star.x - this.cameraX * star.speed * 0.05;
            const y = star.y - this.cameraY * star.speed * 0.05;
            
            if (x > -100 && x < this.width + 100 && y > -100 && y < this.height + 100) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
        
        this.backgroundParticles.forEach(p => {
            this.ctx.globalAlpha = p.opacity;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.globalAlpha = 1;
        this.ctx.restore();
        
        if (this.shakeIntensity > 0) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
    },

    draw() {
        this.drawBackground();
        
        this.ctx.save();
        
        if (this.shakeIntensity > 0) {
            const shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
            const shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
            this.ctx.translate(shakeX, shakeY);
        }
        
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        this.drawGrid();
        
        this.projectiles.forEach(p => p.draw(this.ctx));
        
        this.enemies.forEach(en => en.draw(this.ctx));
        
        this.particles.forEach(p => p.draw(this.ctx));
        
        this.explosionParticles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.shadowBlur = p.life * 15;
            this.ctx.shadowColor = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1;
            this.ctx.shadowBlur = 0;
        });
        
        if (this.player) {
            this.player.draw(this.ctx);
        }
        
        this.ctx.restore();
    },

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.05)';
        this.ctx.lineWidth = 1;
        let step = 150;
        let startX = Math.floor((this.cameraX - this.width) / step) * step;
        let startY = Math.floor((this.cameraY - this.height) / step) * step;
        
        for(let x = startX; x < startX + this.width * 2 + step; x += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);
            this.ctx.lineTo(x, startY + this.height * 2 + step);
            this.ctx.stroke();
        }
        
        for(let y = startY; y < startY + this.height * 2 + step; y += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(startX, y);
            this.ctx.lineTo(startX + this.width * 2 + step, y);
            this.ctx.stroke();
        }
        
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.2)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 500, 0, Math.PI * 2);
        this.ctx.stroke();
    }
};

/**
 * CLASSES DES OBJETS
 */
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.size = Game.isMobile ? CFG.PLAYER_SIZE * 0.9 : CFG.PLAYER_SIZE;
        this.angle = 0;
        this.engineParticles = 0;
        this.wingFlap = 0;
        this.autoRotateSpeed = 0.1;
        
        this.invincible = false;
        this.invincibleTimer = 0;
        
        this.engineGlow = 0;
        this.trail = [];
        
        this.centerForce = 0.0008;
    }

    updateInvincibility() {
        if (this.invincible) {
            this.invincibleTimer--;
            
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
                this.invincibleTimer = 0;
                Game.canvas.classList.remove('player-invincible');
            }
        }
    }

    fire() {
        if (this.invincible) return;
        
        Game.shotsFired++;
        const proj = new Projectile(
            this.x + Math.cos(this.angle) * this.size/2,
            this.y + Math.sin(this.angle) * this.size/2,
            Math.cos(this.angle) * CFG.PROJECTILE_SPEED,
            Math.sin(this.angle) * CFG.PROJECTILE_SPEED,
            this.angle
        );
        Game.projectiles.push(proj);
        Game.updateHUD();
        
        this.vx -= Math.cos(this.angle) * 1.2;
        this.vy -= Math.sin(this.angle) * 1.2;
        
        Game.screenShake(1, 50);
    }

    update() {
        this.updateInvincibility();
        
        if(Game.keys['ArrowLeft'] || Game.keys['KeyA']) this.vx -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowRight'] || Game.keys['KeyD']) this.vx += CFG.SPEED * 0.2;
        if(Game.keys['ArrowUp'] || Game.keys['KeyW']) this.vy -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowDown'] || Game.keys['KeyS']) this.vy += CFG.SPEED * 0.2;
        
        if (Game.joystickActive || Math.abs(Game.joystickX) > 0.01 || Math.abs(Game.joystickY) > 0.01) {
            const sensitivity = 0.4;
            const joyX = Game.joystickX;
            const joyY = Game.joystickY;
            
            const force = (joyX * joyX + joyY * joyY) * 1.5;
            
            this.vx += joyX * CFG.SPEED * sensitivity * force;
            this.vy += joyY * CFG.SPEED * sensitivity * force;
        }
        
        this.wingFlap += 0.2;
        this.engineGlow = (this.engineGlow + 0.1) % (Math.PI * 2);
        
        const nearestEnemy = Game.findNearestEnemy();
        if (nearestEnemy) {
            const dx = nearestEnemy.x - this.x;
            const dy = nearestEnemy.y - this.y;
            const targetAngle = Math.atan2(dy, dx);
            
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            this.angle += angleDiff * this.autoRotateSpeed;
        }
        
        const centerX = Game.cameraX + Game.width / 2;
        const centerY = Game.cameraY + Game.height / 2;
        const cdx = centerX - this.x;
        const cdy = centerY - this.y;
        const distance = Math.sqrt(cdx * cdx + cdy * cdy);
        
        if(distance > 800) {
            this.vx += cdx * this.centerForce;
            this.vy += cdy * this.centerForce;
        }
        
        this.vx *= CFG.FRICTION;
        this.vy *= CFG.FRICTION;
        
        this.x += this.vx;
        this.y += this.vy;
        
        const maxX = CFG.WORLD_WIDTH/2 - 100;
        const maxY = CFG.WORLD_HEIGHT/2 - 100;
        this.x = Math.max(-maxX, Math.min(this.x, maxX));
        this.y = Math.max(-maxY, Math.min(this.y, maxY));
        
        this.trail.push({x: this.x, y: this.y, angle: this.angle});
        if (this.trail.length > 15) this.trail.shift();
        
        this.engineParticles++;
        if(this.engineParticles > 3 && (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1)) {
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            for(let i = 0; i < 3; i++) {
                const angle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                const power = Math.random() * speed * 0.5;
                Game.particles.push(new Particle(
                    this.x - Math.cos(this.angle) * this.size/2,
                    this.y - Math.sin(this.angle) * this.size/2,
                    CFG.COLORS.player,
                    Math.cos(angle) * power,
                    Math.sin(angle) * power,
                    15
                ));
            }
            this.engineParticles = 0;
        }
    }

    draw(ctx) {
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.3;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            ctx.rotate(point.angle);
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = CFG.COLORS.player;
            
            ctx.beginPath();
            ctx.moveTo(this.size/4, 0);
            ctx.lineTo(-this.size/4, -this.size/4);
            ctx.lineTo(-this.size/4, this.size/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        const wingOffset = Math.sin(this.wingFlap) * 4;
        const enginePulse = Math.sin(this.engineGlow) * 0.2 + 0.8;
        
        if (!this.invincible) {
            ctx.shadowBlur = 40;
            ctx.shadowColor = CFG.COLORS.player;
        } else {
            ctx.shadowBlur = 60;
            ctx.shadowColor = '#ffffff';
        }
        
        const gradient = ctx.createLinearGradient(-this.size/2, 0, this.size/2, 0);
        gradient.addColorStop(0, '#0088ff');
        gradient.addColorStop(0.5, CFG.COLORS.player);
        gradient.addColorStop(1, '#00aaff');
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        
        ctx.moveTo(this.size/2, 0);
        ctx.lineTo(this.size/4, -this.size/3);
        ctx.lineTo(-this.size/4, -this.size/2 + wingOffset);
        ctx.lineTo(-this.size/2, -this.size/4);
        ctx.lineTo(-this.size/2, this.size/4);
        ctx.lineTo(-this.size/4, this.size/2 - wingOffset);
        ctx.lineTo(this.size/4, this.size/3);
        ctx.closePath();
        
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(0, 100, 255, 0.6)';
        ctx.beginPath();
        ctx.ellipse(this.size/6, 0, this.size/3, this.size/4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(150, 220, 255, 0.4)';
        ctx.beginPath();
        ctx.ellipse(this.size/3, -this.size/8, this.size/6, this.size/8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255, ${100 + Math.floor(enginePulse * 155)}, 0, 0.9)`;
        ctx.fillRect(-this.size/2, -this.size/8, this.size/6, this.size/4);
        ctx.fillRect(-this.size/2 + this.size/5, -this.size/8, this.size/6, this.size/4);
        
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.size/2 - 10, -this.size/10, 15, this.size/5);
        
        if (Game.fireCooldown > CFG.FIRE_RATE - 5) {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(this.size/2, -this.size/12, 8, this.size/6);
        }
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, vx, vy, angle) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = Game.isMobile ? 5 : 6;
        this.life = 150;
        this.angle = angle;
        this.trail = [];
        this.sparkleTimer = 0;
    }
    
    update() {
        this.sparkleTimer++;
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 8) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        if (Math.random() < 0.8) {
            Game.particles.push(new Particle(
                this.x,
                this.y,
                CFG.COLORS.projectile,
                -this.vx * 0.2 + (Math.random() - 0.5) * 0.5,
                -this.vy * 0.2 + (Math.random() - 0.5) * 0.5,
                8
            ));
        }
        
        return this.life > 0;
    }
    
    draw(ctx) {
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.6;
            const size = this.radius * (i / this.trail.length);
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.fillStyle = `rgba(255, 150, 50, ${alpha})`;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 25;
        ctx.shadowColor = CFG.COLORS.projectile;
        
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 2);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.3, '#ffaa00');
        gradient.addColorStop(0.7, CFG.COLORS.projectile);
        gradient.addColorStop(1, '#990000');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, -this.radius);
        ctx.lineTo(this.radius * 4, 0);
        ctx.lineTo(0, this.radius);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.radius, 0, this.radius/2, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.sparkleTimer % 3 === 0) {
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(-this.radius, (Math.random() - 0.5) * this.radius, this.radius/3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, vx, vy, type, size) {
        this.x = x;
        this.y = y;
        this.vx = vx * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.08);
        this.vy = vy * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.08);
        this.type = type;
        this.size = Game.isMobile ? size * 0.85 : size;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.08;
        this.markForRemoval = false;
        this.pulse = 0;
        this.animationTime = 0;
        this.color = CFG.COLORS[`enemy${type.charAt(0).toUpperCase() + type.slice(1)}`] || CFG.COLORS.enemyCircle;
        this.hitFlash = 0;
        this.trail = [];
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.pulse += 0.06;
        this.animationTime += 0.12;
        
        if (this.hitFlash > 0) this.hitFlash--;
        
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 10) this.trail.shift();
        
        if (Game.player && !Game.player.invincible) {
            const dx = Game.player.x - this.x;
            const dy = Game.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if(distance < 800) {
                this.vx += dx * 0.0002 * Game.level;
                this.vy += dy * 0.0002 * Game.level;
                
                if (distance < 200) {
                    this.vx -= dx * 0.0005;
                    this.vy -= dy * 0.0005;
                }
            }
        }
        
        Game.enemies.forEach(other => {
            if (other !== this) {
                const odx = other.x - this.x;
                const ody = other.y - this.y;
                const odist = Math.sqrt(odx * odx + ody * ody);
                const minDist = (this.size/2) + (other.size/2) + 20;
                
                if (odist < minDist && odist > 0) {
                    const force = 0.1;
                    this.vx -= (odx / odist) * force;
                    this.vy -= (ody / odist) * force;
                }
            }
        });
        
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        const maxSpeed = 4 + Game.level * 0.15;
        if(speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
        }
    }

    draw(ctx) {
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.4;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.size/4 * (i/this.trail.length), 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.hitFlash > 0) {
            ctx.shadowBlur = 50;
            ctx.shadowColor = 'white';
        } else {
            ctx.shadowBlur = 30;
            ctx.shadowColor = this.color;
        }
        
        ctx.rotate(this.rotation);
        
        const pulseSize = 1 + Math.sin(this.pulse) * 0.15;
        ctx.scale(pulseSize, pulseSize);
        
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        
        switch(this.type) {
            case 'circle':
                this.drawCircleEnemy(ctx);
                break;
            case 'triangle':
                this.drawTriangleEnemy(ctx);
                break;
            case 'square':
                this.drawSquareEnemy(ctx);
                break;
            case 'star':
                this.drawStarEnemy(ctx);
                break;
            case 'hexagon':
                this.drawHexagonEnemy(ctx);
                break;
            case 'spiral':
                this.drawSpiralEnemy(ctx);
                break;
            case 'drone':
                this.drawDroneEnemy(ctx);
                break;
        }
        
        ctx.restore();
    }
    
    drawCircleEnemy(ctx) {
        for(let i = 0; i < 8; i++) {
            const segmentAngle = (i / 8) * Math.PI * 2 + this.rotation * 2;
            ctx.save();
            ctx.rotate(segmentAngle);
            
            const segmentPulse = Math.sin(this.animationTime * 2 + i) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)}, ${parseInt(this.color.slice(3,5),16)}, ${parseInt(this.color.slice(5,7),16)}, ${0.4 + segmentPulse * 0.3})`;
            
            ctx.beginPath();
            ctx.arc(0, this.size/2.5, this.size/5 * (0.6 + segmentPulse * 0.4), 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#111';
        const mouthOpen = Math.sin(this.animationTime * 3) * 0.4 + 0.6;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/3, 0, Math.PI * mouthOpen);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        const eyeSize = this.size/6 * (0.8 + Math.sin(this.animationTime * 4) * 0.2);
        ctx.beginPath();
        ctx.arc(-this.size/4, -this.size/6, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.size/4, -this.size/6, eyeSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    drawTriangleEnemy(ctx) {
        const trianglePulse = Math.sin(this.animationTime * 2.5) * 0.25;
        
        ctx.beginPath();
        ctx.moveTo(0, -this.size/2 * (1 + trianglePulse));
        ctx.lineTo(this.size/2, this.size/2 * (1 - trianglePulse/2));
        ctx.lineTo(-this.size/2, this.size/2 * (1 - trianglePulse/2));
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.moveTo(0, -this.size/3);
        ctx.lineTo(this.size/3, this.size/4);
        ctx.lineTo(-this.size/3, this.size/4);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'white';
        const blink = Math.sin(this.animationTime * 4) > 0 ? 1 : 0;
        if(blink) {
            ctx.beginPath();
            ctx.arc(-this.size/4, -this.size/8, this.size/8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size/4, -this.size/8, this.size/8, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    drawSquareEnemy(ctx) {
        const squareWobble = Math.sin(this.animationTime * 3) * 0.25;
        
        ctx.save();
        ctx.scale(1 + squareWobble, 1 - squareWobble);
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(this.animationTime);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        const patternSize = this.size/2.5 * (0.8 + Math.sin(this.animationTime * 2) * 0.2);
        ctx.fillRect(-patternSize/2, -patternSize/2, patternSize, patternSize);
        ctx.restore();
    }
    
    drawStarEnemy(ctx) {
        const spikes = 7;
        const outerRadius = this.size/2;
        const innerRadius = this.size/3;
        const starPulse = Math.sin(this.animationTime * 2) * 0.35 + 0.65;
        
        ctx.beginPath();
        for(let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius * starPulse : innerRadius;
            const angle = (Math.PI * i) / spikes + this.animationTime;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.save();
        ctx.rotate(this.animationTime * 2);
        ctx.fillStyle = 'white';
        const centerPulse = Math.sin(this.animationTime * 3) * 0.2 + 0.8;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/5 * centerPulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    drawHexagonEnemy(ctx) {
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            const angle = (Math.PI * i) / 3 + Math.sin(this.animationTime + i) * 0.3;
            const radius = this.size/2 * (1 + Math.cos(this.animationTime * 2 + i) * 0.15);
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.save();
        ctx.rotate(-this.animationTime);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            const angle = (Math.PI * i) / 3;
            const radius = this.size/3;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    
    drawSpiralEnemy(ctx) {
        ctx.beginPath();
        for(let i = 0; i < 25; i++) {
            const angle = i * 0.25 + this.animationTime * 2;
            const radius = (i / 25) * (this.size/2);
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            if(i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.save();
        ctx.rotate(this.animationTime * 3);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        for(let i = 0; i < 4; i++) {
            const angle = (Math.PI * i) / 2;
            const radius = this.size/6;
            ctx.beginPath();
            ctx.arc(Math.cos(angle) * radius/2, Math.sin(angle) * radius/2, radius/3, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    drawDroneEnemy(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/2.5, 0, Math.PI * 2);
        ctx.fill();
        
        for(let i = 0; i < 4; i++) {
            const angle = (Math.PI * i) / 2;
            ctx.save();
            ctx.rotate(angle);
            
            ctx.fillStyle = this.color;
            ctx.fillRect(0, -this.size/20, this.size/2, this.size/10);
            
            ctx.save();
            ctx.translate(this.size/2, 0);
            ctx.rotate(this.animationTime * 5);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            for(let j = 0; j < 3; j++) {
                const bladeAngle = (Math.PI * 2 * j) / 3;
                ctx.save();
                ctx.rotate(bladeAngle);
                ctx.fillRect(-this.size/30, -this.size/3, this.size/15, this.size/1.5);
                ctx.restore();
            }
            ctx.restore();
            
            ctx.restore();
        }
        
        ctx.fillStyle = 'white';
        const eyePulse = Math.sin(this.animationTime * 4) * 0.3 + 0.7;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/6 * eyePulse, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color, vx = 0, vy = 0, life = 30, special = false) {
        this.x = x; this.y = y;
        this.vx = vx || (Math.random() - 0.5) * 6;
        this.vy = vy || (Math.random() - 0.5) * 6;
        this.life = life;
        this.maxLife = life;
        this.color = color;
        this.size = Math.random() * (Game.isMobile ? 3 : 4) + 2;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
        this.special = special;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 1;
        this.rotation += this.rotationSpeed;
        
        this.size *= 0.97;
        
        return this.life > 0;
    }
    
    draw(ctx) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        
        if (this.special) {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5;
                const radius = this.size;
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                
                const innerAngle = angle + Math.PI / 5;
                const innerRadius = this.size / 2;
                ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        } else {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 5;
            ctx.shadowColor = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
    }
}

// Lancement
window.addEventListener('DOMContentLoaded', () => {
    Game.init();
    
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) e.preventDefault();
    }, { passive: false });
    
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js').catch(error => {
                console.log('ServiceWorker registration failed:', error);
            });
        });
    }
});
</script>
</body>
</html>
