<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Devil - Shooter Edition</title>
    <style>
        /* ==========================================================================
           VARIABLES & IMPORTATIONS
        ========================================================================== */
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff007a;
            --neon-purple: #bc13fe;
            --neon-green: #39ff14;
            --neon-yellow: #ffd700;
            --neon-red: #ff3333;
            --neon-orange: #ff5500;
            --bg-dark: #050505;
            --bg-darker: #01010a;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
            --font-primary: 'Orbitron', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        /* ==========================================================================
           RESET & BASE STYLES (MOBILE FIRST)
        ========================================================================== */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: var(--bg-darker);
            font-family: var(--font-primary);
        }

        body {
            color: white;
            padding: var(--safe-area-top) var(--safe-area-right) var(--safe-area-bottom) var(--safe-area-left);
        }

        img {
            max-width: 100%;
            height: auto;
        }

        /* ==========================================================================
           CONTAINERS & LAYOUT
        ========================================================================== */
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg-darker);
            display: flex;
            flex-direction: column;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* ==========================================================================
           OVERLAY & SCREENS
        ========================================================================== */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0.95), 
                rgba(5, 0, 20, 0.98));
            backdrop-filter: blur(15px);
            z-index: 100;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 1.25rem;
            padding-top: calc(1.25rem + var(--safe-area-top));
            padding-bottom: calc(1.25rem + var(--safe-area-bottom));
        }

        .start-content,
        .mission-failed {
            text-align: center;
            width: 100%;
            max-width: min(56.25rem, 90vw);
            padding: clamp(1.5rem, 4vw, 2.5rem);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8), 
                rgba(5, 0, 20, 0.9));
            border-radius: clamp(1rem, 2vw, 1.875rem);
            border: 0.1875rem solid var(--neon-blue);
            box-shadow: 
                0 0 3.125rem rgba(0, 242, 255, 0.3),
                inset 0 0 1.875rem rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(1.25rem);
        }

        .mission-failed {
            border-color: var(--neon-red);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.9), 
                rgba(40, 0, 0, 0.9));
            box-shadow: 
                0 0 3.75rem rgba(255, 51, 51, 0.4),
                inset 0 0 1.875rem rgba(255, 51, 51, 0.2);
        }

        /* ==========================================================================
           TYPOGRAPHY
        ========================================================================== */
        .start-content h1 {
            font-family: var(--font-primary);
            font-size: clamp(2rem, 6vw, 3.125rem);
            background: linear-gradient(to right, var(--neon-pink), var(--neon-blue), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 1.875rem rgba(255, 0, 122, 0.5);
            margin-bottom: 1.25rem;
            line-height: 1.2;
            letter-spacing: 0.1875rem;
            text-transform: uppercase;
            animation: titleGlow 3s infinite alternate;
        }

        .mission-failed h1 {
            font-family: var(--font-primary);
            font-size: clamp(2rem, 6vw, 2.8125rem);
            color: var(--neon-red);
            text-shadow: 
                0 0 1.25rem var(--neon-red),
                0 0 2.5rem rgba(255, 51, 51, 0.7);
            margin-bottom: 1.875rem;
            text-transform: uppercase;
            letter-spacing: 0.1875rem;
            animation: failedGlow 2s infinite alternate;
        }
        
        .start-content p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 3vw, 1.125rem);
            margin-bottom: 2.5rem;
            line-height: 1.6;
            text-shadow: 0 0 0.625rem rgba(0, 242, 255, 0.5);
        }

        /* ==========================================================================
           HUD & GAME UI
        ========================================================================== */
        .hud {
            position: fixed;
            top: max(1.25rem, var(--safe-area-top));
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 clamp(0.9375rem, 3vw, 1.5625rem);
            gap: 0.625rem;
        }

        .score-display {
            font-family: var(--font-primary);
            font-size: clamp(1.25rem, 4vw, 2rem);
            font-weight: 900;
            color: var(--neon-blue);
            text-shadow: 
                0 0 0.625rem var(--neon-blue),
                0 0 1.25rem var(--neon-blue),
                0 0 1.875rem rgba(0, 242, 255, 0.5);
            background: linear-gradient(to right, rgba(0, 0, 0, 0.7), rgba(0, 20, 40, 0.7));
            padding: clamp(0.5rem, 2vw, 0.75rem) clamp(1rem, 3vw, 1.5625rem);
            border-radius: 0.9375rem;
            border: 0.125rem solid var(--neon-blue);
            backdrop-filter: blur(0.625rem);
            box-shadow: 
                0 0 1.25rem rgba(0, 242, 255, 0.3),
                inset 0 0 1.25rem rgba(0, 242, 255, 0.1);
            letter-spacing: 0.125rem;
            animation: pulse 2s infinite;
            min-height: 2.75rem;
            display: flex;
            align-items: center;
        }

        .lives-container {
            display: flex;
            gap: clamp(0.5rem, 2vw, 0.9375rem);
            background: linear-gradient(to right, rgba(0, 20, 40, 0.7), rgba(0, 0, 0, 0.7));
            padding: clamp(0.5rem, 2vw, 0.75rem) clamp(1rem, 3vw, 1.5625rem);
            border-radius: 0.9375rem;
            border: 0.125rem solid var(--neon-blue);
            backdrop-filter: blur(0.625rem);
            box-shadow: 
                0 0 1.25rem rgba(0, 242, 255, 0.3),
                inset 0 0 1.25rem rgba(0, 242, 255, 0.1);
            min-height: 2.75rem;
            align-items: center;
        }

        .heart {
            width: clamp(1.5625rem, 5vw, 2.1875rem);
            height: clamp(1.5625rem, 5vw, 2.1875rem);
            position: relative;
            transition: transform 0.3s, filter 0.3s;
            min-width: 1.5625rem;
        }

        .heart svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 0.5rem var(--neon-blue));
            transition: all 0.3s;
        }

        /* ==========================================================================
           BUTTONS
        ========================================================================== */
        .play-btn {
            position: relative;
            width: clamp(5rem, 20vw, 7.5rem);
            height: clamp(5rem, 20vw, 7.5rem);
            background: linear-gradient(135deg, var(--neon-green), var(--neon-blue));
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2.5rem auto;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 1.875rem var(--neon-green),
                0 0 3.75rem rgba(57, 255, 20, 0.3),
                inset 0 0 1.25rem rgba(255, 255, 255, 0.2);
            border: 0.1875rem solid white;
            animation: playBtnGlow 2s infinite alternate;
            min-height: 3.75rem;
        }

        .play-btn:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 
                0 0 2.5rem var(--neon-blue),
                0 0 5rem rgba(0, 242, 255, 0.5);
        }

        .play-btn:active {
            transform: scale(0.95);
        }

        .play-triangle {
            width: 0;
            height: 0;
            border-left: clamp(1.25rem, 5vw, 2.5rem) solid white;
            border-top: clamp(0.9375rem, 3.5vw, 1.5625rem) solid transparent;
            border-bottom: clamp(0.9375rem, 3.5vw, 1.5625rem) solid transparent;
            margin-left: 0.5rem;
            filter: drop-shadow(0 0 0.3125rem white);
        }

        /* ==========================================================================
           MOBILE CONTROLS
        ========================================================================== */
        #mobile-controls {
            position: fixed;
            bottom: max(1.875rem, var(--safe-area-bottom));
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 clamp(1.25rem, 4vw, 1.875rem);
            z-index: 60;
            gap: 1.25rem;
            pointer-events: none;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        }

        .joystick-container {
            position: relative;
            width: clamp(7.5rem, 30vw, 11.25rem);
            height: clamp(7.5rem, 30vw, 11.25rem);
            touch-action: none;
        }

        .joystick-boundary {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                rgba(0, 242, 255, 0.1), 
                rgba(0, 100, 200, 0.05));
            border: 0.1875rem solid var(--neon-blue);
            border-radius: 50%;
            box-shadow: 
                0 0 1.875rem rgba(0, 242, 255, 0.4),
                inset 0 0 1.875rem rgba(0, 242, 255, 0.2);
            backdrop-filter: blur(0.625rem);
            pointer-events: none;
        }

        .joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(3rem, 12vw, 5rem);
            height: clamp(3rem, 12vw, 5rem);
            background: radial-gradient(circle at 30% 30%, 
                var(--neon-blue), 
                #0080ff);
            border: 0.1875rem solid white;
            border-radius: 50%;
            box-shadow: 
                0 0 1.875rem rgba(0, 242, 255, 0.9),
                inset 0 0 0.9375rem rgba(255, 255, 255, 0.8);
            transition: all 0.1s ease-out;
            pointer-events: none;
            z-index: 2;
        }

        .action-btn {
            width: clamp(5rem, 20vw, 7.5rem);
            height: clamp(5rem, 20vw, 7.5rem);
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 0, 122, 0.8), 
                rgba(188, 19, 254, 0.6));
            border: 0.1875rem solid var(--neon-pink);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 
                0 0 1.875rem rgba(255, 0, 122, 0.6),
                0 0 3.75rem rgba(255, 0, 122, 0.3),
                inset 0 0 1.25rem rgba(255, 255, 255, 0.3);
            transition: all 0.1s;
            margin-bottom: 1.875rem;
            position: relative;
            cursor: pointer;
            animation: fireBtnGlow 2s infinite alternate;
            min-height: 3.75rem;
        }

        /* ==========================================================================
           CONTROLS INFO
        ========================================================================== */
        .controls-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(8.75rem, 1fr));
            gap: 1.25rem;
            margin-top: 2.5rem;
            width: 100%;
        }

        .control-item {
            text-align: center;
            padding: 0.625rem;
        }

        .control-icon {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            margin-bottom: 0.625rem;
            text-shadow: 0 0 0.625rem var(--neon-blue);
        }

        .control-text {
            color: var(--neon-green);
            font-size: clamp(0.875rem, 2vw, 1rem);
        }

        /* ==========================================================================
           SCORE RESULTS
        ========================================================================== */
        .score-results {
            background: linear-gradient(to right, 
                rgba(255, 51, 51, 0.1), 
                rgba(255, 0, 122, 0.1));
            border-radius: 1.25rem;
            padding: clamp(1rem, 3vw, 1.875rem);
            margin: 1.875rem 0;
            border: 0.125rem solid rgba(255, 51, 51, 0.3);
            box-shadow: 
                0 0 1.875rem rgba(255, 51, 51, 0.2),
                inset 0 0 1.25rem rgba(255, 51, 51, 0.1);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1.25rem 0;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            padding: 0.625rem 0;
            border-bottom: 0.0625rem solid rgba(255, 255, 255, 0.1);
        }

        .score-item:last-child {
            border-bottom: none;
        }

        .score-value {
            color: var(--neon-yellow);
            font-weight: bold;
            font-size: clamp(1.1rem, 2.5vw, 1.5rem);
            text-shadow: 0 0 0.625rem var(--neon-yellow);
        }

        /* ==========================================================================
           LEVEL & COMBO DISPLAYS
        ========================================================================== */
        .level-display {
            position: fixed;
            bottom: max(1.875rem, var(--safe-area-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(to right, 
                rgba(188, 19, 254, 0.3), 
                rgba(0, 242, 255, 0.3));
            padding: 0.625rem clamp(1rem, 3vw, 1.5625rem);
            border-radius: 0.9375rem;
            border: 0.125rem solid var(--neon-purple);
            backdrop-filter: blur(0.625rem);
            box-shadow: 0 0 1.25rem rgba(188, 19, 254, 0.3);
            pointer-events: none;
            z-index: 40;
            font-family: var(--font-primary);
            font-weight: bold;
            color: white;
            text-shadow: 0 0 0.625rem var(--neon-purple);
            font-size: clamp(0.875rem, 2vw, 1rem);
            white-space: nowrap;
        }

        .combo-display {
            position: fixed;
            top: 50%;
            right: 1.25rem;
            transform: translateY(-50%);
            font-family: var(--font-primary);
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            font-weight: bold;
            color: var(--neon-orange);
            text-shadow: 
                0 0 0.625rem var(--neon-orange),
                0 0 1.25rem rgba(255, 85, 0, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: 0.625rem 1.25rem;
            border-radius: 0.9375rem;
            border: 0.125rem solid var(--neon-orange);
            backdrop-filter: blur(0.625rem);
            pointer-events: none;
            z-index: 40;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 12.5rem;
        }

        /* ==========================================================================
           PAUSE SCREEN
        ========================================================================== */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0.85), 
                rgba(0, 20, 40, 0.9));
            backdrop-filter: blur(0.9375rem);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 90;
            flex-direction: column;
            gap: 1.875rem;
            padding: 1.25rem;
        }

        .pause-title {
            font-family: var(--font-primary);
            font-size: clamp(2rem, 6vw, 4rem);
            background: linear-gradient(to right, var(--neon-blue), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 1.875rem rgba(0, 242, 255, 0.5);
            margin-bottom: 1.25rem;
            text-align: center;
        }

        .pause-stats {
            background: rgba(0, 0, 0, 0.5);
            padding: 1.5625rem;
            border-radius: 1.25rem;
            border: 0.125rem solid var(--neon-blue);
            width: 100%;
            max-width: 18.75rem;
        }

        .pause-stats div {
            margin: 0.9375rem 0;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            display: flex;
            justify-content: space-between;
        }

        /* ==========================================================================
           UTILITY CLASSES
        ========================================================================== */
        .hidden { 
            display: none !important; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }

        .heart.lost svg {
            fill: #222;
            filter: none;
        }

        .heart.pulse svg {
            animation: heartPulse 0.5s ease-in-out;
        }

        .joystick-thumb.active {
            box-shadow: 
                0 0 2.5rem rgba(0, 242, 255, 1),
                inset 0 0 1.25rem rgba(255, 255, 255, 1);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .action-btn.active {
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 0, 122, 1), 
                rgba(188, 19, 254, 0.8));
            transform: scale(0.95);
            box-shadow: 
                0 0 2.5rem rgba(255, 0, 122, 0.9),
                0 0 5rem rgba(255, 0, 122, 0.5),
                inset 0 0 1.5625rem rgba(255, 255, 255, 0.4);
        }

        .combo-display.active {
            opacity: 1;
            animation: comboPulse 0.5s ease-in-out;
        }

        .player-invincible {
            animation: playerBlink 0.5s infinite alternate;
        }

        /* ==========================================================================
           ANIMATIONS
        ========================================================================== */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        @keyframes heartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        @keyframes playBtnGlow {
            0% { box-shadow: 0 0 1.875rem var(--neon-green), 0 0 3.75rem rgba(57, 255, 20, 0.3); }
            100% { box-shadow: 0 0 2.5rem var(--neon-blue), 0 0 5rem rgba(0, 242, 255, 0.4); }
        }

        @keyframes fireBtnGlow {
            0% { box-shadow: 0 0 1.875rem rgba(255, 0, 122, 0.6), 0 0 3.75rem rgba(255, 0, 122, 0.3); }
            100% { box-shadow: 0 0 2.5rem rgba(188, 19, 254, 0.7), 0 0 5rem rgba(188, 19, 254, 0.4); }
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 0 1.875rem rgba(255, 0, 122, 0.5); }
            50% { text-shadow: 0 0 2.5rem rgba(0, 242, 255, 0.6); }
            100% { text-shadow: 0 0 1.875rem rgba(188, 19, 254, 0.5); }
        }

        @keyframes failedGlow {
            0% { text-shadow: 0 0 1.25rem var(--neon-red), 0 0 2.5rem rgba(255, 51, 51, 0.7); }
            100% { text-shadow: 0 0 1.875rem var(--neon-red), 0 0 3.75rem rgba(255, 51, 51, 0.9); }
        }

        @keyframes highscorePulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        @keyframes targetRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes targetPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.2); }
        }

        @keyframes comboPulse {
            0%, 100% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.1); }
        }

        @keyframes playerBlink {
            0% { 
                opacity: 0.3;
                filter: brightness(2) drop-shadow(0 0 1.25rem var(--neon-blue));
            }
            100% { 
                opacity: 1;
                filter: brightness(1) drop-shadow(0 0 0.625rem var(--neon-blue));
            }
        }

        /* ==========================================================================
           MEDIA QUERIES - TABLET (768px)
        ========================================================================== */
        @media (min-width: 768px) {
            .hud {
                padding: 0 2.5rem;
            }

            .score-display {
                font-size: clamp(1.5rem, 3vw, 1.75rem);
            }

            .heart {
                width: clamp(1.75rem, 3vw, 2rem);
                height: clamp(1.75rem, 3vw, 2rem);
            }

            .joystick-container {
                width: clamp(8.75rem, 25vw, 10rem);
                height: clamp(8.75rem, 25vw, 10rem);
            }

            .joystick-thumb {
                width: clamp(3.5rem, 10vw, 4rem);
                height: clamp(3.5rem, 10vw, 4rem);
            }

            .action-btn {
                width: clamp(5.625rem, 15vw, 6.25rem);
                height: clamp(5.625rem, 15vw, 6.25rem);
                margin-bottom: 2.5rem;
            }

            #mobile-controls {
                padding: 0 2.5rem;
                bottom: max(2.5rem, var(--safe-area-bottom));
            }

            .controls-info {
                grid-template-columns: repeat(3, 1fr);
                gap: 2.5rem;
            }

            .control-icon {
                font-size: 2rem;
            }

            .control-text {
                font-size: 0.875rem;
            }
        }

        /* ==========================================================================
           MEDIA QUERIES - DESKTOP (1024px)
        ========================================================================== */
        @media (min-width: 1024px) {
            .hud {
                padding: 0 3.125rem;
            }

            .score-display {
                font-size: 2rem;
            }

            .heart {
                width: 2.1875rem;
                height: 2.1875rem;
            }

            .joystick-container {
                width: 11.25rem;
                height: 11.25rem;
            }

            .joystick-thumb {
                width: 5rem;
                height: 5rem;
            }

            .action-btn {
                width: 7.5rem;
                height: 7.5rem;
                margin-bottom: 3.125rem;
            }

            #mobile-controls {
                padding: 0 3.125rem;
            }

            .start-content h1 {
                font-size: 3.125rem;
            }

            .start-content p {
                font-size: 1.125rem;
            }

            .play-btn {
                width: 7.5rem;
                height: 7.5rem;
            }

            .play-triangle {
                border-left-width: 2.5rem;
                border-top-width: 1.5625rem;
                border-bottom-width: 1.5625rem;
            }
        }

        /* ==========================================================================
           MEDIA QUERIES - LARGE DESKTOP (1200px)
        ========================================================================== */
        @media (min-width: 1200px) {
            .score-display {
                font-size: 2.25rem;
            }

            .heart {
                width: 2.5rem;
                height: 2.5rem;
            }

            .joystick-container {
                width: 12.5rem;
                height: 12.5rem;
            }

            .joystick-thumb {
                width: 5.625rem;
                height: 5.625rem;
            }

            .play-btn {
                width: 8.75rem;
                height: 8.75rem;
            }

            .play-triangle {
                border-left-width: 2.8125rem;
                border-top-width: 1.875rem;
                border-bottom-width: 1.875rem;
            }
        }

        /* ==========================================================================
           MEDIA QUERIES - LANDSCAPE MOBILE (max-height: 600px)
        ========================================================================== */
        @media (max-height: 600px) {
            .hud {
                top: max(0.625rem, var(--safe-area-top));
            }
            
            .score-display {
                font-size: 1.25rem;
                padding: 0.375rem 0.75rem;
            }
            
            .heart {
                width: 1.25rem;
                height: 1.25rem;
            }
            
            #mobile-controls {
                bottom: max(0.9375rem, var(--safe-area-bottom));
            }
            
            .joystick-container {
                width: 7.5rem;
                height: 7.5rem;
            }

            .joystick-thumb {
                width: 3.125rem;
                height: 3.125rem;
            }
            
            .action-btn {
                width: 5rem;
                height: 5rem;
                margin-bottom: 0.9375rem;
            }

            .level-display {
                bottom: max(0.9375rem, var(--safe-area-bottom));
                font-size: 0.75rem;
                padding: 0.375rem 0.9375rem;
            }

            .start-content,
            .mission-failed {
                padding: 1rem;
                margin: 0.5rem;
            }

            .start-content h1,
            .mission-failed h1 {
                font-size: 1.5rem;
                margin-bottom: 0.5rem;
            }

            .start-content p {
                font-size: 0.875rem;
                margin-bottom: 1rem;
            }

            .play-btn {
                width: 4rem;
                height: 4rem;
                margin: 1rem auto;
            }

            .play-triangle {
                border-left-width: 1rem;
                border-top-width: 0.625rem;
                border-bottom-width: 0.625rem;
                margin-left: 0.25rem;
            }
        }

        /* ==========================================================================
           MEDIA QUERIES - ULTRA WIDE (min-aspect-ratio: 16/9)
        ========================================================================== */
        @media (min-aspect-ratio: 16/9) {
            canvas {
                object-fit: cover;
            }
        }

        /* ==========================================================================
           TARGET ICON STYLES
        ========================================================================== */
        .target-icon {
            width: 70%;
            height: 70%;
            position: relative;
            animation: targetRotate 4s linear infinite;
        }

        .target-icon::before,
        .target-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 0.125rem solid var(--neon-green);
            box-shadow: 0 0 0.9375rem var(--neon-green);
        }

        .target-icon::before {
            width: 80%;
            height: 80%;
        }

        .target-icon::after {
            width: 40%;
            height: 40%;
        }

        .target-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20%;
            height: 20%;
            background: var(--neon-green);
            border-radius: 50%;
            box-shadow: 0 0 0.9375rem var(--neon-green);
            animation: targetPulse 1s infinite alternate;
        }

        .target-cross {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0.1875rem;
            height: 80%;
            background: var(--neon-green);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0.5rem var(--neon-green);
        }

        .target-cross::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 0.1875rem;
            background: var(--neon-green);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0.5rem var(--neon-green);
        }

        /* ==========================================================================
           PARTICLE STYLES
        ========================================================================== */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 10;
            border-radius: 50%;
        }
    </style>
</head>
<body>

<!-- √âl√©ment audio cach√© pour la musique de fond -->
<audio id="background-music" loop>
    <source src="mixkit-sci-fi-game-395.mp3" type="audio/mpeg">
</audio>

<div id="game-container">
    <div class="hud">
        <div class="score-display" id="score-display">0</div>
        <div class="lives-container" id="lives-container">
            <div class="heart" id="heart-1">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-2">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-3">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
        </div>
    </div>

    <div class="level-display" id="level-display">LEVEL 1</div>
    <div class="combo-display" id="combo-display">COMBO x0</div>

    <div id="start-screen" class="overlay">
        <div class="start-content">
            <h1>NEON DEVIL<br>SHOOTER</h1>
            <p>Survive dans l'ar√®ne n√©on. √âliminez les vagues d'ennemis. Devenez une l√©gende.</p>
            <div class="controls-info">
                <div class="control-item">
                    <div class="control-icon">üïπÔ∏è</div>
                    <div class="control-text">Joystick pour se d√©placer</div>
                </div>
                <div class="control-item">
                    <div class="control-icon">üéØ</div>
                    <div class="control-text">Bouton rouge pour tirer</div>
                </div>
                <div class="control-item">
                    <div class="control-icon">üí•</div>
                    <div class="control-text">√âvitez les ennemis et survivez</div>
                </div>
            </div>
            <button class="play-btn" onclick="Game.start()" id="play-btn" aria-label="Jouer">
                <div class="play-triangle"></div>
            </button>
        </div>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <div class="mission-failed">
            <h1>MISSION FAILED</h1>
            <div class="score-results">
                <div class="score-item">
                    <span class="score-label">SCORE:</span>
                    <span class="score-value" id="final-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">BEST SCORE:</span>
                    <span class="highscore-value" id="best-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">LEVEL:</span>
                    <span class="score-value" id="final-level">1</span>
                </div>
                <div class="score-item">
                    <span class="score-label">COMBO MAX:</span>
                    <span class="score-value" id="final-combo">x0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">ENNEMIS TU√âS:</span>
                    <span class="score-value" id="final-kills">0</span>
                </div>
            </div>
            <button class="play-btn" onclick="Game.start()" id="restart-btn" aria-label="Recommencer">
                <div class="play-triangle"></div>
            </button>
        </div>
    </div>

    <div id="pause-screen" class="pause-overlay hidden">
        <div class="pause-title">PAUSE</div>
        <div class="pause-stats">
            <div>
                <span>Score:</span>
                <span id="pause-score">0</span>
            </div>
            <div>
                <span>Niveau:</span>
                <span id="pause-level">1</span>
            </div>
            <div>
                <span>Vies:</span>
                <span id="pause-lives">3</span>
            </div>
            <div>
                <span>Ennemis restants:</span>
                <span id="pause-enemies">0</span>
            </div>
        </div>
        <button class="play-btn" onclick="Game.resume()" id="resume-btn" aria-label="Reprendre">
            <div class="play-triangle"></div>
        </button>
    </div>

    <canvas id="canvas"></canvas>

    <!-- CONTROLES TOUJOURS VISIBLES -->
    <div id="mobile-controls">
        <div class="control-group">
            <div class="joystick-container" id="joystick-container">
                <div class="joystick-boundary"></div>
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="action-btn" id="btn-fire">
                <div class="target-icon">
                    <div class="target-cross"></div>
                    <div class="target-center"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * CONFIGURATION & CONSTANTES - OPTIMIS√âES POUR PAYSAGE
 */
const CFG = {
    GRAVITY: 0.12,
    FRICTION: 0.93,
    SPEED: 5.0,
    PLAYER_SIZE: 45,
    ENEMY_SPEED_MULTIPLIER: 0.8,
    PROJECTILE_SPEED: 18,
    FIRE_RATE: 3,
    JOYSTICK_RADIUS: 70,
    JOYSTICK_DEADZONE: 0.08,
    WORLD_WIDTH: 4000,
    WORLD_HEIGHT: 2000,
    COLORS: {
        player: '#00f2ff',
        enemyCircle: '#ff007a',
        enemyTriangle: '#bc13fe',
        enemySquare: '#ffd700',
        enemyStar: '#39ff14',
        enemyHexagon: '#ff00ff',
        enemySpiral: '#ff5500',
        enemyDrone: '#aa00ff',
        projectile: '#ff3333',
        nebula1: 'rgba(188, 19, 254, 0.1)',
        nebula2: 'rgba(0, 242, 255, 0.1)',
        nebula3: 'rgba(255, 0, 122, 0.1)'
    },
    PARTICLE_COUNT: {
        stars: 400,
        nebulas: 15,
        backgroundParticles: 100
    }
};

/**
 * MOTEUR DE JEU - AM√âLIOR√â POUR PAYSAGE
 */
const Game = {
    canvas: document.getElementById('canvas'),
    ctx: null,
    width: 0,
    height: 0,
    player: null,
    enemies: [],
    projectiles: [],
    particles: [],
    stars: [],
    nebulas: [],
    backgroundParticles: [],
    level: 1,
    score: 0,
    lives: 3,
    keys: {},
    cameraX: 0,
    cameraY: 0,
    isRunning: false,
    spawnTimer: 0,
    enemyCount: 0,
    shotsFired: 0,
    fireCooldown: 0,
    isMobile: false,
    joystickActive: false,
    joystickX: 0,
    joystickY: 0,
    joystickOrigin: {x: 0, y: 0},
    joystickMaxRadius: CFG.JOYSTICK_RADIUS,
    joystickTouchId: null,
    bestScore: 0,
    gameOver: false,
    explosionParticles: [],
    lastTime: 0,
    deltaTime: 0,
    touchEvents: [],
    combo: 0,
    comboTimeout: null,
    maxCombo: 0,
    enemiesKilled: 0,
    timePlayed: 0,
    shakeIntensity: 0,
    shakeDuration: 0,
    backgroundMusic: null,

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.detectDevice();
        this.resize();
        
        // Initialiser la musique de fond
        this.initBackgroundMusic();
        
        // Charger le meilleur score
        this.loadBestScore();
        
        // √âv√©nements de redimensionnement
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('orientationchange', () => {
            setTimeout(() => this.resize(), 100);
        });
        
        // Input Listeners
        this.setupInput();
        this.setupMobileControls();
        this.generateBackground();
        
        // Focus sur le bouton de d√©marrage
        document.getElementById('play-btn').focus();
        
        this.loop(0);
    },

    initBackgroundMusic() {
        this.backgroundMusic = document.getElementById('background-music');
        this.backgroundMusic.volume = 0.5; // Volume √† 50%
        this.backgroundMusic.loop = true; // Boucle infinie
        
        // Politique de lecture automatique - d√©marrer au premier clic utilisateur
        document.addEventListener('click', () => {
            if (this.backgroundMusic.paused) {
                this.backgroundMusic.play().catch(e => {
                    console.log("Lecture automatique bloqu√©e, attente d'interaction utilisateur");
                });
            }
        }, { once: true });
    },

    startBackgroundMusic() {
        if (this.backgroundMusic && this.backgroundMusic.paused) {
            this.backgroundMusic.currentTime = 0; // Revenir au d√©but
            this.backgroundMusic.play().catch(e => {
                console.log("Erreur de lecture de la musique:", e);
            });
        }
    },

    pauseBackgroundMusic() {
        if (this.backgroundMusic && !this.backgroundMusic.paused) {
            this.backgroundMusic.pause();
        }
    },

    resumeBackgroundMusic() {
        if (this.backgroundMusic && this.backgroundMusic.paused) {
            this.backgroundMusic.play().catch(e => {
                console.log("Erreur de reprise de la musique:", e);
            });
        }
    },

    loadBestScore() {
        const savedScore = localStorage.getItem('neonDevilBestScore');
        this.bestScore = savedScore ? parseInt(savedScore) : 0;
        this.updateBestScoreDisplay();
    },

    saveBestScore() {
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('neonDevilBestScore', this.bestScore.toString());
        }
    },

    updateBestScoreDisplay() {
        document.getElementById('best-score').textContent = this.bestScore;
    },

    detectDevice() {
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Ajuster les param√®tres selon l'appareil
        if (this.isMobile) {
            CFG.SPEED = 4.5;
            CFG.PLAYER_SIZE = 40;
            CFG.JOYSTICK_RADIUS = 60;
            CFG.PROJECTILE_SPEED = 16;
            CFG.PARTICLE_COUNT.stars = 300;
        }
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        // Recalculer la position du joystick
        this.calculateJoystickOrigin();
    },

    calculateJoystickOrigin() {
        const joystickContainer = document.querySelector('.joystick-container');
        if (!joystickContainer) return;
        
        const rect = joystickContainer.getBoundingClientRect();
        this.joystickOrigin.x = rect.left + rect.width / 2;
        this.joystickOrigin.y = rect.top + rect.height / 2;
        this.joystickMaxRadius = Math.min(rect.width / 2 - 40, CFG.JOYSTICK_RADIUS);
    },

    setupInput() {
        // Clavier
        window.addEventListener('keydown', e => {
            if (!this.isRunning) return;
            
            this.keys[e.code] = true;
            if (e.code === 'Space' && this.fireCooldown <= 0) {
                e.preventDefault();
                if (this.player && !this.player.invincible) {
                    this.player.fire();
                    this.fireCooldown = CFG.FIRE_RATE;
                }
            }
            if (e.code === 'Escape' || e.code === 'KeyP') {
                if (this.isRunning && !this.gameOver) {
                    this.togglePause();
                }
            }
            if (e.code === 'Enter' || e.code === 'NumpadEnter') {
                if (!this.isRunning && !document.getElementById('game-over-screen').classList.contains('hidden')) {
                    this.start();
                }
            }
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        
        // Touch pour d√©marrer
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!this.isRunning && !this.gameOver) {
                this.start();
            }
        }, { passive: false });
    },

    setupMobileControls() {
        const joystickContainer = document.getElementById('joystick-container');
        const fireBtn = document.getElementById('btn-fire');
        
        if (!joystickContainer) return;
        
        this.calculateJoystickOrigin();
        
        // Gestion du joystick am√©lior√©e
        const handleJoystickStart = (clientX, clientY, touchId = null) => {
            if (!this.isRunning) return;
            
            this.joystickActive = true;
            if (touchId !== null) this.joystickTouchId = touchId;
            document.getElementById('joystick-thumb').classList.add('active');
            this.updateJoystickPosition(clientX, clientY);
        };
        
        const handleJoystickMove = (clientX, clientY) => {
            if (!this.joystickActive || !this.isRunning) return;
            this.updateJoystickPosition(clientX, clientY);
        };
        
        const handleJoystickEnd = (touchId = null) => {
            if (touchId !== null && this.joystickTouchId !== touchId) return;
            
            this.joystickActive = false;
            this.joystickX = 0;
            this.joystickY = 0;
            this.joystickTouchId = null;
            document.getElementById('joystick-thumb').classList.remove('active');
            document.getElementById('joystick-thumb').style.transform = 'translate(-50%, -50%)';
        };
        
        // Touch events optimis√©s pour mobile
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleJoystickStart(touch.clientX, touch.clientY, touch.identifier);
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (!this.joystickActive || !this.joystickTouchId) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    handleJoystickMove(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        });
        
        document.addEventListener('touchcancel', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        });
        
        // Mouse events pour desktop
        joystickContainer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleJoystickStart(e.clientX, e.clientY);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!this.joystickActive) return;
            e.preventDefault();
            handleJoystickMove(e.clientX, e.clientY);
        });
        
        document.addEventListener('mouseup', (e) => {
            if (this.joystickActive) {
                handleJoystickEnd();
            }
        });
        
        // Bouton de tir
        const handleFireStart = () => {
            if (!this.isRunning) return;
            
            if (this.fireCooldown <= 0 && this.player && !this.player.invincible) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
            }
            fireBtn.classList.add('active');
        };
        
        const handleFireEnd = () => {
            fireBtn.classList.remove('active');
        };
        
        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleFireStart();
        }, { passive: false });
        
        fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleFireStart();
        });
        
        fireBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mouseleave', handleFireEnd);
    },

    updateJoystickPosition(clientX, clientY) {
        const joystickThumb = document.getElementById('joystick-thumb');
        
        // Recalculer l'origine √† chaque mise √† jour
        this.calculateJoystickOrigin();
        
        let deltaX = clientX - this.joystickOrigin.x;
        let deltaY = clientY - this.joystickOrigin.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > this.joystickMaxRadius) {
            deltaX = (deltaX / distance) * this.joystickMaxRadius;
            deltaY = (deltaY / distance) * this.joystickMaxRadius;
        }
        
        // Appliquer une zone morte pour √©viter les mouvements involontaires
        if (distance < this.joystickMaxRadius * CFG.JOYSTICK_DEADZONE) {
            deltaX = 0;
            deltaY = 0;
        }
        
        joystickThumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        
        // Normaliser les valeurs entre -1 et 1
        this.joystickX = deltaX / this.joystickMaxRadius;
        this.joystickY = deltaY / this.joystickMaxRadius;
    },

    togglePause() {
        if (this.isRunning && !this.gameOver) {
            this.isRunning = false;
            this.pauseBackgroundMusic();
            document.getElementById('pause-screen').classList.remove('hidden');
            document.getElementById('pause-score').textContent = this.score;
            document.getElementById('pause-level').textContent = this.level;
            document.getElementById('pause-lives').textContent = this.lives;
            document.getElementById('pause-enemies').textContent = this.enemies.length;
            document.getElementById('resume-btn').focus();
        }
    },

    resume() {
        this.isRunning = true;
        this.resumeBackgroundMusic();
        document.getElementById('pause-screen').classList.add('hidden');
        this.canvas.focus();
    },

    start() {
        console.log("Jeu d√©marre!");
        // D√©marrer la musique de fond
        this.startBackgroundMusic();
        
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.enemies = [];
        this.projectiles = [];
        this.particles = [];
        this.explosionParticles = [];
        this.enemyCount = 0;
        this.enemiesKilled = 0;
        this.shotsFired = 0;
        this.fireCooldown = 0;
        this.isRunning = true;
        this.gameOver = false;
        this.cameraX = -CFG.WORLD_WIDTH / 2 + this.width / 2;
        this.cameraY = -CFG.WORLD_HEIGHT / 2 + this.height / 2;
        this.lastTime = 0;
        this.timePlayed = 0;
        this.combo = 0;
        this.maxCombo = 0;
        
        // R√©initialiser le joystick
        this.joystickActive = false;
        this.joystickX = 0;
        this.joystickY = 0;
        const joystickThumb = document.getElementById('joystick-thumb');
        if (joystickThumb) {
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            joystickThumb.classList.remove('active');
        }
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('pause-screen').classList.add('hidden');
        
        // Position initiale au centre du monde
        this.player = new Player(0, 0);
        this.spawnTimer = 0;
        this.updateHUD();
        this.updateLevelDisplay();
        this.updateComboDisplay();
        
        this.updateHearts();
        
        // Nettoyer les classes d'invincibilit√©
        this.canvas.classList.remove('player-invincible');
        
        this.canvas.focus();
    },

    generateBackground() {
        // G√©n√©rer les √©toiles
        this.stars = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.stars; i++) {
            this.stars.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: Math.random() * 3 + 0.5,
                speed: Math.random() * 0.8 + 0.2,
                opacity: Math.random() * 0.8 + 0.2,
                twinkleSpeed: Math.random() * 0.05 + 0.01,
                twinkleOffset: Math.random() * Math.PI * 2
            });
        }
        
        // G√©n√©rer les n√©buleuses
        this.nebulas = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.nebulas; i++) {
            const size = Math.random() * 800 + 400;
            this.nebulas.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: size,
                color: [CFG.COLORS.nebula1, CFG.COLORS.nebula2, CFG.COLORS.nebula3][Math.floor(Math.random() * 3)],
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: Math.random() * 0.002 - 0.001
            });
        }
        
        // G√©n√©rer les particules de fond
        this.backgroundParticles = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.backgroundParticles; i++) {
            this.backgroundParticles.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: Math.random() * 4 + 1,
                color: [CFG.COLORS.player, CFG.COLORS.enemyCircle, CFG.COLORS.enemyStar][Math.floor(Math.random() * 3)],
                speed: Math.random() * 2 + 0.5,
                direction: Math.random() * Math.PI * 2,
                opacity: Math.random() * 0.3 + 0.1
            });
        }
    },

    canSpawnEnemyAt(x, y, size) {
        if (!this.player) return true;
        
        const playerDist = Math.sqrt(
            Math.pow(x - this.player.x, 2) + 
            Math.pow(y - this.player.y, 2)
        );
        if (playerDist < 300) return false;
        
        for (const enemy of this.enemies) {
            const dist = Math.sqrt(
                Math.pow(x - enemy.x, 2) + 
                Math.pow(y - enemy.y, 2)
            );
            const minDist = (size/2) + (enemy.size/2) + 30;
            if (dist < minDist) {
                return false;
            }
        }
        return true;
    },

    spawnEnemy() {
        const edge = Math.floor(Math.random() * 4);
        let baseX, baseY, vx, vy;
        
        const spawnMargin = 200;
        const worldLeft = -CFG.WORLD_WIDTH/2;
        const worldRight = CFG.WORLD_WIDTH/2;
        const worldTop = -CFG.WORLD_HEIGHT/2;
        const worldBottom = CFG.WORLD_HEIGHT/2;
        
        switch(edge) {
            case 0: // Haut
                baseX = Math.random() * CFG.WORLD_WIDTH + worldLeft;
                baseY = worldTop - spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = Math.random() * 2 + 1;
                break;
            case 1: // Droite
                baseX = worldRight + spawnMargin;
                baseY = Math.random() * CFG.WORLD_HEIGHT + worldTop;
                vx = -Math.random() * 2 - 1;
                vy = (Math.random() - 0.5) * 2;
                break;
            case 2: // Bas
                baseX = Math.random() * CFG.WORLD_WIDTH + worldLeft;
                baseY = worldBottom + spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = -Math.random() * 2 - 1;
                break;
            case 3: // Gauche
                baseX = worldLeft - spawnMargin;
                baseY = Math.random() * CFG.WORLD_HEIGHT + worldTop;
                vx = Math.random() * 2 + 1;
                vy = (Math.random() - 0.5) * 2;
                break;
        }
        
        const enemyTypes = ['circle', 'triangle', 'square', 'star', 'hexagon', 'spiral', 'drone'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const size = 25 + Math.random() * 20 + this.level * 2;
        const x = baseX;
        const y = baseY;
        
        if (this.canSpawnEnemyAt(x, y, size)) {
            this.enemies.push(new Enemy(x, y, vx, vy, type, size));
            this.enemyCount++;
            return true;
        }
        return false;
    },

    updateHUD() {
        document.getElementById('score-display').textContent = this.score;
    },

    updateLevelDisplay() {
        document.getElementById('level-display').textContent = `LEVEL ${this.level}`;
    },

    updateComboDisplay() {
        const comboDisplay = document.getElementById('combo-display');
        comboDisplay.textContent = `COMBO x${this.combo}`;
        
        if (this.combo > 1) {
            comboDisplay.classList.add('active');
        } else {
            comboDisplay.classList.remove('active');
        }
    },

    incrementCombo() {
        this.combo++;
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
        }
        
        this.updateComboDisplay();
        
        // R√©initialiser le timeout du combo
        if (this.comboTimeout) {
            clearTimeout(this.comboTimeout);
        }
        
        this.comboTimeout = setTimeout(() => {
            if (this.combo > 3) {
                this.createComboText();
            }
            this.combo = 0;
            this.updateComboDisplay();
        }, 3000);
    },

    createComboText() {
        if (!this.player) return;
        
        for (let i = 0; i < 10; i++) {
            this.particles.push(new Particle(
                this.player.x,
                this.player.y,
                CFG.COLORS.enemyStar,
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 8,
                20,
                true
            ));
        }
    },

    updateHearts() {
        for (let i = 1; i <= 3; i++) {
            const heart = document.getElementById(`heart-${i}`);
            if (i <= this.lives) {
                heart.classList.remove('lost');
                if (i === this.lives) {
                    heart.classList.add('pulse');
                    setTimeout(() => heart.classList.remove('pulse'), 500);
                }
            } else {
                heart.classList.add('lost');
                heart.classList.remove('pulse');
            }
        }
    },

    createShipExplosion(x, y) {
        // Gros explosion
        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 3 + Math.random() * 6;
            const size = 4 + Math.random() * 6;
            
            this.explosionParticles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: size,
                life: 1.0,
                color: CFG.COLORS.player,
                decay: 0.015 + Math.random() * 0.015
            });
        }
        
        // Petites explosions secondaires
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 50;
            const size = 2 + Math.random() * 4;
            
            setTimeout(() => {
                const ex = x + Math.cos(angle) * distance;
                const ey = y + Math.sin(angle) * distance;
                
                for (let j = 0; j < 15; j++) {
                    const a = Math.random() * Math.PI * 2;
                    const s = 1 + Math.random() * 3;
                    
                    this.explosionParticles.push({
                        x: ex,
                        y: ey,
                        vx: Math.cos(a) * s,
                        vy: Math.sin(a) * s,
                        size: size,
                        life: 0.8,
                        color: '#ff5500',
                        decay: 0.02 + Math.random() * 0.02
                    });
                }
            }, Math.random() * 500);
        }
        
        this.screenShake(10, 500);
    },

    screenShake(intensity, duration) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
    },

    die() {
        if (this.gameOver || !this.player) return;
        
        if (this.player.invincible) return;
        
        this.lives--;
        this.updateHearts();
        
        if (this.lives > 0) {
            this.spawnExplosion(this.player.x, this.player.y, CFG.COLORS.enemyCircle);
            
            // Invincibilit√© temporaire (2 secondes)
            this.player.invincible = true;
            this.player.invincibleTimer = 120;
            
            // Position de respawn
            this.player.x = 0;
            this.player.y = 0;
            this.player.vx = 0;
            this.player.vy = 0;
            
            // Ajouter la classe d'invincibilit√©
            this.canvas.classList.add('player-invincible');
            
            // Reset combo
            this.combo = 0;
            this.updateComboDisplay();
        } else {
            this.gameOver = true;
            this.isRunning = false;
            
            this.createShipExplosion(this.player.x, this.player.y);
            
            // Nettoyer la classe d'invincibilit√©
            this.canvas.classList.remove('player-invincible');
            
            setTimeout(() => {
                this.player = null;
                
                this.saveBestScore();
                
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('best-score').textContent = this.bestScore;
                document.getElementById('final-level').textContent = this.level;
                document.getElementById('final-combo').textContent = `x${this.maxCombo}`;
                document.getElementById('final-kills').textContent = this.enemiesKilled;
                
                setTimeout(() => document.getElementById('restart-btn').focus(), 100);
            }, 1500);
        }
    },

    spawnExplosion(x, y, color) {
        for(let i=0; i<20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    },

    findNearestEnemy() {
        let nearest = null;
        let nearestDist = Infinity;
        
        for (const enemy of this.enemies) {
            const dx = enemy.x - this.player.x;
            const dy = enemy.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist) {
                nearestDist = dist;
                nearest = enemy;
            }
        }
        
        return nearest;
    },

    loop(timestamp) {
        this.deltaTime = Math.min(timestamp - this.lastTime, 32);
        this.lastTime = timestamp;
        
        if (this.isRunning) {
            this.timePlayed += this.deltaTime;
        }
        
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        if(this.isRunning && this.player) {
            this.update();
            this.draw();
        } else if (this.gameOver) {
            this.updateExplosionParticles();
            this.drawBackground();
            this.draw();
        } else {
            this.drawBackground();
        }
        
        requestAnimationFrame((t) => this.loop(t));
    },

    update() {
        if (!this.player || !this.isRunning) return;
        
        if (this.fireCooldown > 0) {
            this.fireCooldown -= 1;
        }
        
        // Mise √† jour du joystick
        if (!this.joystickActive) {
            this.joystickX = 0;
            this.joystickY = 0;
        }
        
        // Contr√¥les clavier
        if ((this.keys['Space'] || this.keys['ShiftLeft']) && this.fireCooldown <= 0 && !this.player.invincible) {
            this.player.fire();
            this.fireCooldown = CFG.FIRE_RATE;
        }
        
        // G√©n√©ration d'ennemis
        this.spawnTimer++;
        const spawnRate = Math.max(5, 40 - this.level * 2);
        if(this.spawnTimer >= spawnRate) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }
        
        this.player.update();
        
        // Mise √† jour de la cam√©ra avec limites du monde
        if (this.player && !this.player.invincible) {
            let targetCamX = this.player.x - this.width / 2;
            let targetCamY = this.player.y - this.height / 2;
            
            // Limites de la cam√©ra
            const maxCamX = CFG.WORLD_WIDTH/2 - this.width;
            const maxCamY = CFG.WORLD_HEIGHT/2 - this.height;
            const minCamX = -CFG.WORLD_WIDTH/2;
            const minCamY = -CFG.WORLD_HEIGHT/2;
            
            targetCamX = Math.max(minCamX, Math.min(targetCamX, maxCamX));
            targetCamY = Math.max(minCamY, Math.min(targetCamY, maxCamY));
            
            this.cameraX += (targetCamX - this.cameraX) * 0.08;
            this.cameraY += (targetCamY - this.cameraY) * 0.08;
        }
        
        // Mettre √† jour les ennemis
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            enemy.update();
            
            // V√©rifier la collision avec le joueur
            if(this.player && !this.player.invincible && this.circleIntersect(this.player, enemy)) {
                this.die();
                enemy.markForRemoval = true;
            }
            
            // V√©rifier si l'ennemi est hors des limites
            if (enemy.x < -CFG.WORLD_WIDTH/2 - 200 || enemy.x > CFG.WORLD_WIDTH/2 + 200 ||
                enemy.y < -CFG.WORLD_HEIGHT/2 - 200 || enemy.y > CFG.WORLD_HEIGHT/2 + 200) {
                enemy.markForRemoval = true;
            }
        }
        
        // Mettre √† jour les projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.update();
            
            // V√©rifier les collisions avec les ennemis
            for (let j = this.enemies.length - 1; j >= 0; j--) {
                const enemy = this.enemies[j];
                if (this.circleIntersect(proj, enemy)) {
                    this.score += 100 * this.combo;
                    this.enemiesKilled++;
                    this.incrementCombo();
                    this.spawnExplosion(enemy.x, enemy.y, enemy.color);
                    enemy.markForRemoval = true;
                    this.projectiles.splice(i, 1);
                    this.enemyCount--;
                    this.updateHUD();
                    this.screenShake(3, 100);
                    break;
                }
            }
            
            // Supprimer les projectiles hors √©cran
            if (proj.life <= 0) {
                this.projectiles.splice(i, 1);
            }
        }
        
        // Nettoyer les ennemis marqu√©s pour suppression
        this.enemies = this.enemies.filter(en => !en.markForRemoval);
        
        // Mettre √† jour les particules
        this.particles = this.particles.filter(p => p.update());
        
        // Mettre √† jour les particules de fond
        this.updateBackgroundParticles();
        
        // Mettre √† jour le screen shake
        if (this.shakeDuration > 0) {
            this.shakeDuration -= this.deltaTime;
        } else {
            this.shakeIntensity = 0;
        }
        
        // Augmenter le niveau
        if(this.score >= this.level * 1500) {
            this.level++;
            this.updateLevelDisplay();
            this.screenShake(5, 200);
            
            // Cr√©er un effet de niveau up
            for (let i = 0; i < 30; i++) {
                this.particles.push(new Particle(
                    this.player ? this.player.x : 0,
                    this.player ? this.player.y : 0,
                    CFG.COLORS.nebula2,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    25,
                    true
                ));
            }
        }
    },

    updateBackgroundParticles() {
        for (const p of this.backgroundParticles) {
            p.x += Math.cos(p.direction) * p.speed;
            p.y += Math.sin(p.direction) * p.speed;
            
            // Rebond sur les bords
            if (p.x < -CFG.WORLD_WIDTH/2 || p.x > CFG.WORLD_WIDTH/2) {
                p.direction = Math.PI - p.direction;
            }
            if (p.y < -CFG.WORLD_HEIGHT/2 || p.y > CFG.WORLD_HEIGHT/2) {
                p.direction = -p.direction;
            }
        }
    },

    updateExplosionParticles() {
        for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
            const p = this.explosionParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= p.decay;
            
            if (p.life <= 0) {
                this.explosionParticles.splice(i, 1);
            }
        }
    },

    circleIntersect(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius1 = obj1.size ? obj1.size/2 : (obj1.radius || 0);
        const radius2 = obj2.size ? obj2.size/2 : (obj2.radius || 0);
        return distance < radius1 + radius2;
    },

    drawBackground() {
        // Fond d√©grad√©
        const gradient = this.ctx.createRadialGradient(
            this.width/2, this.height/2, 0,
            this.width/2, this.height/2, Math.max(this.width, this.height)/2
        );
        gradient.addColorStop(0, '#050510');
        gradient.addColorStop(0.5, '#03031a');
        gradient.addColorStop(1, '#010125');
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        // Appliquer le screen shake
        if (this.shakeIntensity > 0) {
            const shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
            const shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
            this.ctx.translate(shakeX, shakeY);
        }
        
        this.ctx.save();
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        // Dessiner les n√©buleuses
        this.nebulas.forEach(nebula => {
            this.ctx.save();
            this.ctx.translate(nebula.x, nebula.y);
            this.ctx.rotate(nebula.rotation);
            
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, nebula.size);
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'transparent');
            
            this.ctx.fillStyle = gradient;
            this.ctx.globalAlpha = 0.3;
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, nebula.size, nebula.size * 0.5, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.restore();
            
            nebula.rotation += nebula.rotationSpeed;
        });
        
        // Dessiner les √©toiles
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        this.stars.forEach(star => {
            const twinkle = Math.sin(this.timePlayed * 0.001 * star.twinkleSpeed + star.twinkleOffset) * 0.3 + 0.7;
            this.ctx.globalAlpha = star.opacity * twinkle;
            const x = star.x - this.cameraX * star.speed * 0.05;
            const y = star.y - this.cameraY * star.speed * 0.05;
            
            if (x > -100 && x < this.width + 100 && y > -100 && y < this.height + 100) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
        
        // Dessiner les particules de fond
        this.backgroundParticles.forEach(p => {
            this.ctx.globalAlpha = p.opacity;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.globalAlpha = 1;
        this.ctx.restore();
        
        // R√©initialiser la transformation du screen shake
        if (this.shakeIntensity > 0) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
    },

    draw() {
        this.drawBackground();
        
        this.ctx.save();
        
        // Appliquer le screen shake
        if (this.shakeIntensity > 0) {
            const shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
            const shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
            this.ctx.translate(shakeX, shakeY);
        }
        
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        this.drawGrid();
        
        // Dessiner les projectiles
        this.projectiles.forEach(p => p.draw(this.ctx));
        
        // Dessiner les ennemis
        this.enemies.forEach(en => en.draw(this.ctx));
        
        // Dessiner les particules
        this.particles.forEach(p => p.draw(this.ctx));
        
        // Dessiner les particules d'explosion
        this.explosionParticles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.shadowBlur = p.life * 15;
            this.ctx.shadowColor = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1;
            this.ctx.shadowBlur = 0;
        });
        
        // Dessiner le joueur
        if (this.player) {
            this.player.draw(this.ctx);
        }
        
        this.ctx.restore();
    },

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.05)';
        this.ctx.lineWidth = 1;
        let step = 150;
        let startX = Math.floor((this.cameraX - this.width) / step) * step;
        let startY = Math.floor((this.cameraY - this.height) / step) * step;
        
        for(let x = startX; x < startX + this.width * 2 + step; x += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);
            this.ctx.lineTo(x, startY + this.height * 2 + step);
            this.ctx.stroke();
        }
        
        for(let y = startY; y < startY + this.height * 2 + step; y += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(startX, y);
            this.ctx.lineTo(startX + this.width * 2 + step, y);
            this.ctx.stroke();
        }
        
        // Centre de l'ar√®ne
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.2)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 500, 0, Math.PI * 2);
        this.ctx.stroke();
    }
};

/**
 * CLASSES DES OBJETS - OPTIMIS√âES POUR PAYSAGE
 */
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.size = Game.isMobile ? CFG.PLAYER_SIZE * 0.9 : CFG.PLAYER_SIZE;
        this.angle = 0;
        this.engineParticles = 0;
        this.wingFlap = 0;
        this.autoRotateSpeed = 0.1;
        
        // Propri√©t√©s d'invincibilit√©
        this.invincible = false;
        this.invincibleTimer = 0;
        
        // Effets visuels
        this.engineGlow = 0;
        this.trail = [];
    }

    updateInvincibility() {
        if (this.invincible) {
            this.invincibleTimer--;
            
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
                this.invincibleTimer = 0;
                Game.canvas.classList.remove('player-invincible');
            }
        }
    }

    fire() {
        if (this.invincible) return;
        
        Game.shotsFired++;
        const proj = new Projectile(
            this.x + Math.cos(this.angle) * this.size/2,
            this.y + Math.sin(this.angle) * this.size/2,
            Math.cos(this.angle) * CFG.PROJECTILE_SPEED,
            Math.sin(this.angle) * CFG.PROJECTILE_SPEED,
            this.angle
        );
        Game.projectiles.push(proj);
        Game.updateHUD();
        
        // Recul
        this.vx -= Math.cos(this.angle) * 1.2;
        this.vy -= Math.sin(this.angle) * 1.2;
        
        // Effet visuel
        Game.screenShake(1, 50);
    }

    update() {
        this.updateInvincibility();
        
        // Contr√¥les clavier
        if(Game.keys['ArrowLeft'] || Game.keys['KeyA']) this.vx -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowRight'] || Game.keys['KeyD']) this.vx += CFG.SPEED * 0.2;
        if(Game.keys['ArrowUp'] || Game.keys['KeyW']) this.vy -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowDown'] || Game.keys['KeyS']) this.vy += CFG.SPEED * 0.2;
        
        // Contr√¥les joystick
        if (Game.joystickActive) {
            const sensitivity = 0.4;
            this.vx += Game.joystickX * CFG.SPEED * sensitivity;
            this.vy += Game.joystickY * CFG.SPEED * sensitivity;
        }
        
        this.wingFlap += 0.2;
        this.engineGlow = (this.engineGlow + 0.1) % (Math.PI * 2);
        
        // Auto-rotation vers l'ennemi le plus proche
        const nearestEnemy = Game.findNearestEnemy();
        if (nearestEnemy) {
            const dx = nearestEnemy.x - this.x;
            const dy = nearestEnemy.y - this.y;
            const targetAngle = Math.atan2(dy, dx);
            
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            this.angle += angleDiff * this.autoRotateSpeed;
        }
        
        // Friction
        this.vx *= CFG.FRICTION;
        this.vy *= CFG.FRICTION;
        
        // Mise √† jour de la position avec limites du monde
        this.x += this.vx;
        this.y += this.vy;
        
        const maxX = CFG.WORLD_WIDTH/2 - 100;
        const maxY = CFG.WORLD_HEIGHT/2 - 100;
        this.x = Math.max(-maxX, Math.min(this.x, maxX));
        this.y = Math.max(-maxY, Math.min(this.y, maxY));
        
        // Mise √† jour de la tra√Æn√©e
        this.trail.push({x: this.x, y: this.y, angle: this.angle});
        if (this.trail.length > 15) this.trail.shift();
        
        // Particules de moteur
        this.engineParticles++;
        if(this.engineParticles > 3 && (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1)) {
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            for(let i = 0; i < 3; i++) {
                const angle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                const power = Math.random() * speed * 0.5;
                Game.particles.push(new Particle(
                    this.x - Math.cos(this.angle) * this.size/2,
                    this.y - Math.sin(this.angle) * this.size/2,
                    CFG.COLORS.player,
                    Math.cos(angle) * power,
                    Math.sin(angle) * power,
                    15
                ));
            }
            this.engineParticles = 0;
        }
    }

    draw(ctx) {
        // Dessiner la tra√Æn√©e
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.3;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            ctx.rotate(point.angle);
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = CFG.COLORS.player;
            
            // Forme simplifi√©e pour la tra√Æn√©e
            ctx.beginPath();
            ctx.moveTo(this.size/4, 0);
            ctx.lineTo(-this.size/4, -this.size/4);
            ctx.lineTo(-this.size/4, this.size/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        const wingOffset = Math.sin(this.wingFlap) * 4;
        const enginePulse = Math.sin(this.engineGlow) * 0.2 + 0.8;
        
        // Effet de glow autour du vaisseau
        if (!this.invincible) {
            ctx.shadowBlur = 40;
            ctx.shadowColor = CFG.COLORS.player;
        } else {
            ctx.shadowBlur = 60;
            ctx.shadowColor = '#ffffff';
        }
        
        // Corps principal avec effet n√©on
        const gradient = ctx.createLinearGradient(-this.size/2, 0, this.size/2, 0);
        gradient.addColorStop(0, '#0088ff');
        gradient.addColorStop(0.5, CFG.COLORS.player);
        gradient.addColorStop(1, '#00aaff');
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        
        // Forme am√©lior√©e du vaisseau
        ctx.moveTo(this.size/2, 0);
        ctx.lineTo(this.size/4, -this.size/3);
        ctx.lineTo(-this.size/4, -this.size/2 + wingOffset);
        ctx.lineTo(-this.size/2, -this.size/4);
        ctx.lineTo(-this.size/2, this.size/4);
        ctx.lineTo(-this.size/4, this.size/2 - wingOffset);
        ctx.lineTo(this.size/4, this.size/3);
        ctx.closePath();
        
        ctx.fill();
        ctx.stroke();
        
        // Cockpit avec effet de verre
        ctx.fillStyle = 'rgba(0, 100, 255, 0.6)';
        ctx.beginPath();
        ctx.ellipse(this.size/6, 0, this.size/3, this.size/4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // R√©flexion du cockpit
        ctx.fillStyle = 'rgba(150, 220, 255, 0.4)';
        ctx.beginPath();
        ctx.ellipse(this.size/3, -this.size/8, this.size/6, this.size/8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Propulseurs avec effet de pulsation
        ctx.fillStyle = `rgba(255, ${100 + Math.floor(enginePulse * 155)}, 0, 0.9)`;
        ctx.fillRect(-this.size/2, -this.size/8, this.size/6, this.size/4);
        ctx.fillRect(-this.size/2 + this.size/5, -this.size/8, this.size/6, this.size/4);
        
        // Canon
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.size/2 - 10, -this.size/10, 15, this.size/5);
        
        // Effet de tir sur le canon
        if (Game.fireCooldown > CFG.FIRE_RATE - 5) {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(this.size/2, -this.size/12, 8, this.size/6);
        }
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, vx, vy, angle) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = Game.isMobile ? 5 : 6;
        this.life = 150;
        this.angle = angle;
        this.trail = [];
        this.sparkleTimer = 0;
    }
    
    update() {
        this.sparkleTimer++;
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 8) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        // Cr√©er des √©tincelles
        if (Math.random() < 0.8) {
            Game.particles.push(new Particle(
                this.x,
                this.y,
                CFG.COLORS.projectile,
                -this.vx * 0.2 + (Math.random() - 0.5) * 0.5,
                -this.vy * 0.2 + (Math.random() - 0.5) * 0.5,
                8
            ));
        }
        
        return this.life > 0;
    }
    
    draw(ctx) {
        // Tra√Æn√©e
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.6;
            const size = this.radius * (i / this.trail.length);
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.fillStyle = `rgba(255, 150, 50, ${alpha})`;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Projectile principal
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 25;
        ctx.shadowColor = CFG.COLORS.projectile;
        
        // Corps du projectile avec effet de chaleur
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 2);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.3, '#ffaa00');
        gradient.addColorStop(0.7, CFG.COLORS.projectile);
        gradient.addColorStop(1, '#990000');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, -this.radius);
        ctx.lineTo(this.radius * 4, 0);
        ctx.lineTo(0, this.radius);
        ctx.closePath();
        ctx.fill();
        
        // Centre brillant
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.radius, 0, this.radius/2, 0, Math.PI * 2);
        ctx.fill();
        
        // √âtincelles
        if (this.sparkleTimer % 3 === 0) {
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(-this.radius, (Math.random() - 0.5) * this.radius, this.radius/3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, vx, vy, type, size) {
        this.x = x;
        this.y = y;
        this.vx = vx * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.08);
        this.vy = vy * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.08);
        this.type = type;
        this.size = Game.isMobile ? size * 0.85 : size;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.08;
        this.markForRemoval = false;
        this.pulse = 0;
        this.animationTime = 0;
        this.color = CFG.COLORS[`enemy${type.charAt(0).toUpperCase() + type.slice(1)}`] || CFG.COLORS.enemyCircle;
        this.hitFlash = 0;
        this.trail = [];
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.pulse += 0.06;
        this.animationTime += 0.12;
        
        if (this.hitFlash > 0) this.hitFlash--;
        
        // Mise √† jour de la tra√Æn√©e
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 10) this.trail.shift();
        
        // Comportement intelligent
        if (Game.player && !Game.player.invincible) {
            const dx = Game.player.x - this.x;
            const dy = Game.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if(distance < 800) {
                // Suivi du joueur
                this.vx += dx * 0.0002 * Game.level;
                this.vy += dy * 0.0002 * Game.level;
                
                // √âvitement √† courte distance
                if (distance < 200) {
                    this.vx -= dx * 0.0005;
                    this.vy -= dy * 0.0005;
                }
            }
        }
        
        // √âviter les autres ennemis
        Game.enemies.forEach(other => {
            if (other !== this) {
                const odx = other.x - this.x;
                const ody = other.y - this.y;
                const odist = Math.sqrt(odx * odx + ody * ody);
                const minDist = (this.size/2) + (other.size/2) + 20;
                
                if (odist < minDist && odist > 0) {
                    const force = 0.1;
                    this.vx -= (odx / odist) * force;
                    this.vy -= (ody / odist) * force;
                }
            }
        });
        
        // Limiter la vitesse
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        const maxSpeed = 4 + Game.level * 0.15;
        if(speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
        }
    }

    draw(ctx) {
        // Dessiner la tra√Æn√©e
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.4;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.size/4 * (i/this.trail.length), 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Effet de hit flash
        if (this.hitFlash > 0) {
            ctx.shadowBlur = 50;
            ctx.shadowColor = 'white';
        } else {
            ctx.shadowBlur = 30;
            ctx.shadowColor = this.color;
        }
        
        ctx.rotate(this.rotation);
        
        const pulseSize = 1 + Math.sin(this.pulse) * 0.15;
        ctx.scale(pulseSize, pulseSize);
        
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        
        // Dessiner selon le type d'ennemi
        switch(this.type) {
            case 'circle':
                this.drawCircleEnemy(ctx);
                break;
            case 'triangle':
                this.drawTriangleEnemy(ctx);
                break;
            case 'square':
                this.drawSquareEnemy(ctx);
                break;
            case 'star':
                this.drawStarEnemy(ctx);
                break;
            case 'hexagon':
                this.drawHexagonEnemy(ctx);
                break;
            case 'spiral':
                this.drawSpiralEnemy(ctx);
                break;
            case 'drone':
                this.drawDroneEnemy(ctx);
                break;
        }
        
        ctx.restore();
    }
    
    drawCircleEnemy(ctx) {
        // Anneaux ext√©rieurs
        for(let i = 0; i < 8; i++) {
            const segmentAngle = (i / 8) * Math.PI * 2 + this.rotation * 2;
            ctx.save();
            ctx.rotate(segmentAngle);
            
            const segmentPulse = Math.sin(this.animationTime * 2 + i) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)}, ${parseInt(this.color.slice(3,5),16)}, ${parseInt(this.color.slice(5,7),16)}, ${0.4 + segmentPulse * 0.3})`;
            
            ctx.beginPath();
            ctx.arc(0, this.size/2.5, this.size/5 * (0.6 + segmentPulse * 0.4), 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Corps principal
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Bouche anim√©e
        ctx.fillStyle = '#111';
        const mouthOpen = Math.sin(this.animationTime * 3) * 0.4 + 0.6;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/3, 0, Math.PI * mouthOpen);
        ctx.fill();
        
        // Yeux
        ctx.fillStyle = 'white';
        const eyeSize = this.size/6 * (0.8 + Math.sin(this.animationTime * 4) * 0.2);
        ctx.beginPath();
        ctx.arc(-this.size/4, -this.size/6, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.size/4, -this.size/6, eyeSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    drawTriangleEnemy(ctx) {
        const trianglePulse = Math.sin(this.animationTime * 2.5) * 0.25;
        
        ctx.beginPath();
        ctx.moveTo(0, -this.size/2 * (1 + trianglePulse));
        ctx.lineTo(this.size/2, this.size/2 * (1 - trianglePulse/2));
        ctx.lineTo(-this.size/2, this.size/2 * (1 - trianglePulse/2));
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Motif int√©rieur
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.moveTo(0, -this.size/3);
        ctx.lineTo(this.size/3, this.size/4);
        ctx.lineTo(-this.size/3, this.size/4);
        ctx.closePath();
        ctx.fill();
        
        // Yeux
        ctx.fillStyle = 'white';
        const blink = Math.sin(this.animationTime * 4) > 0 ? 1 : 0;
        if(blink) {
            ctx.beginPath();
            ctx.arc(-this.size/4, -this.size/8, this.size/8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size/4, -this.size/8, this.size/8, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    drawSquareEnemy(ctx) {
        const squareWobble = Math.sin(this.animationTime * 3) * 0.25;
        
        ctx.save();
        ctx.scale(1 + squareWobble, 1 - squareWobble);
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.restore();
        
        // Motif int√©rieur rotatif
        ctx.save();
        ctx.rotate(this.animationTime);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        const patternSize = this.size/2.5 * (0.8 + Math.sin(this.animationTime * 2) * 0.2);
        ctx.fillRect(-patternSize/2, -patternSize/2, patternSize, patternSize);
        ctx.restore();
    }
    
    drawStarEnemy(ctx) {
        const spikes = 7;
        const outerRadius = this.size/2;
        const innerRadius = this.size/3;
        const starPulse = Math.sin(this.animationTime * 2) * 0.35 + 0.65;
        
        ctx.beginPath();
        for(let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius * starPulse : innerRadius;
            const angle = (Math.PI * i) / spikes + this.animationTime;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Centre rotatif avec effet de pulsation
        ctx.save();
        ctx.rotate(this.animationTime * 2);
        ctx.fillStyle = 'white';
        const centerPulse = Math.sin(this.animationTime * 3) * 0.2 + 0.8;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/5 * centerPulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    drawHexagonEnemy(ctx) {
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            const angle = (Math.PI * i) / 3 + Math.sin(this.animationTime + i) * 0.3;
            const radius = this.size/2 * (1 + Math.cos(this.animationTime * 2 + i) * 0.15);
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Hexagone int√©rieur rotatif
        ctx.save();
        ctx.rotate(-this.animationTime);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            const angle = (Math.PI * i) / 3;
            const radius = this.size/3;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    
    drawSpiralEnemy(ctx) {
        // Spirale
        ctx.beginPath();
        for(let i = 0; i < 25; i++) {
            const angle = i * 0.25 + this.animationTime * 2;
            const radius = (i / 25) * (this.size/2);
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            if(i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        // Centre avec effet de rotation
        ctx.save();
        ctx.rotate(this.animationTime * 3);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/3, 0, Math.PI * 2);
        ctx.fill();
        
        // Motif du centre
        ctx.fillStyle = 'white';
        for(let i = 0; i < 4; i++) {
            const angle = (Math.PI * i) / 2;
            const radius = this.size/6;
            ctx.beginPath();
            ctx.arc(Math.cos(angle) * radius/2, Math.sin(angle) * radius/2, radius/3, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    drawDroneEnemy(ctx) {
        // Corps central
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/2.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Bras
        for(let i = 0; i < 4; i++) {
            const angle = (Math.PI * i) / 2;
            ctx.save();
            ctx.rotate(angle);
            
            // Bras
            ctx.fillStyle = this.color;
            ctx.fillRect(0, -this.size/20, this.size/2, this.size/10);
            
            // H√©lices
            ctx.save();
            ctx.translate(this.size/2, 0);
            ctx.rotate(this.animationTime * 5);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            for(let j = 0; j < 3; j++) {
                const bladeAngle = (Math.PI * 2 * j) / 3;
                ctx.save();
                ctx.rotate(bladeAngle);
                ctx.fillRect(-this.size/30, -this.size/3, this.size/15, this.size/1.5);
                ctx.restore();
            }
            ctx.restore();
            
            ctx.restore();
        }
        
        // ≈íil central
        ctx.fillStyle = 'white';
        const eyePulse = Math.sin(this.animationTime * 4) * 0.3 + 0.7;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/6 * eyePulse, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color, vx = 0, vy = 0, life = 30, special = false) {
        this.x = x; this.y = y;
        this.vx = vx || (Math.random() - 0.5) * 6;
        this.vy = vy || (Math.random() - 0.5) * 6;
        this.life = life;
        this.maxLife = life;
        this.color = color;
        this.size = Math.random() * (Game.isMobile ? 3 : 4) + 2;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
        this.special = special;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 1;
        this.rotation += this.rotationSpeed;
        
        // R√©duction de la taille au fil du temps
        this.size *= 0.97;
        
        return this.life > 0;
    }
    
    draw(ctx) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        
        if (this.special) {
            // Particules sp√©ciales (combo, level up)
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // Forme √©toil√©e pour les effets sp√©ciaux
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5;
                const radius = this.size;
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                
                const innerAngle = angle + Math.PI / 5;
                const innerRadius = this.size / 2;
                ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        } else {
            // Particules normales
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 5;
            ctx.shadowColor = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
    }
}

// Lancement
window.addEventListener('DOMContentLoaded', () => {
    Game.init();
    
    // Pr√©venir le zoom tactile
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) e.preventDefault();
    }, { passive: false });
    
    // Support PWA (Progressive Web App)
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js').catch(error => {
                console.log('ServiceWorker registration failed:', error);
            });
        });
    }
});
</script>
</body>
</html>
