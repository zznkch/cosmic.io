<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Devil - Shooter Edition</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff007a;
            --neon-purple: #bc13fe;
            --neon-green: #39ff14;
            --neon-yellow: #ffd700;
            --neon-red: #ff3333;
            --bg-dark: #050505;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
        }

        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: var(--bg-dark);
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg-dark);
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #080810, #00051a);
        }

        /* UI Styles */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: opacity 0.3s;
            padding: 20px;
            padding-top: calc(20px + var(--safe-area-top));
            padding-bottom: calc(20px + var(--safe-area-bottom));
        }

        /* HUD r√©vis√© pour √©viter la superposition */
        .hud {
            position: fixed;
            top: max(15px, var(--safe-area-top));
            left: max(15px, var(--safe-area-left));
            right: max(15px, var(--safe-area-right));
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 15px;
            /* Ajuster pour laisser de la place au bouton plein √©cran */
            padding-right: 70px; /* Espace pour le bouton plein √©cran */
        }

        .score-display {
            font-size: 28px;
            font-weight: bold;
            color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .lives-container {
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .heart {
            width: 30px;
            height: 30px;
            position: relative;
        }

        .heart svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 5px var(--neon-blue));
            transition: all 0.3s;
        }

        .heart.lost svg {
            fill: #333;
            filter: none;
        }

        /* Bouton triangle pour jouer */
        .play-triangle {
            width: 0;
            height: 0;
            border-left: 50px solid var(--neon-green);
            border-top: 30px solid transparent;
            border-bottom: 30px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            margin: 30px;
            filter: drop-shadow(0 0 15px var(--neon-green));
            background: none;
            border-right: none;
        }

        .play-triangle:hover {
            transform: scale(1.1);
            border-left-color: var(--neon-blue);
            filter: drop-shadow(0 0 25px var(--neon-blue));
        }

        .play-triangle:active {
            transform: scale(0.95);
        }

        /* Contr√¥les mobiles - Joystick am√©lior√© */
        #mobile-controls {
            position: fixed;
            bottom: max(20px, var(--safe-area-bottom));
            width: 100vw;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 60;
            gap: 20px;
        }

        .joystick-container {
            position: relative;
            width: 150px;
            height: 150px;
            touch-action: none;
        }

        .joystick-boundary {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--neon-blue);
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(0, 242, 255, 0.3),
                inset 0 0 20px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(5px);
            pointer-events: none;
        }

        .joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            background: linear-gradient(45deg, var(--neon-blue), #00a8ff);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(0, 242, 255, 0.8),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
            transition: transform 0.1s;
            pointer-events: none;
            z-index: 2;
        }

        .joystick-thumb.active {
            box-shadow: 
                0 0 30px rgba(0, 242, 255, 1),
                inset 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .action-btn {
            width: clamp(70px, 20vw, 100px);
            height: clamp(70px, 20vw, 100px);
            background: rgba(0, 100, 255, 0.3);
            border: 3px solid var(--neon-green);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 
                0 0 20px rgba(57, 255, 20, 0.5),
                inset 0 0 10px rgba(57, 255, 20, 0.2);
            transition: all 0.1s;
            align-self: flex-end;
            margin-bottom: 20px;
            position: relative;
        }

        .action-btn.active {
            background: rgba(0, 100, 255, 0.5);
            transform: scale(0.95);
            box-shadow: 
                0 0 30px rgba(57, 255, 20, 0.8),
                inset 0 0 15px rgba(57, 255, 20, 0.3);
        }

        .target-icon {
            width: 70%;
            height: 70%;
            position: relative;
        }

        .target-icon::before,
        .target-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 2px solid var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
        }

        .target-icon::before {
            width: 80%;
            height: 80%;
        }

        .target-icon::after {
            width: 40%;
            height: 40%;
        }

        .target-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20%;
            height: 20%;
            background: var(--neon-green);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .target-cross {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 80%;
            background: var(--neon-green);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px var(--neon-green);
        }

        .target-cross::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 2px;
            background: var(--neon-green);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px var(--neon-green);
        }

        /* Orientation d√©tection */
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        .orientation-warning h2 {
            color: var(--neon-pink);
            margin-bottom: 20px;
            font-size: clamp(1.5rem, 5vw, 2rem);
        }

        .orientation-warning p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 4vw, 1.2rem);
        }

        /* Style pour l'√©cran de d√©marrage */
        .start-content {
            text-align: center;
            max-width: min(800px, 90vw);
            padding: 0 20px;
        }
        
        .start-content h1 {
            font-size: clamp(2.5rem, 10vw, 4rem);
            color: var(--neon-pink);
            text-shadow: 0 0 20px var(--neon-pink);
            margin-bottom: clamp(10px, 3vw, 20px);
            line-height: 1.2;
        }
        
        .start-content p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 4vw, 1.2rem);
            margin-bottom: clamp(20px, 5vw, 30px);
            line-height: 1.5;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .score-display {
                font-size: 24px;
                padding: 4px 12px;
            }
            
            .heart {
                width: 25px;
                height: 25px;
            }
            
            #mobile-controls {
                display: flex;
            }

            .joystick-container {
                width: 120px;
                height: 120px;
            }

            .joystick-thumb {
                width: 60px;
                height: 60px;
            }
            
            /* Ajustement du HUD pour mobile */
            .hud {
                padding-right: 60px; /* Moins d'espace sur mobile */
            }
            
            .play-triangle {
                border-left-width: 40px;
                border-top-width: 25px;
                border-bottom-width: 25px;
            }
        }

        @media (min-width: 1200px) {
            .score-display {
                font-size: 32px;
            }
            
            .heart {
                width: 35px;
                height: 35px;
            }
            
            .play-triangle {
                border-left-width: 60px;
                border-top-width: 35px;
                border-bottom-width: 35px;
            }
        }

        @media (orientation: portrait) and (max-width: 768px) {
            .orientation-warning {
                display: flex;
            }
            
            #game-container:not(.allow-portrait) {
                display: none;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .score-display {
                font-size: 20px;
            }
            
            .heart {
                width: 20px;
                height: 20px;
            }
            
            .hud {
                padding-right: 50px; /* Moins d'espace sur les √©crans tr√®s courts */
            }
        }

        /* Support pour √©crans tr√®s larges (TV) */
        @media (min-aspect-ratio: 16/9) {
            canvas {
                object-fit: cover;
            }
        }

        .hidden { display: none !important; }

        /* Mode plein √©cran - position r√©vis√©e */
        .fullscreen-btn {
            position: fixed;
            top: max(20px, var(--safe-area-top));
            right: max(20px, var(--safe-area-right));
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid var(--neon-green);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--neon-green);
            font-size: 20px;
            cursor: pointer;
            z-index: 70;
            backdrop-filter: blur(5px);
            /* Assure que le bouton est toujours au-dessus */
            z-index: 51;
        }

        /* Sur mobile, d√©placer le bouton en bas si n√©cessaire */
        @media (max-width: 768px) and (orientation: landscape) {
            .fullscreen-btn {
                top: auto;
                bottom: max(20px, var(--safe-area-bottom));
            }
        }

        /* √âcran Mission Failed */
        .mission-failed {
            text-align: center;
            max-width: min(600px, 90vw);
        }

        .mission-failed h1 {
            font-size: clamp(2.5rem, 8vw, 4rem);
            color: var(--neon-red);
            text-shadow: 0 0 20px var(--neon-red);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .score-results {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid rgba(255, 51, 51, 0.3);
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.2);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            font-size: 1.2rem;
        }

        .score-label {
            color: #ddd;
        }

        .score-value {
            color: var(--neon-yellow);
            font-weight: bold;
            font-size: 1.4rem;
        }

        .highscore-value {
            color: var(--neon-green);
            font-weight: bold;
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--neon-green);
        }
    </style>
</head>
<body>

<div class="orientation-warning">
    <div>
        <h2>üîÑ Tournez votre appareil</h2>
        <p>Pour une meilleure exp√©rience de jeu, veuillez utiliser votre appareil en mode paysage.</p>
    </div>
</div>

<div id="game-container">
    <div class="hud">
        <div class="score-display" id="score-display">0</div>
        <div class="lives-container" id="lives-container">
            <div class="heart" id="heart-1">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-2">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-3">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
        </div>
    </div>

    <button class="fullscreen-btn" id="fullscreen-btn" title="Plein √©cran">‚õ∂</button>

    <div id="start-screen" class="overlay">
        <div class="start-content">
            <h1>NEON DEVIL<br>SHOOTER</h1>
            <p>Destroy aliens! Survive as long as possible.</p>
            <button class="play-triangle" onclick="Game.start()" id="play-triangle-btn" aria-label="Jouer"></button>
        </div>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <div class="mission-failed">
            <h1>MISSION FAILED</h1>
            <div class="score-results">
                <div class="score-item">
                    <span class="score-label">SCORE:</span>
                    <span class="score-value" id="final-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">BEST SCORE:</span>
                    <span class="highscore-value" id="best-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">LEVEL:</span>
                    <span class="score-value" id="final-level">1</span>
                </div>
                <div class="score-item">
                    <span class="score-label">SHOTS FIRED:</span>
                    <span class="score-value" id="final-shots">0</span>
                </div>
            </div>
            <button class="play-triangle" onclick="Game.start()" id="restart-btn" aria-label="Recommencer"></button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div id="mobile-controls">
        <div class="control-group">
            <div class="joystick-container">
                <div class="joystick-boundary"></div>
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="action-btn" id="btn-fire">
                <div class="target-icon">
                    <div class="target-cross"></div>
                    <div class="target-center"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * CONFIGURATION & CONSTANTES
 */
const CFG = {
    GRAVITY: 0.15,
    FRICTION: 0.9,
    JUMP_FORCE: -8,
    SPEED: 5,
    PLAYER_SIZE: 45,
    ENEMY_SPEED_MULTIPLIER: 0.7,
    PROJECTILE_SPEED: 15,
    FIRE_RATE: 5,
    JOYSTICK_RADIUS: 60,
    COLORS: {
        player: '#00f2ff',
        enemyCircle: '#ff007a',
        enemyTriangle: '#bc13fe',
        enemySquare: '#ffd700',
        enemyStar: '#39ff14',
        enemyHexagon: '#ff00ff',
        enemySpiral: '#ff5500',
        enemyDrone: '#aa00ff',
        coin: '#ffd700',
        projectile: '#ff3333'
    }
};

/**
 * MOTEUR DE JEU
 */
const Game = {
    canvas: document.getElementById('canvas'),
    ctx: null,
    width: 0,
    height: 0,
    player: null,
    enemies: [],
    projectiles: [],
    coins: [],
    particles: [],
    stars: [],
    level: 1,
    score: 0,
    lives: 3,
    keys: {},
    cameraX: 0,
    cameraY: 0,
    isRunning: false,
    spawnTimer: 0,
    enemyCount: 0,
    shotsFired: 0,
    fireCooldown: 0,
    isMobile: false,
    isPortrait: false,
    joystickActive: false,
    joystickX: 0,
    joystickY: 0,
    joystickOrigin: {x: 0, y: 0},
    joystickMaxRadius: CFG.JOYSTICK_RADIUS,
    joystickTouchId: null,
    bestScore: 0,
    gameOver: false,
    explosionParticles: [],

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.detectDevice();
        this.resize();
        
        // Charger le meilleur score
        this.loadBestScore();
        
        // √âv√©nements de redimensionnement
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('orientationchange', () => {
            setTimeout(() => this.resize(), 100);
        });
        
        // Gestion du plein √©cran
        this.setupFullscreen();
        
        // Input Listeners
        this.setupInput();
        this.setupMobileControls();
        this.generateStars();
        
        // Focus sur le triangle de d√©marrage
        document.getElementById('play-triangle-btn').focus();
        
        this.loop();
    },

    loadBestScore() {
        const savedScore = localStorage.getItem('neonDevilBestScore');
        this.bestScore = savedScore ? parseInt(savedScore) : 0;
        this.updateBestScoreDisplay();
    },

    saveBestScore() {
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('neonDevilBestScore', this.bestScore.toString());
        }
    },

    updateBestScoreDisplay() {
        document.getElementById('best-score').textContent = this.bestScore;
    },

    detectDevice() {
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isPortrait = window.innerHeight > window.innerWidth;
        
        // Ajuster les param√®tres selon l'appareil
        if (this.isMobile) {
            CFG.SPEED = 3;
            CFG.PLAYER_SIZE = 35;
            CFG.JOYSTICK_RADIUS = 50;
        }
    },

    setupFullscreen() {
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Erreur plein √©cran: ${err.message}`);
                });
                fullscreenBtn.innerHTML = 'üóï';
            } else {
                document.exitFullscreen();
                fullscreenBtn.innerHTML = '‚õ∂';
            }
        });

        // Mettre √† jour le bouton quand le mode plein √©cran change
        document.addEventListener('fullscreenchange', () => {
            fullscreenBtn.innerHTML = document.fullscreenElement ? 'üóï' : '‚õ∂';
        });
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        // Ajuster le canvas √† la taille de l'√©cran
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        this.isPortrait = this.height > this.width;
    },

    setupInput() {
        // Clavier
        window.addEventListener('keydown', e => {
            this.keys[e.code] = true;
            if (e.code === 'Space' && this.isRunning) {
                e.preventDefault();
                if (this.fireCooldown <= 0) {
                    this.player.fire();
                    this.fireCooldown = CFG.FIRE_RATE;
                }
            }
            if (e.code === 'Escape') {
                if (this.isRunning) {
                    this.togglePause();
                }
            }
            // Support pour TV (t√©l√©commandes)
            if (e.code === 'Enter' || e.code === 'NumpadEnter') {
                if (!this.isRunning && !document.getElementById('game-over-screen').classList.contains('hidden')) {
                    this.start();
                }
            }
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        
        // Support tactile pour ordinateurs avec √©cran tactile
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!this.isRunning) {
                this.start();
            }
        }, { passive: false });
    },

    setupMobileControls() {
        const joystickContainer = document.querySelector('.joystick-container');
        const fireBtn = document.getElementById('btn-fire');
        
        if (!joystickContainer) return;
        
        // Calculer la position du joystick
        const rect = joystickContainer.getBoundingClientRect();
        this.joystickOrigin.x = rect.left + rect.width / 2;
        this.joystickOrigin.y = rect.top + rect.height / 2;
        this.joystickMaxRadius = rect.width / 2 - 35;
        
        // √âv√©nements pour le joystick
        const handleJoystickStart = (clientX, clientY, touchId = null) => {
            this.joystickActive = true;
            if (touchId !== null) this.joystickTouchId = touchId;
            document.getElementById('joystick-thumb').classList.add('active');
            this.updateJoystickPosition(clientX, clientY);
        };
        
        const handleJoystickMove = (clientX, clientY) => {
            if (!this.joystickActive) return;
            this.updateJoystickPosition(clientX, clientY);
        };
        
        const handleJoystickEnd = (touchId = null) => {
            if (touchId !== null && this.joystickTouchId !== touchId) return;
            
            this.joystickActive = false;
            this.joystickX = 0;
            this.joystickY = 0;
            this.joystickTouchId = null;
            document.getElementById('joystick-thumb').classList.remove('active');
            document.getElementById('joystick-thumb').style.transform = 'translate(-50%, -50%)';
        };
        
        // Touch events avec gestion multi-touch
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleJoystickStart(touch.clientX, touch.clientY, touch.identifier);
        });
        
        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!this.joystickActive || !this.joystickTouchId) return;
            
            // Trouver le touch correspondant
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === this.joystickTouchId) {
                    handleJoystickMove(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        }, { passive: false });
        
        joystickContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        });
        
        joystickContainer.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            handleJoystickEnd(this.joystickTouchId);
        });
        
        // Mouse events (pour les √©crans tactiles de PC)
        joystickContainer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleJoystickStart(e.clientX, e.clientY);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!this.joystickActive) return;
            e.preventDefault();
            handleJoystickMove(e.clientX, e.clientY);
        });
        
        document.addEventListener('mouseup', (e) => {
            handleJoystickEnd();
        });
        
        // Bouton de tir
        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (this.isRunning && this.fireCooldown <= 0) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
            }
            fireBtn.classList.add('active');
        });
        
        fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            fireBtn.classList.remove('active');
        });
        
        fireBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            fireBtn.classList.remove('active');
        });
        
        fireBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (this.isRunning && this.fireCooldown <= 0) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
            }
            fireBtn.classList.add('active');
        });
        
        fireBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            fireBtn.classList.remove('active');
        });
        
        fireBtn.addEventListener('mouseleave', () => {
            fireBtn.classList.remove('active');
        });
    },

    updateJoystickPosition(clientX, clientY) {
        const joystickThumb = document.getElementById('joystick-thumb');
        const rect = document.querySelector('.joystick-container').getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Calculer la distance depuis le centre
        let deltaX = clientX - centerX;
        let deltaY = clientY - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Limiter strictement au rayon maximum
        if (distance > this.joystickMaxRadius) {
            deltaX = (deltaX / distance) * this.joystickMaxRadius;
            deltaY = (deltaY / distance) * this.joystickMaxRadius;
        }
        
        // Mettre √† jour la position du thumb
        joystickThumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        
        // Normaliser les valeurs entre -1 et 1
        this.joystickX = deltaX / this.joystickMaxRadius;
        this.joystickY = deltaY / this.joystickMaxRadius;
    },

    togglePause() {
        if (this.isRunning) {
            this.isRunning = false;
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('start-screen').innerHTML = `
                <div class="start-content">
                    <h1>PAUSE</h1>
                    <p>Score: ${this.score} | Level: ${this.level}</p>
                    <button class="play-triangle" onclick="Game.resume()" aria-label="Reprendre"></button>
                </div>
            `;
        }
    },

    resume() {
        this.isRunning = true;
        document.getElementById('start-screen').classList.add('hidden');
    },

    start() {
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.enemies = [];
        this.projectiles = [];
        this.coins = [];
        this.particles = [];
        this.explosionParticles = [];
        this.enemyCount = 0;
        this.shotsFired = 0;
        this.fireCooldown = 0;
        this.isRunning = true;
        this.gameOver = false;
        this.cameraX = 0;
        this.cameraY = 0;
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        this.player = new Player(this.width / 2, this.height / 2);
        this.spawnTimer = 0;
        this.updateHUD();
        
        // Mettre √† jour les c≈ìurs
        this.updateHearts();
        
        // Focus sur le canvas pour les contr√¥les clavier
        this.canvas.focus();
    },

    generateStars() {
        this.stars = [];
        const starCount = this.isMobile ? 100 : 200;
        for (let i = 0; i < starCount; i++) {
            this.stars.push({
                x: Math.random() * 4000 - 2000,
                y: Math.random() * 4000 - 2000,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 0.5 + 0.1,
                opacity: Math.random() * 0.5 + 0.3
            });
        }
    },

    canSpawnEnemyAt(x, y, size) {
        if (!this.player) return true;
        
        const playerX = this.player.x;
        const playerY = this.player.y;
        const playerDist = Math.sqrt(
            Math.pow(x - playerX, 2) + 
            Math.pow(y - playerY, 2)
        );
        if (playerDist < 150) return false;
        
        for (const enemy of this.enemies) {
            const dist = Math.sqrt(
                Math.pow(x - enemy.x, 2) + 
                Math.pow(y - enemy.y, 2)
            );
            const minDist = (size/2) + (enemy.size/2) + 10;
            if (dist < minDist) {
                return false;
            }
        }
        return true;
    },

    spawnEnemy() {
        const edge = Math.floor(Math.random() * 4);
        let baseX, baseY, vx, vy;
        
        const spawnMargin = Math.max(this.width, this.height) * 0.1;
        
        switch(edge) {
            case 0:
                baseX = Math.random() * this.width;
                baseY = -spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = Math.random() * 1 + 0.5;
                break;
            case 1:
                baseX = this.width + spawnMargin;
                baseY = Math.random() * this.height;
                vx = -Math.random() * 1 - 0.5;
                vy = (Math.random() - 0.5) * 2;
                break;
            case 2:
                baseX = Math.random() * this.width;
                baseY = this.height + spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = -Math.random() * 1 - 0.5;
                break;
            case 3:
                baseX = -spawnMargin;
                baseY = Math.random() * this.height;
                vx = Math.random() * 1 + 0.5;
                vy = (Math.random() - 0.5) * 2;
                break;
        }
        
        const enemyTypes = ['circle', 'triangle', 'square', 'star', 'hexagon', 'spiral', 'drone'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const size = 25 + Math.random() * 15;
        const x = baseX + this.cameraX;
        const y = baseY + this.cameraY;
        
        if (this.canSpawnEnemyAt(x, y, size)) {
            this.enemies.push(new Enemy(x, y, vx, vy, type, size));
            this.enemyCount++;
            return true;
        }
        return false;
    },

    spawnCoin(x, y) {
        this.coins.push(new Coin(x + this.cameraX, y + this.cameraY));
    },

    updateHUD() {
        document.getElementById('score-display').textContent = this.score;
    },

    updateHearts() {
        for (let i = 1; i <= 3; i++) {
            const heart = document.getElementById(`heart-${i}`);
            if (i <= this.lives) {
                heart.classList.remove('lost');
            } else {
                heart.classList.add('lost');
            }
        }
    },

    createShipExplosion(x, y) {
        for (let i = 0; i < 50; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            const size = 3 + Math.random() * 4;
            const life = 1.0;
            
            this.explosionParticles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: size,
                life: life,
                color: CFG.COLORS.player,
                decay: 0.02 + Math.random() * 0.02
            });
        }
        
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            const size = 2 + Math.random() * 3;
            const life = 1.0;
            
            this.explosionParticles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: size,
                life: life,
                color: '#ff5500',
                decay: 0.015 + Math.random() * 0.015
            });
        }
    },

    die() {
        if (this.gameOver) return;
        
        this.lives--;
        this.updateHearts();
        
        if (this.lives > 0) {
            // Explosion normale - pas de retour au centre
            this.spawnExplosion(this.player.x, this.player.y, CFG.COLORS.enemyCircle);
        } else {
            // Game Over - explosion massive
            this.gameOver = true;
            this.isRunning = false;
            
            this.createShipExplosion(this.player.x, this.player.y);
            
            this.saveBestScore();
            
            setTimeout(() => {
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('best-score').textContent = this.bestScore;
                document.getElementById('final-level').textContent = this.level;
                document.getElementById('final-shots').textContent = this.shotsFired;
                
                setTimeout(() => document.getElementById('restart-btn').focus(), 100);
            }, 1500);
        }
    },

    spawnExplosion(x, y, color) {
        for(let i=0; i<15; i++) this.particles.push(new Particle(x, y, color));
    },

    findNearestEnemy() {
        let nearest = null;
        let nearestDist = Infinity;
        
        for (const enemy of this.enemies) {
            const dx = enemy.x - this.player.x;
            const dy = enemy.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist) {
                nearestDist = dist;
                nearest = enemy;
            }
        }
        
        return nearest;
    },

    loop() {
        if (this.isPortrait && this.isMobile) {
            requestAnimationFrame(() => this.loop());
            return;
        }
        
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        if(this.isRunning) {
            this.update();
            this.draw();
        } else if (this.gameOver) {
            this.updateExplosionParticles();
            this.draw();
        } else {
            this.drawBackground();
        }
        
        requestAnimationFrame(() => this.loop());
    },

    update() {
        if (!this.player || !this.isRunning) return;
        
        if (this.fireCooldown > 0) {
            this.fireCooldown--;
        }
        
        if ((this.keys['Space'] || this.keys['ShiftLeft']) && this.fireCooldown <= 0) {
            this.player.fire();
            this.fireCooldown = CFG.FIRE_RATE;
        }
        
        this.spawnTimer++;
        const spawnRate = Math.max(15, 60 - this.level * 3);
        if(this.spawnTimer >= spawnRate) {
            this.spawnEnemy();
            this.spawnTimer = 0;
            
            if(Math.random() < 0.3) {
                this.spawnCoin(
                    Math.random() * this.width - this.width / 2,
                    Math.random() * this.height - this.height / 2
                );
            }
        }
        
        this.player.update();
        
        let targetCamX = this.player.x - this.width / 2;
        let targetCamY = this.player.y - this.height / 2;
        this.cameraX += (targetCamX - this.cameraX) * 0.05;
        this.cameraY += (targetCamY - this.cameraY) * 0.05;
        
        this.enemies.forEach(en => {
            en.update();
            if(this.circleIntersect(this.player, en)) {
                this.die();
                en.markForRemoval = true;
            }
        });
        
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.update();
            
            for (let j = this.enemies.length - 1; j >= 0; j--) {
                const enemy = this.enemies[j];
                if (this.circleIntersect(proj, enemy)) {
                    this.score += 100;
                    this.spawnExplosion(enemy.x, enemy.y, enemy.color);
                    enemy.markForRemoval = true;
                    this.projectiles.splice(i, 1);
                    this.enemyCount--;
                    this.updateHUD();
                    break;
                }
            }
            
            const distX = Math.abs(proj.x - this.player.x);
            const distY = Math.abs(proj.y - this.player.y);
            if (distX > this.width * 1.5 || distY > this.height * 1.5 || proj.life <= 0) {
                this.projectiles.splice(i, 1);
            }
        }
        
        this.enemies = this.enemies.filter(en => !en.markForRemoval);
        
        this.coins = this.coins.filter(c => {
            if(this.circleIntersect(this.player, c)) {
                this.score += 100;
                this.spawnExplosion(c.x, c.y, CFG.COLORS.coin);
                this.updateHUD();
                return false;
            }
            return true;
        });
        
        this.particles = this.particles.filter(p => p.update());
        
        if(this.score >= this.level * 1000) {
            this.level++;
        }
    },

    updateExplosionParticles() {
        for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
            const p = this.explosionParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= p.decay;
            
            if (p.life <= 0) {
                this.explosionParticles.splice(i, 1);
            }
        }
    },

    circleIntersect(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius1 = obj1.size ? obj1.size/2 : (obj1.radius || 0);
        const radius2 = obj2.size ? obj2.size/2 : (obj2.radius || 0);
        return distance < radius1 + radius2;
    },

    drawBackground() {
        this.ctx.fillStyle = '#050510';
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        this.stars.forEach(star => {
            this.ctx.globalAlpha = star.opacity;
            const x = star.x - this.cameraX * star.speed * 0.1;
            const y = star.y - this.cameraY * star.speed * 0.1;
            
            if (x > -100 && x < this.width + 100 && y > -100 && y < this.height + 100) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
        this.ctx.globalAlpha = 1;
    },

    draw() {
        this.drawBackground();
        
        this.ctx.save();
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        this.drawGrid();
        
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.1)';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(
            this.cameraX - 100, 
            this.cameraY - 100, 
            this.width + 200, 
            this.height + 200
        );
        
        this.coins.forEach(c => c.draw(this.ctx));
        this.projectiles.forEach(p => p.draw(this.ctx));
        this.enemies.forEach(en => en.draw(this.ctx));
        this.particles.forEach(p => p.draw(this.ctx));
        
        this.explosionParticles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.shadowBlur = p.life * 10;
            this.ctx.shadowColor = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1;
            this.ctx.shadowBlur = 0;
        });
        
        if (!this.gameOver && this.player) {
            this.player.draw(this.ctx);
        }
        
        this.ctx.restore();
    },

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.03)';
        this.ctx.lineWidth = 1;
        let step = 100;
        let startX = Math.floor(this.cameraX / step) * step - step;
        let startY = Math.floor(this.cameraY / step) * step - step;
        
        for(let x = startX; x < startX + this.width + step * 3; x += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);
            this.ctx.lineTo(x, startY + this.height + step * 3);
            this.ctx.stroke();
        }
        
        for(let y = startY; y < startY + this.height + step * 3; y += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(startX, y);
            this.ctx.lineTo(startX + this.width + step * 3, y);
            this.ctx.stroke();
        }
    }
};

/**
 * CLASSES DES OBJETS
 */
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.size = Game.isMobile ? CFG.PLAYER_SIZE * 0.8 : CFG.PLAYER_SIZE;
        this.angle = 0;
        this.engineParticles = 0;
        this.wingFlap = 0;
        this.autoRotateSpeed = 0.1;
    }

    fire() {
        Game.shotsFired++;
        const proj = new Projectile(
            this.x + Math.cos(this.angle) * this.size/2,
            this.y + Math.sin(this.angle) * this.size/2,
            Math.cos(this.angle) * CFG.PROJECTILE_SPEED,
            Math.sin(this.angle) * CFG.PROJECTILE_SPEED,
            this.angle
        );
        Game.projectiles.push(proj);
        Game.updateHUD();
        
        this.vx -= Math.cos(this.angle) * 1.5;
        this.vy -= Math.sin(this.angle) * 1.5;
    }

    update() {
        // Contr√¥les clavier
        if(Game.keys['ArrowLeft'] || Game.keys['KeyA']) this.vx -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowRight'] || Game.keys['KeyD']) this.vx += CFG.SPEED * 0.2;
        if(Game.keys['ArrowUp'] || Game.keys['KeyW']) this.vy -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowDown'] || Game.keys['KeyS']) this.vy += CFG.SPEED * 0.2;
        
        // Contr√¥les joystick
        if (Game.joystickActive) {
            this.vx += Game.joystickX * CFG.SPEED * 0.3;
            this.vy += Game.joystickY * CFG.SPEED * 0.3;
        }
        
        this.wingFlap += 0.2;
        
        const nearestEnemy = Game.findNearestEnemy();
        if (nearestEnemy) {
            const dx = nearestEnemy.x - this.x;
            const dy = nearestEnemy.y - this.y;
            const targetAngle = Math.atan2(dy, dx);
            
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            this.angle += angleDiff * this.autoRotateSpeed;
        }
        
        const centerX = Game.width / 2 + Game.cameraX;
        const centerY = Game.height / 2 + Game.cameraY;
        const cdx = centerX - this.x;
        const cdy = centerY - this.y;
        const distance = Math.sqrt(cdx * cdx + cdy * cdy);
        
        if(distance > 300) {
            this.vx += cdx * 0.001;
            this.vy += cdy * 0.001;
        }
        
        this.vx *= CFG.FRICTION;
        this.vy *= CFG.FRICTION;
        
        this.x += this.vx;
        this.y += this.vy;
        
        this.engineParticles++;
        if(this.engineParticles > 5 && (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1)) {
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            for(let i = 0; i < 2; i++) {
                const angle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                const power = Math.random() * speed * 0.5;
                Game.particles.push(new Particle(
                    this.x - Math.cos(this.angle) * this.size/2,
                    this.y - Math.sin(this.angle) * this.size/2,
                    CFG.COLORS.player,
                    Math.cos(angle) * power,
                    Math.sin(angle) * power
                ));
            }
            this.engineParticles = 0;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        const wingOffset = Math.sin(this.wingFlap) * 3;
        
        ctx.shadowBlur = 30;
        ctx.shadowColor = CFG.COLORS.player;
        
        ctx.fillStyle = CFG.COLORS.player;
        ctx.beginPath();
        
        ctx.moveTo(this.size/2, 0);
        ctx.lineTo(0, -this.size/3);
        ctx.lineTo(-this.size/3, -this.size/4);
        ctx.lineTo(-this.size/2, -this.size/6);
        ctx.lineTo(-this.size/2, -this.size/2 + wingOffset);
        ctx.lineTo(-this.size/4, -this.size/3);
        ctx.lineTo(-this.size/2, 0);
        ctx.lineTo(-this.size/4, this.size/3);
        ctx.lineTo(-this.size/2, this.size/2 - wingOffset);
        ctx.lineTo(-this.size/2, this.size/6);
        ctx.lineTo(-this.size/3, this.size/4);
        ctx.lineTo(0, this.size/3);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'rgba(0, 100, 255, 0.7)';
        ctx.beginPath();
        ctx.moveTo(this.size/3, 0);
        ctx.lineTo(-this.size/6, -this.size/4);
        ctx.lineTo(-this.size/3, 0);
        ctx.lineTo(-this.size/6, this.size/4);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.beginPath();
        ctx.arc(this.size/6, 0, this.size/4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(this.size/6, 0, this.size/5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ff5500';
        ctx.fillRect(-this.size/2, -this.size/8, this.size/10, this.size/4);
        ctx.fillRect(-this.size/2 + this.size/6, -this.size/8, this.size/10, this.size/4);
        
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.size/2 - 8, -4, 12, 8);
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, vx, vy, angle) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = Game.isMobile ? 4 : 5;
        this.life = 100;
        this.angle = angle;
        this.trail = [];
    }
    
    update() {
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 5) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        if (Math.random() < 0.7) {
            Game.particles.push(new Particle(
                this.x,
                this.y,
                CFG.COLORS.projectile,
                -this.vx * 0.1 + (Math.random() - 0.5) * 0.3,
                -this.vy * 0.1 + (Math.random() - 0.5) * 0.3
            ));
        }
        
        return this.life > 0;
    }
    
    draw(ctx) {
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = i / this.trail.length * 0.5;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.fillStyle = `rgba(255, 100, 50, ${alpha})`;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * (i/this.trail.length), 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = CFG.COLORS.projectile;
        
        const gradient = ctx.createLinearGradient(0, -this.radius, 0, this.radius);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.5, CFG.COLORS.projectile);
        gradient.addColorStop(1, '#ff9900');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, -this.radius);
        ctx.lineTo(this.radius * 3, 0);
        ctx.lineTo(0, this.radius);
        ctx.lineTo(-this.radius, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(this.radius, 0, this.radius/2, this.radius, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, vx, vy, type, size) {
        this.x = x;
        this.y = y;
        this.vx = vx * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.05);
        this.vy = vy * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.05);
        this.type = type;
        this.size = Game.isMobile ? size * 0.8 : size;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.05;
        this.markForRemoval = false;
        this.pulse = 0;
        this.animationTime = 0;
        this.frame = 0;
        this.color = CFG.COLORS[`enemy${type.charAt(0).toUpperCase() + type.slice(1)}`] || CFG.COLORS.enemyCircle;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.pulse += 0.05;
        this.animationTime += 0.1;
        this.frame = Math.floor(this.animationTime) % 4;
        
        const dx = Game.player.x - this.x;
        const dy = Game.player.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if(distance < 500) {
            this.vx += dx * 0.0002 * Game.level;
            this.vy += dy * 0.0002 * Game.level;
        }
        
        Game.enemies.forEach(other => {
            if (other !== this) {
                const odx = other.x - this.x;
                const ody = other.y - this.y;
                const odist = Math.sqrt(odx * odx + ody * ody);
                const minDist = (this.size/2) + (other.size/2) + 5;
                
                if (odist < minDist && odist > 0) {
                    const force = 0.05;
                    this.vx -= (odx / odist) * force;
                    this.vy -= (ody / odist) * force;
                }
            }
        });
        
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        const maxSpeed = 3 + Game.level * 0.1;
        if(speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        const pulseSize = 1 + Math.sin(this.pulse) * 0.1;
        ctx.scale(pulseSize, pulseSize);
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        
        switch(this.type) {
            case 'circle':
                for(let i = 0; i < 6; i++) {
                    const segmentAngle = (i / 6) * Math.PI * 2 + this.rotation * 2;
                    ctx.save();
                    ctx.rotate(segmentAngle);
                    
                    const segmentPulse = Math.sin(this.animationTime + i) * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)}, ${parseInt(this.color.slice(3,5),16)}, ${parseInt(this.color.slice(5,7),16)}, ${0.3 + segmentPulse * 0.4})`;
                    
                    ctx.beginPath();
                    ctx.arc(0, this.size/3, this.size/6 * (0.5 + segmentPulse * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#222';
                const mouthOpen = Math.sin(this.animationTime * 3) * 0.3 + 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, this.size/4, 0, Math.PI * mouthOpen);
                ctx.fill();
                break;
                
            case 'triangle':
                const trianglePulse = Math.sin(this.animationTime * 2) * 0.2;
                
                ctx.beginPath();
                ctx.moveTo(0, -this.size/2 * (1 + trianglePulse));
                ctx.lineTo(this.size/2, this.size/2 * (1 - trianglePulse/2));
                ctx.lineTo(-this.size/2, this.size/2 * (1 - trianglePulse/2));
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                const blink = Math.sin(this.animationTime * 4) > 0 ? 1 : 0;
                ctx.fillStyle = 'white';
                if(blink) {
                    ctx.beginPath();
                    ctx.arc(-this.size/4, -this.size/8, this.size/10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(this.size/4, -this.size/8, this.size/10, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 'square':
                const squareWobble = Math.sin(this.animationTime * 3) * 0.2;
                
                ctx.save();
                ctx.scale(1 + squareWobble, 1 - squareWobble);
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                const patternSize = this.size/3 * (0.8 + Math.sin(this.animationTime * 2) * 0.2);
                ctx.fillRect(-patternSize/2, -patternSize/2, patternSize, patternSize);
                break;
                
            case 'star':
                const spikes = 5;
                const outerRadius = this.size/2;
                const innerRadius = this.size/4;
                const starPulse = Math.sin(this.animationTime * 2) * 0.3 + 0.7;
                
                ctx.beginPath();
                for(let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius * starPulse : innerRadius;
                    const angle = (Math.PI * i) / spikes + this.animationTime;
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = 'white';
                ctx.save();
                ctx.rotate(this.animationTime * 2);
                ctx.beginPath();
                ctx.arc(0, 0, this.size/6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;
                
            case 'hexagon':
                ctx.beginPath();
                for(let i = 0; i < 6; i++) {
                    const angle = (Math.PI * i) / 3 + Math.sin(this.animationTime + i) * 0.2;
                    const radius = this.size/2 * (1 + Math.cos(this.animationTime * 2 + i) * 0.1);
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                for(let i = 0; i < 6; i++) {
                    const angle = (Math.PI * i) / 3;
                    const radius = this.size/4;
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
                ctx.closePath();
                ctx.fill();
                break;
                
            case 'spiral':
                ctx.beginPath();
                for(let i = 0; i < 20; i++) {
                    const angle = i * 0.3 + this.animationTime * 2;
                    const radius = (i / 20) * (this.size/2);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size/4, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'drone':
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/3, -this.size/3, this.size * 0.66, this.size * 0.66);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                const rotorAngle = this.animationTime * 5;
                
                ctx.save();
                ctx.translate(-this.size/2, 0);
                ctx.rotate(rotorAngle);
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size);
                ctx.restore();
                
                ctx.save();
                ctx.translate(this.size/2, 0);
                ctx.rotate(rotorAngle);
                ctx.fillRect(-this.size/8, -this-size/2, this.size/4, this.size);
                ctx.restore();
                
                ctx.save();
                ctx.translate(0, -this.size/2);
                ctx.rotate(rotorAngle + Math.PI/2);
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size);
                ctx.restore();
                
                ctx.save();
                ctx.translate(0, this.size/2);
                ctx.rotate(rotorAngle + Math.PI/2);
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size);
                ctx.restore();
                break;
        }
        
        ctx.restore();
    }
}

class Coin {
    constructor(x, y) { 
        this.x = x; 
        this.y = y; 
        this.size = Game.isMobile ? 12 : 15; 
        this.bob = 0; 
        this.rotation = 0;
    }
    
    draw(ctx) {
        this.bob += 0.05;
        this.rotation += 0.02;
        
        ctx.save();
        ctx.translate(this.x, this.y + Math.sin(this.bob) * 5);
        ctx.rotate(this.rotation);
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = CFG.COLORS.coin;
        
        ctx.fillStyle = CFG.COLORS.coin;
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(0, 0, this.size * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-this.size * 0.2, -this.size * 0.05, this.size * 0.4, this.size * 0.1);
        
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, vx = 0, vy = 0) {
        this.x = x; this.y = y;
        this.vx = vx || (Math.random() - 0.5) * 4;
        this.vy = vy || (Math.random() - 0.5) * 4;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * (Game.isMobile ? 2 : 3) + 1;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.02;
        return this.life > 0;
    }
    
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// Lancement
window.addEventListener('DOMContentLoaded', () => {
    Game.init();
});

// Pr√©venir le zoom tactile
document.addEventListener('gesturestart', (e) => e.preventDefault());
document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1) e.preventDefault();
}, { passive: false });

// Support PWA (Progressive Web App)
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(error => {
            console.log('ServiceWorker registration failed:', error);
        });
    });
}
</script>
</body>
</html>