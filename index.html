<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Devil - Mission Edition</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff007a;
            --neon-purple: #bc13fe;
            --neon-green: #39ff14;
            --neon-yellow: #ffd700;
            --neon-red: #ff3333;
            --neon-orange: #ff5500;
            --bg-dark: #050505;
            --bg-darker: #01010a;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
        }

        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: var(--bg-darker);
            font-family: 'Orbitron', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg-darker);
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Orientation warning */
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 200;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(20px);
        }

        .orientation-warning h2 {
            color: var(--neon-pink);
            margin-bottom: 20px;
            font-size: clamp(1.5rem, 5vw, 2rem);
        }

        .orientation-warning p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 4vw, 1.2rem);
        }

        /* UI Styles am√©lior√©s */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.95), rgba(5, 0, 20, 0.98));
            backdrop-filter: blur(15px);
            z-index: 100;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 20px;
            padding-top: calc(20px + var(--safe-area-top));
            padding-bottom: calc(20px + var(--safe-area-bottom));
        }

        /* HUD am√©lior√© avec LVL en haut */
        .hud {
            position: fixed;
            top: max(10px, var(--safe-area-top));
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 clamp(10px, 3vw, 20px);
            gap: 10px;
        }

        .score-display {
            font-family: 'Orbitron', monospace;
            font-size: clamp(18px, 5vw, 28px);
            font-weight: 900;
            color: var(--neon-blue);
            text-shadow: 
                0 0 10px var(--neon-blue),
                0 0 20px var(--neon-blue),
                0 0 30px rgba(0, 242, 255, 0.5);
            background: linear-gradient(to right, rgba(0, 0, 0, 0.7), rgba(0, 20, 40, 0.7));
            padding: clamp(6px, 1.5vw, 10px) clamp(12px, 2.5vw, 20px);
            border-radius: 12px;
            border: 2px solid var(--neon-blue);
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 15px rgba(0, 242, 255, 0.3),
                inset 0 0 15px rgba(0, 242, 255, 0.1);
            letter-spacing: 1px;
            animation: pulse 2s infinite;
            flex-shrink: 1;
            min-width: 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .lives-container {
            display: flex;
            gap: clamp(6px, 1.5vw, 12px);
            background: linear-gradient(to right, rgba(0, 20, 40, 0.7), rgba(0, 0, 0, 0.7));
            padding: clamp(6px, 1.5vw, 10px) clamp(12px, 2.5vw, 20px);
            border-radius: 12px;
            border: 2px solid var(--neon-blue);
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 15px rgba(0, 242, 255, 0.3),
                inset 0 0 15px rgba(0, 242, 255, 0.1);
            flex-shrink: 0;
        }

        .heart {
            width: clamp(20px, 5vw, 32px);
            height: clamp(20px, 5vw, 32px);
            position: relative;
            transition: transform 0.3s, filter 0.3s;
        }

        .heart svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 6px var(--neon-blue));
            transition: all 0.3s;
        }

        .heart.lost svg {
            fill: #222;
            filter: none;
        }

        .heart.pulse svg {
            animation: heartPulse 0.5s ease-in-out;
        }

        @keyframes heartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* LVL Display en haut */
        .lvl-display {
            position: fixed;
            top: max(10px, var(--safe-area-top));
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(to right, 
                rgba(188, 19, 254, 0.3), 
                rgba(0, 242, 255, 0.3));
            padding: clamp(6px, 1.5vw, 8px) clamp(12px, 2.5vw, 20px);
            border-radius: 12px;
            border: 2px solid var(--neon-purple);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 15px rgba(188, 19, 254, 0.3);
            pointer-events: none;
            z-index: 40;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 8px var(--neon-purple);
            font-size: clamp(16px, 4vw, 22px);
        }

        /* Combo display */
        .combo-display {
            position: fixed;
            top: 50%;
            right: clamp(8px, 2vw, 15px);
            transform: translateY(-50%);
            font-family: 'Orbitron', monospace;
            font-size: clamp(14px, 4vw, 20px);
            font-weight: bold;
            color: var(--neon-orange);
            text-shadow: 
                0 0 8px var(--neon-orange),
                0 0 15px rgba(255, 85, 0, 0.5);
            background: rgba(0, 0, 0, 0.5);
            padding: clamp(6px, 1.5vw, 8px) clamp(10px, 2.5vw, 15px);
            border-radius: 12px;
            border: 2px solid var(--neon-orange);
            backdrop-filter: blur(10px);
            pointer-events: none;
            z-index: 40;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-display.active {
            opacity: 1;
            animation: comboPulse 0.5s ease-in-out;
        }

        @keyframes comboPulse {
            0%, 100% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.1); }
        }

        /* Boutons style mission */
        .mission-btn {
            position: relative;
            width: clamp(80px, 22vw, 130px);
            height: clamp(80px, 22vw, 130px);
            background: linear-gradient(135deg, var(--neon-green), var(--neon-blue));
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            margin: clamp(15px, 4vw, 30px);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 25px var(--neon-green),
                0 0 50px rgba(57, 255, 20, 0.3),
                inset 0 0 15px rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            animation: playBtnGlow 2s infinite alternate;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(16px, 4vw, 24px);
            text-transform: uppercase;
            letter-spacing: 2px;
            touch-action: manipulation;
        }

        @keyframes playBtnGlow {
            0% { box-shadow: 0 0 25px var(--neon-green), 0 0 50px rgba(57, 255, 20, 0.3); }
            100% { box-shadow: 0 0 35px var(--neon-blue), 0 0 70px rgba(0, 242, 255, 0.4); }
        }

        .mission-btn:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 
                0 0 35px var(--neon-blue),
                0 0 70px rgba(0, 242, 255, 0.5);
        }

        .mission-btn:active {
            transform: scale(0.95);
        }

        .go-btn {
            position: relative;
            width: clamp(100px, 28vw, 160px);
            height: clamp(100px, 28vw, 160px);
            background: linear-gradient(135deg, var(--neon-red), var(--neon-orange));
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            margin: clamp(15px, 4vw, 30px);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 35px var(--neon-red),
                0 0 70px rgba(255, 51, 51, 0.4),
                inset 0 0 15px rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            animation: goBtnGlow 1.5s infinite alternate;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(20px, 5vw, 32px);
            text-transform: uppercase;
            letter-spacing: 3px;
            touch-action: manipulation;
        }

        @keyframes goBtnGlow {
            0% { box-shadow: 0 0 35px var(--neon-red), 0 0 70px rgba(255, 51, 51, 0.4); }
            100% { box-shadow: 0 0 45px var(--neon-orange), 0 0 90px rgba(255, 85, 0, 0.5); }
        }

        .next-btn {
            position: relative;
            width: clamp(70px, 18vw, 110px);
            height: clamp(70px, 18vw, 110px);
            background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            margin: clamp(12px, 3vw, 25px);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 
                0 0 25px var(--neon-blue),
                0 0 50px rgba(0, 242, 255, 0.3),
                inset 0 0 15px rgba(255, 255, 255, 0.2);
            border: 3px solid white;
            animation: nextBtnGlow 2s infinite alternate;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: clamp(14px, 3vw, 20px);
            text-transform: uppercase;
            letter-spacing: 2px;
            touch-action: manipulation;
        }

        @keyframes nextBtnGlow {
            0% { box-shadow: 0 0 25px var(--neon-blue), 0 0 50px rgba(0, 242, 255, 0.3); }
            100% { box-shadow: 0 0 35px var(--neon-purple), 0 0 70px rgba(188, 19, 254, 0.4); }
        }

        /* Contr√¥les mobiles am√©lior√©s - RESPONSIVE */
        #mobile-controls {
            position: fixed;
            bottom: max(20px, var(--safe-area-bottom));
            width: 100vw;
            display: flex;
            justify-content: space-between;
            padding: 0 clamp(15px, 4vw, 30px);
            z-index: 60;
            gap: clamp(15px, 4vw, 30px);
            pointer-events: none;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            align-items: flex-end;
        }

        .joystick-container {
            position: relative;
            width: clamp(120px, 28vw, 200px);
            height: clamp(120px, 28vw, 200px);
            touch-action: none;
        }

        .joystick-boundary {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                rgba(0, 242, 255, 0.1), 
                rgba(0, 100, 200, 0.05));
            border: 3px solid var(--neon-blue);
            border-radius: 50%;
            box-shadow: 
                0 0 25px rgba(0, 242, 255, 0.4),
                inset 0 0 25px rgba(0, 242, 255, 0.2);
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(50px, 12vw, 90px);
            height: clamp(50px, 12vw, 90px);
            background: radial-gradient(circle at 30% 30%, 
                var(--neon-blue), 
                #0080ff);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 
                0 0 25px rgba(0, 242, 255, 0.9),
                inset 0 0 12px rgba(255, 255, 255, 0.8);
            transition: all 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
            z-index: 2;
            will-change: transform, box-shadow;
        }

        .joystick-thumb.active {
            box-shadow: 
                0 0 35px rgba(0, 242, 255, 1),
                inset 0 0 15px rgba(255, 255, 255, 1);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .action-btn {
            width: clamp(100px, 22vw, 140px);
            height: clamp(100px, 22vw, 140px);
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 0, 122, 0.8), 
                rgba(188, 19, 254, 0.6));
            border: 3px solid var(--neon-pink);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 
                0 0 25px rgba(255, 0, 122, 0.6),
                0 0 50px rgba(255, 0, 122, 0.3),
                inset 0 0 15px rgba(255, 255, 255, 0.3);
            transition: all 0.1s;
            margin-bottom: clamp(15px, 4vw, 30px);
            position: relative;
            cursor: pointer;
            animation: fireBtnGlow 2s infinite alternate;
            touch-action: manipulation;
        }

        @keyframes fireBtnGlow {
            0% { box-shadow: 0 0 25px rgba(255, 0, 122, 0.6), 0 0 50px rgba(255, 0, 122, 0.3); }
            100% { box-shadow: 0 0 35px rgba(188, 19, 254, 0.7), 0 0 70px rgba(188, 19, 254, 0.4); }
        }

        .action-btn.active {
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 0, 122, 1), 
                rgba(188, 19, 254, 0.8));
            transform: scale(0.95);
            box-shadow: 
                0 0 35px rgba(255, 0, 122, 0.9),
                0 0 70px rgba(255, 0, 122, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.4);
        }

        .target-icon {
            width: 60%;
            height: 60%;
            position: relative;
            animation: targetRotate 4s linear infinite;
        }

        @keyframes targetRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Style pour l'√©cran de d√©marrage am√©lior√© */
        .start-content {
            text-align: center;
            max-width: min(800px, 90vw);
            padding: clamp(15px, 4vw, 30px);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8), 
                rgba(5, 0, 20, 0.9));
            border-radius: 25px;
            border: 3px solid var(--neon-blue);
            box-shadow: 
                0 0 40px rgba(0, 242, 255, 0.3),
                inset 0 0 25px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(20px);
        }
        
        .start-content h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.8rem, 7vw, 4rem);
            background: linear-gradient(to right, var(--neon-pink), var(--neon-blue), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 25px rgba(255, 0, 122, 0.5);
            margin-bottom: clamp(12px, 3vw, 18px);
            line-height: 1.2;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: titleGlow 3s infinite alternate;
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 0 25px rgba(255, 0, 122, 0.5); }
            50% { text-shadow: 0 0 35px rgba(0, 242, 255, 0.6); }
            100% { text-shadow: 0 0 25px rgba(188, 19, 254, 0.5); }
        }
        
        .start-content p {
            color: var(--neon-blue);
            font-size: clamp(0.9rem, 2.5vw, 1.3rem);
            margin-bottom: clamp(20px, 4vw, 30px);
            line-height: 1.6;
            text-shadow: 0 0 8px rgba(0, 242, 255, 0.5);
        }

        /* Styles pour les √©crans de tutoriel */
        .tutorial-screen {
            text-align: center;
            max-width: min(800px, 90vw);
            padding: clamp(15px, 4vw, 30px);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8), 
                rgba(5, 0, 20, 0.9));
            border-radius: 25px;
            border: 3px solid var(--neon-blue);
            box-shadow: 
                0 0 40px rgba(0, 242, 255, 0.3),
                inset 0 0 25px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(20px);
        }

        .tutorial-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.6rem, 5vw, 3rem);
            color: var(--neon-blue);
            margin-bottom: clamp(15px, 3vw, 25px);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 12px var(--neon-blue);
        }

        .tutorial-subtitle {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.1rem, 3.5vw, 2rem);
            color: var(--neon-green);
            margin-bottom: clamp(12px, 2.5vw, 18px);
            text-shadow: 0 0 8px var(--neon-green);
        }

        .tutorial-text {
            color: white;
            font-size: clamp(0.85rem, 2.2vw, 1.1rem);
            margin-bottom: clamp(15px, 3vw, 25px);
            line-height: 1.6;
            text-align: left;
            padding: 0 clamp(8px, 2.5vw, 15px);
        }

        .tutorial-controls {
            display: flex;
            justify-content: center;
            gap: clamp(15px, 3vw, 30px);
            margin: clamp(15px, 3vw, 25px) 0;
            flex-wrap: wrap;
        }

        .tutorial-control-demo {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(8px, 2vw, 12px);
            padding: clamp(12px, 2.5vw, 15px);
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid var(--neon-blue);
            min-width: min(180px, 90%);
        }

        .control-label {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(0.9rem, 2.2vw, 1.1rem);
            color: var(--neon-green);
            font-weight: bold;
        }

        .control-description {
            color: #ddd;
            font-size: clamp(0.75rem, 1.8vw, 0.9rem);
            text-align: center;
            max-width: min(220px, 90%);
        }

        .lives-explanation {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(12px, 2.5vw, 18px);
            margin: clamp(15px, 3vw, 25px) 0;
            padding: clamp(12px, 2.5vw, 15px);
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid var(--neon-blue);
        }

        .life-icon {
            width: clamp(30px, 7vw, 45px);
            height: clamp(30px, 7vw, 45px);
        }

        .life-icon svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 6px var(--neon-blue));
        }

        .life-text {
            color: white;
            font-size: clamp(0.85rem, 2.2vw, 1rem);
            text-align: center;
            max-width: min(450px, 90%);
        }

        /* √âcran Mission Failed am√©lior√© */
        .mission-failed {
            text-align: center;
            max-width: min(600px, 90vw);
            padding: clamp(20px, 4vw, 30px);
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.9), 
                rgba(40, 0, 0, 0.9));
            border-radius: 25px;
            border: 3px solid var(--neon-red);
            box-shadow: 
                0 0 50px rgba(255, 51, 51, 0.4),
                inset 0 0 25px rgba(255, 51, 51, 0.2);
            backdrop-filter: blur(20px);
        }

        .mission-failed h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.8rem, 7vw, 3.5rem);
            color: var(--neon-red);
            text-shadow: 
                0 0 15px var(--neon-red),
                0 0 30px rgba(255, 51, 51, 0.7);
            margin-bottom: clamp(15px, 3vw, 25px);
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: failedGlow 2s infinite alternate;
        }

        @keyframes failedGlow {
            0% { text-shadow: 0 0 15px var(--neon-red), 0 0 30px rgba(255, 51, 51, 0.7); }
            100% { text-shadow: 0 0 25px var(--neon-red), 0 0 50px rgba(255, 51, 51, 0.9); }
        }

        .score-results {
            background: linear-gradient(to right, 
                rgba(255, 51, 51, 0.1), 
                rgba(255, 0, 122, 0.1));
            border-radius: 15px;
            padding: clamp(15px, 3vw, 25px);
            margin: clamp(15px, 3vw, 25px) 0;
            border: 2px solid rgba(255, 51, 51, 0.3);
            box-shadow: 
                0 0 25px rgba(255, 51, 51, 0.2),
                inset 0 0 15px rgba(255, 51, 51, 0.1);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: clamp(12px, 2.5vw, 15px) 0;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            padding: clamp(6px, 1.5vw, 8px) 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .score-item:last-child {
            border-bottom: none;
        }

        .score-label {
            color: #ddd;
            font-weight: bold;
        }

        .score-value {
            color: var(--neon-yellow);
            font-weight: bold;
            font-size: clamp(1rem, 2.8vw, 1.3rem);
            text-shadow: 0 0 8px var(--neon-yellow);
        }

        .highscore-value {
            color: var(--neon-green);
            font-weight: bold;
            font-size: clamp(1.1rem, 3vw, 1.5rem);
            text-shadow: 
                0 0 12px var(--neon-green),
                0 0 25px rgba(57, 255, 20, 0.5);
            animation: highscorePulse 2s infinite alternate;
        }

        @keyframes highscorePulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.03); }
        }

        /* Mode pause */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, 
                rgba(0, 0, 0, 0.85), 
                rgba(0, 20, 40, 0.9));
            backdrop-filter: blur(15px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 90;
            flex-direction: column;
            gap: clamp(15px, 3vw, 25px);
        }

        .pause-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 7vw, 3.5rem);
            background: linear-gradient(to right, var(--neon-blue), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 25px rgba(0, 242, 255, 0.5);
            margin-bottom: clamp(12px, 2.5vw, 18px);
        }

        .pause-stats {
            background: rgba(0, 0, 0, 0.5);
            padding: clamp(15px, 3vw, 20px);
            border-radius: 15px;
            border: 2px solid var(--neon-blue);
            min-width: min(250px, 85%);
        }

        .pause-stats div {
            margin: clamp(10px, 2vw, 12px) 0;
            font-size: clamp(0.9rem, 2.2vw, 1.1rem);
            display: flex;
            justify-content: space-between;
        }

        .pause-stats span:first-child {
            color: var(--neon-blue);
        }

        .pause-stats span:last-child {
            color: var(--neon-yellow);
            font-weight: bold;
        }

        .hidden { 
            display: none !important; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s, visibility 0.5s;
        }

        /* Animation d'invincibilit√© am√©lior√©e */
        .player-invincible {
            animation: playerBlink 0.5s infinite alternate;
        }

        @keyframes playerBlink {
            0% { 
                opacity: 0.3;
                filter: brightness(2) drop-shadow(0 0 15px var(--neon-blue));
            }
            100% { 
                opacity: 1;
                filter: brightness(1) drop-shadow(0 0 8px var(--neon-blue));
            }
        }

        /* Mode paysage sur mobile - cache le jeu */
        @media (orientation: landscape) and (max-width: 768px) {
            .orientation-warning {
                display: flex;
            }
            
            #game-container:not(.allow-portrait) {
                display: none;
            }
            
            #mobile-controls {
                opacity: 0.3;
            }
        }

        /* Ajustements pour tr√®s petits √©crans */
        @media (max-height: 600px) {
            #mobile-controls {
                bottom: max(10px, var(--safe-area-bottom));
                padding: 0 clamp(10px, 3vw, 20px);
            }
            
            .joystick-container {
                width: clamp(90px, 22vw, 160px);
                height: clamp(90px, 22vw, 160px);
            }
            
            .action-btn {
                width: clamp(80px, 18vw, 120px);
                height: clamp(80px, 18vw, 120px);
                margin-bottom: clamp(10px, 3vw, 25px);
            }
            
            .hud {
                top: max(8px, var(--safe-area-top));
            }
            
            .lvl-display {
                top: max(8px, var(--safe-area-top));
            }
            
            .start-content h1 {
                font-size: clamp(1.5rem, 5vw, 2.5rem);
            }
        }

        /* Ajustements pour √©crans tr√®s √©troits */
        @media (max-width: 320px) {
            .hud {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }
            
            .score-display, .lives-container {
                width: auto;
            }
            
            .tutorial-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .mission-btn {
                width: 70px;
                height: 70px;
                font-size: 14px;
            }
            
            .go-btn {
                width: 85px;
                height: 85px;
                font-size: 18px;
            }
        }

        /* Desktop */
        @media (min-width: 769px) {
            .orientation-warning {
                display: none;
            }
            
            #mobile-controls {
                display: none;
            }
            
            .hud {
                top: max(25px, var(--safe-area-top));
                padding: 0 30px;
            }
            
            .score-display {
                font-size: 32px;
                padding: 12px 25px;
            }
            
            .heart {
                width: 35px;
                height: 35px;
            }
            
            .lvl-display {
                font-size: 24px;
                padding: 10px 25px;
                top: max(25px, var(--safe-area-top));
            }
            
            .combo-display {
                font-size: 24px;
                padding: 12px 20px;
                right: 25px;
            }
        }

        /* Grands √©crans desktop */
        @media (min-width: 1024px) {
            .mission-btn {
                width: 150px;
                height: 150px;
                font-size: 28px;
                margin: 40px;
            }
            
            .go-btn {
                width: 180px;
                height: 180px;
                font-size: 38px;
                margin: 40px;
            }
            
            .next-btn {
                width: 130px;
                height: 130px;
                font-size: 24px;
                margin: 35px;
            }
        }

        /* Indicateurs de swipe */
        .swipe-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 101;
            opacity: 0.7;
            pointer-events: none;
        }

        .swipe-text {
            color: var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(12px, 2vw, 16px);
            text-shadow: 0 0 5px var(--neon-blue);
            animation: swipePulse 2s infinite;
        }

        @keyframes swipePulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .swipe-arrow {
            width: 40px;
            height: 40px;
            position: relative;
            animation: arrowBounce 2s infinite;
        }

        @keyframes arrowBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(5px); }
        }

        .swipe-arrow.up svg,
        .swipe-arrow.down svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 5px var(--neon-blue));
        }

        .swipe-indicator.top .swipe-arrow {
            transform: rotate(180deg);
        }

        .swipe-indicator.top .swipe-text {
            order: -1;
            margin-top: 5px;
        }
    </style>
</head>
<body>

<div class="orientation-warning">
    <div>
        <h2>üîÑ Rotate Your Device</h2>
        <p>For the best gaming experience, please use your device in portrait mode.</p>
    </div>
</div>

<div id="game-container">
    <div class="hud">
        <div class="score-display" id="score-display">0</div>
        <div class="lives-container" id="lives-container">
            <div class="heart" id="heart-1">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-2">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-3">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
        </div>
    </div>

    <div class="lvl-display" id="lvl-display">LVL 1</div>
    <div class="combo-display" id="combo-display">COMBO x0</div>

    <!-- Main Start Screen -->
    <div id="start-screen" class="overlay">
        <div class="start-content">
            <h1>NEON DEVIL<br>MISSION EDITION</h1>
            <p>Survive in the neon arena. Eliminate waves of enemies. Become a legend.</p>
            <button class="mission-btn" onclick="Game.showTutorial(1)" id="play-btn" aria-label="Play">
                START
            </button>
        </div>
    </div>

    <!-- Tutorial Screens -->
    <div id="tutorial-1" class="overlay hidden">
        <div class="tutorial-screen">
            <div class="tutorial-title">CONTROLS</div>
            <div class="tutorial-subtitle">MOVEMENT JOYSTICK</div>
            <div class="tutorial-text">
                <p>The left joystick controls your ship:</p>
                <p>‚Ä¢ Slide your finger to move the ship</p>
                <p>‚Ä¢ The further you pull, the faster you go</p>
                <p>‚Ä¢ Release to return to center</p>
                <p>‚Ä¢ Avoid enemies by maneuvering</p>
            </div>
            <div class="tutorial-controls">
                <div class="tutorial-control-demo">
                    <div class="joystick-container">
                        <div class="joystick-boundary"></div>
                        <div class="joystick-thumb"></div>
                    </div>
                    <div class="control-label">JOYSTICK</div>
                    <div class="control-description">Move your ship in all directions</div>
                </div>
            </div>
            <button class="next-btn" onclick="Game.showTutorial(2)" id="next-btn-1" aria-label="Next">
                NEXT
            </button>
        </div>
        <!-- Swipe indicator for tutorial -->
        <div class="swipe-indicator">
            <div class="swipe-text">Swipe down for next</div>
            <div class="swipe-arrow down">
                <svg viewBox="0 0 24 24">
                    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                </svg>
            </div>
        </div>
    </div>

    <div id="tutorial-2" class="overlay hidden">
        <div class="tutorial-screen">
            <div class="tutorial-title">CONTROLS</div>
            <div class="tutorial-subtitle">FIRE BUTTON</div>
            <div class="tutorial-text">
                <p>The right button controls your weapons:</p>
                <p>‚Ä¢ Touch to fire projectiles</p>
                <p>‚Ä¢ Hold for automatic fire</p>
                <p>‚Ä¢ Hit enemies to destroy them</p>
                <p>‚Ä¢ Each hit scores points</p>
            </div>
            <div class="tutorial-controls">
                <div class="tutorial-control-demo">
                    <div class="action-btn">
                        <div class="target-icon">
                            <div class="target-cross"></div>
                            <div class="target-center"></div>
                        </div>
                    </div>
                    <div class="control-label">FIRE BUTTON</div>
                    <div class="control-description">Shoot enemies to destroy them</div>
                </div>
            </div>
            <div style="display: flex; gap: 15px; margin-top: 25px;">
                <button class="next-btn" onclick="Game.showTutorial(1)" aria-label="Back">
                    BACK
                </button>
                <button class="next-btn" onclick="Game.showTutorial(3)" aria-label="Next">
                    NEXT
                </button>
            </div>
        </div>
        <!-- Swipe indicators for tutorial (up and down) -->
        <div class="swipe-indicator">
            <div class="swipe-text">Swipe up for previous</div>
            <div class="swipe-arrow up">
                <svg viewBox="0 0 24 24">
                    <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>
                </svg>
            </div>
            <div style="height: 20px;"></div>
            <div class="swipe-text">Swipe down for next</div>
            <div class="swipe-arrow down">
                <svg viewBox="0 0 24 24">
                    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
                </svg>
            </div>
        </div>
    </div>

    <div id="tutorial-3" class="overlay hidden">
        <div class="tutorial-screen">
            <div class="tutorial-title">LIFE SYSTEM</div>
            <div class="tutorial-subtitle">YOUR SHIP</div>
            <div class="tutorial-text">
                <p>You have 3 lives to survive:</p>
                <p>‚Ä¢ Each contact with an enemy costs one life</p>
                <p>‚Ä¢ After losing a life, you are invincible for 2 seconds</p>
                <p>‚Ä¢ Lose all 3 lives and the mission fails</p>
                <p>‚Ä¢ Avoid enemies at all costs!</p>
            </div>
            <div class="lives-explanation">
                <div style="display: flex; gap: 15px;">
                    <div class="life-icon">
                        <svg viewBox="0 0 32 29.6">
                            <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                            c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                        </svg>
                    </div>
                    <div class="life-icon">
                        <svg viewBox="0 0 32 29.6">
                            <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                            c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                        </svg>
                    </div>
                    <div class="life-icon">
                        <svg viewBox="0 0 32 29.6">
                            <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                            c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                        </svg>
                    </div>
                </div>
                <div class="life-text">
                    Your ship has 3 lives. Avoid contact with enemies to survive as long as possible and get a high score!
                </div>
            </div>
            <div style="display: flex; gap: 15px; margin-top: 25px;">
                <button class="next-btn" onclick="Game.showTutorial(2)" aria-label="Back">
                    BACK
                </button>
                <button class="go-btn" onclick="Game.startMission()" aria-label="Start mission">
                    GO!
                </button>
            </div>
        </div>
        <!-- Swipe indicator for tutorial -->
        <div class="swipe-indicator top">
            <div class="swipe-arrow up">
                <svg viewBox="0 0 24 24">
                    <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/>
                </svg>
            </div>
            <div class="swipe-text">Swipe up for previous</div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="overlay hidden">
        <div class="mission-failed">
            <h1>MISSION FAILED</h1>
            <div class="score-results">
                <div class="score-item">
                    <span class="score-label">SCORE:</span>
                    <span class="score-value" id="final-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">BEST SCORE:</span>
                    <span class="highscore-value" id="best-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">LEVEL:</span>
                    <span class="score-value" id="final-level">1</span>
                </div>
                <div class="score-item">
                    <span class="score-label">MAX COMBO:</span>
                    <span class="score-value" id="final-combo">x0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">ENEMIES KILLED:</span>
                    <span class="score-value" id="final-kills">0</span>
                </div>
            </div>
            <button class="mission-btn" onclick="Game.startMission()" id="restart-btn" aria-label="Retry">
                RETRY
            </button>
        </div>
    </div>

    <!-- Pause Screen -->
    <div id="pause-screen" class="pause-overlay hidden">
        <div class="pause-title">PAUSE</div>
        <div class="pause-stats">
            <div>
                <span>Score:</span>
                <span id="pause-score">0</span>
            </div>
            <div>
                <span>Level:</span>
                <span id="pause-level">1</span>
            </div>
            <div>
                <span>Lives:</span>
                <span id="pause-lives">3</span>
            </div>
            <div>
                <span>Enemies Left:</span>
                <span id="pause-enemies">0</span>
            </div>
        </div>
        <button class="mission-btn" onclick="Game.resume()" id="resume-btn" aria-label="Resume">
            RESUME
        </button>
    </div>

    <canvas id="canvas"></canvas>

    <!-- ALWAYS VISIBLE CONTROLS -->
    <div id="mobile-controls">
        <div class="control-group">
            <div class="joystick-container" id="joystick-container">
                <div class="joystick-boundary"></div>
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="action-btn" id="btn-fire">
                <div class="target-icon">
                    <div class="target-cross"></div>
                    <div class="target-center"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * CONFIGURATION & CONSTANTS - OPTIMIZED FOR RESPONSIVE
 */
const CFG = {
    GRAVITY: 0.12,
    FRICTION: 0.93,
    SPEED: 5.0,
    PLAYER_SIZE: window.innerWidth * 0.06,
    ENEMY_SPEED_MULTIPLIER: 0.8,
    PROJECTILE_SPEED: 18,
    FIRE_RATE: 3,
    JOYSTICK_RADIUS: window.innerWidth * 0.15,
    JOYSTICK_DEADZONE: 0.05,
    JOYSTICK_RESPONSE_CURVE: 1.5,
    WORLD_WIDTH: 4000,
    WORLD_HEIGHT: 2000,
    COLORS: {
        player: '#00f2ff',
        enemyCircle: '#ff007a',
        enemyTriangle: '#bc13fe',
        enemySquare: '#ffd700',
        enemyStar: '#39ff14',
        enemyHexagon: '#ff00ff',
        enemySpiral: '#ff5500',
        enemyDrone: '#aa00ff',
        projectile: '#ff3333',
        nebula1: 'rgba(188, 19, 254, 0.1)',
        nebula2: 'rgba(0, 242, 255, 0.1)',
        nebula3: 'rgba(255, 0, 122, 0.1)'
    },
    PARTICLE_COUNT: {
        stars: Math.min(400, Math.floor(window.innerWidth * window.innerHeight * 0.0001)),
        nebulas: 12,
        backgroundParticles: 80
    }
};

/**
 * GAME ENGINE - IMPROVED WITH TUTORIAL AND SWIPE NAVIGATION
 */
const Game = {
    canvas: document.getElementById('canvas'),
    ctx: null,
    width: window.innerWidth,
    height: window.innerHeight,
    player: null,
    enemies: [],
    projectiles: [],
    particles: [],
    stars: [],
    nebulas: [],
    backgroundParticles: [],
    level: 1,
    score: 0,
    lives: 3,
    keys: {},
    cameraX: 0,
    cameraY: 0,
    isRunning: false,
    spawnTimer: 0,
    enemyCount: 0,
    shotsFired: 0,
    fireCooldown: 0,
    isMobile: false,
    isPortrait: false,
    joystickActive: false,
    joystickX: 0,
    joystickY: 0,
    joystickOrigin: {x: 0, y: 0},
    joystickMaxRadius: CFG.JOYSTICK_RADIUS,
    joystickTouchId: null,
    bestScore: 0,
    gameOver: false,
    explosionParticles: [],
    lastTime: 0,
    deltaTime: 0,
    combo: 0,
    comboTimeout: null,
    maxCombo: 0,
    enemiesKilled: 0,
    timePlayed: 0,
    shakeIntensity: 0,
    shakeDuration: 0,
    lastJoystickUpdate: 0,
    joystickSmoothing: 0.8,
    autoFireInterval: null,
    currentTutorial: 0,
    
    // Swipe navigation variables
    touchStartY: 0,
    touchEndY: 0,
    minSwipeDistance: 50, // Minimum distance for a swipe to be recognized

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.detectDevice();
        this.resize();
        
        // Load best score
        this.loadBestScore();
        
        // Resize events
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('orientationchange', () => {
            setTimeout(() => this.resize(), 100);
            this.checkOrientation();
        });
        
        // Input Listeners
        this.setupInput();
        this.setupMobileControls();
        this.setupSwipeNavigation(); // Setup swipe navigation for tutorial
        this.generateBackground();
        
        // Check initial orientation
        this.checkOrientation();
        
        this.loop(0);
    },

    setupSwipeNavigation() {
        // Get all tutorial screens
        const tutorialScreens = [
            document.getElementById('tutorial-1'),
            document.getElementById('tutorial-2'),
            document.getElementById('tutorial-3')
        ];
        
        // Add touch event listeners to each tutorial screen
        tutorialScreens.forEach(screen => {
            if (!screen) return;
            
            screen.addEventListener('touchstart', (e) => {
                this.touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });
            
            screen.addEventListener('touchend', (e) => {
                this.touchEndY = e.changedTouches[0].screenY;
                this.handleSwipe();
            }, { passive: true });
            
            // Also support mouse for desktop testing
            screen.addEventListener('mousedown', (e) => {
                this.touchStartY = e.screenY;
            });
            
            screen.addEventListener('mouseup', (e) => {
                this.touchEndY = e.screenY;
                this.handleSwipe();
            });
        });
    },

    handleSwipe() {
        const swipeDistance = this.touchStartY - this.touchEndY;
        
        // Check if swipe distance is significant enough
        if (Math.abs(swipeDistance) < this.minSwipeDistance) {
            return;
        }
        
        // Swipe up (negative distance means finger moved up)
        if (swipeDistance > 0) {
            // Swipe up - go to next tutorial
            this.nextTutorial();
        } else {
            // Swipe down - go to previous tutorial
            this.previousTutorial();
        }
    },

    nextTutorial() {
        if (this.currentTutorial < 3) {
            this.showTutorial(this.currentTutorial + 1);
        } else if (this.currentTutorial === 3) {
            // If on last tutorial, start mission
            this.startMission();
        }
    },

    previousTutorial() {
        if (this.currentTutorial > 1) {
            this.showTutorial(this.currentTutorial - 1);
        } else if (this.currentTutorial === 1) {
            // If on first tutorial, go back to start screen
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('tutorial-1').classList.add('hidden');
            this.currentTutorial = 0;
        }
    },

    showTutorial(tutorialNum) {
        this.currentTutorial = tutorialNum;
        
        // Hide all screens
        document.getElementById('start-screen').classList.add('hidden');
        for (let i = 1; i <= 3; i++) {
            document.getElementById(`tutorial-${i}`).classList.add('hidden');
        }
        
        // Show requested tutorial
        document.getElementById(`tutorial-${tutorialNum}`).classList.remove('hidden');
    },

    checkOrientation() {
        const isPortrait = window.innerHeight > window.innerWidth;
        const isMobile = this.isMobile;
        
        if (isMobile && !isPortrait) {
            document.querySelector('.orientation-warning').style.display = 'flex';
            document.getElementById('game-container').classList.add('allow-portrait');
        } else {
            document.querySelector('.orientation-warning').style.display = 'none';
            document.getElementById('game-container').classList.remove('allow-portrait');
        }
    },

    loadBestScore() {
        const savedScore = localStorage.getItem('neonDevilBestScore');
        this.bestScore = savedScore ? parseInt(savedScore) : 0;
        this.updateBestScoreDisplay();
    },

    saveBestScore() {
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('neonDevilBestScore', this.bestScore.toString());
        }
    },

    updateBestScoreDisplay() {
        document.getElementById('best-score').textContent = this.bestScore;
    },

    detectDevice() {
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isPortrait = window.innerHeight > window.innerWidth;
        
        // Adjust settings based on device
        if (this.isMobile) {
            CFG.SPEED = 4.5;
            CFG.PLAYER_SIZE = Math.min(45, window.innerWidth * 0.05);
            CFG.JOYSTICK_RADIUS = Math.min(70, window.innerWidth * 0.15);
            CFG.PROJECTILE_SPEED = 16;
            CFG.PARTICLE_COUNT.stars = Math.min(400, Math.floor(window.innerWidth * window.innerHeight * 0.0001));
            CFG.JOYSTICK_DEADZONE = 0.03;
            CFG.JOYSTICK_RESPONSE_CURVE = 1.3;
        }
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.isPortrait = this.height > this.width;
        
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        // Adjust settings based on screen size
        if (this.isMobile) {
            CFG.PLAYER_SIZE = Math.max(30, Math.min(45, this.width * 0.04));
            CFG.JOYSTICK_RADIUS = Math.max(40, Math.min(70, this.width * 0.12));
        } else {
            CFG.PLAYER_SIZE = Math.min(45, this.width * 0.03);
        }
        
        // Recalculate joystick position
        this.calculateJoystickOrigin();
        
        // Update orientation warning
        this.checkOrientation();
    },

    calculateJoystickOrigin() {
        const joystickContainer = document.querySelector('.joystick-container');
        if (!joystickContainer) return;
        
        const rect = joystickContainer.getBoundingClientRect();
        this.joystickOrigin.x = rect.left + rect.width / 2;
        this.joystickOrigin.y = rect.top + rect.height / 2;
        this.joystickMaxRadius = Math.min(rect.width / 2 - 15, CFG.JOYSTICK_RADIUS);
    },

    setupInput() {
        // Keyboard
        window.addEventListener('keydown', e => {
            if (!this.isRunning) return;
            
            this.keys[e.code] = true;
            if (e.code === 'Space' && this.fireCooldown <= 0) {
                e.preventDefault();
                if (this.player && !this.player.invincible) {
                    this.player.fire();
                    this.fireCooldown = CFG.FIRE_RATE;
                }
            }
            if (e.code === 'Escape' || e.code === 'KeyP') {
                if (this.isRunning && !this.gameOver) {
                    this.togglePause();
                }
            }
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
    },

    setupMobileControls() {
        const joystickContainer = document.getElementById('joystick-container');
        const fireBtn = document.getElementById('btn-fire');
        const joystickThumb = document.getElementById('joystick-thumb');
        
        if (!joystickContainer) return;
        
        this.calculateJoystickOrigin();
        
        // Joystick handling
        const handleJoystickStart = (clientX, clientY, touchId = null) => {
            if (!this.isRunning) return;
            
            this.joystickActive = true;
            if (touchId !== null) this.joystickTouchId = touchId;
            joystickThumb.classList.add('active');
            this.updateJoystickPosition(clientX, clientY, true);
        };
        
        const handleJoystickMove = (clientX, clientY) => {
            if (!this.joystickActive || !this.isRunning) return;
            this.updateJoystickPosition(clientX, clientY, false);
        };
        
        const handleJoystickEnd = (touchId = null) => {
            if (touchId !== null && this.joystickTouchId !== touchId) return;
            
            this.joystickActive = false;
            this.joystickX = 0;
            this.joystickY = 0;
            this.joystickTouchId = null;
            joystickThumb.classList.remove('active');
            joystickThumb.style.transform = 'translate(-50%, -50%)';
        };
        
        // Touch events
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            handleJoystickStart(touch.clientX, touch.clientY, touch.identifier);
        }, { passive: false, capture: true });
        
        document.addEventListener('touchmove', (e) => {
            if (!this.joystickActive || !this.joystickTouchId) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleJoystickMove(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        }, { passive: false, capture: true });
        
        document.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        }, { capture: true });
        
        document.addEventListener('touchcancel', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        }, { capture: true });
        
        // Mouse events for desktop
        joystickContainer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleJoystickStart(e.clientX, e.clientY);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!this.joystickActive) return;
            e.preventDefault();
            e.stopPropagation();
            handleJoystickMove(e.clientX, e.clientY);
        });
        
        document.addEventListener('mouseup', (e) => {
            if (this.joystickActive) {
                e.preventDefault();
                e.stopPropagation();
                handleJoystickEnd();
            }
        });
        
        // Fire button
        const handleFireStart = () => {
            if (!this.isRunning) return;
            
            if (this.fireCooldown <= 0 && this.player && !this.player.invincible) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
                this.startAutoFire();
            }
            fireBtn.classList.add('active');
        };
        
        const handleFireEnd = () => {
            fireBtn.classList.remove('active');
            this.stopAutoFire();
        };
        
        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireStart();
        }, { passive: false });
        
        fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireStart();
        });
        
        fireBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mouseleave', handleFireEnd);
    },

    startAutoFire() {
        if (this.autoFireInterval) clearInterval(this.autoFireInterval);
        
        this.autoFireInterval = setInterval(() => {
            if (this.isRunning && this.player && !this.player.invincible && this.fireCooldown <= 0) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
            }
        }, 150);
    },
    
    stopAutoFire() {
        if (this.autoFireInterval) {
            clearInterval(this.autoFireInterval);
            this.autoFireInterval = null;
        }
    },

    updateJoystickPosition(clientX, clientY, isStart = false) {
        const joystickThumb = document.getElementById('joystick-thumb');
        const now = Date.now();
        
        if (now - this.lastJoystickUpdate < 16 && !isStart) return;
        this.lastJoystickUpdate = now;
        
        this.calculateJoystickOrigin();
        
        let deltaX = clientX - this.joystickOrigin.x;
        let deltaY = clientY - this.joystickOrigin.y;
        let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        let normalizedDistance = Math.min(distance / this.joystickMaxRadius, 1);
        let responseFactor = Math.pow(normalizedDistance, CFG.JOYSTICK_RESPONSE_CURVE);
        
        if (distance > this.joystickMaxRadius) {
            deltaX = (deltaX / distance) * this.joystickMaxRadius;
            deltaY = (deltaY / distance) * this.joystickMaxRadius;
            distance = this.joystickMaxRadius;
            normalizedDistance = 1;
            responseFactor = 1;
        }
        
        if (distance < this.joystickMaxRadius * CFG.JOYSTICK_DEADZONE) {
            deltaX = 0;
            deltaY = 0;
            normalizedDistance = 0;
            responseFactor = 0;
        }
        
        joystickThumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        
        this.joystickX = (deltaX / this.joystickMaxRadius) * responseFactor;
        this.joystickY = (deltaY / this.joystickMaxRadius) * responseFactor;
    },

    togglePause() {
        if (this.isRunning && !this.gameOver) {
            this.isRunning = false;
            document.getElementById('pause-screen').classList.remove('hidden');
            document.getElementById('pause-score').textContent = this.score;
            document.getElementById('pause-level').textContent = this.level;
            document.getElementById('pause-lives').textContent = this.lives;
            document.getElementById('pause-enemies').textContent = this.enemies.length;
            document.getElementById('resume-btn').focus();
            this.stopAutoFire();
        }
    },

    resume() {
        this.isRunning = true;
        document.getElementById('pause-screen').classList.add('hidden');
        this.canvas.focus();
    },

    startMission() {
        console.log("Mission starting!");
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.enemies = [];
        this.projectiles = [];
        this.particles = [];
        this.explosionParticles = [];
        this.enemyCount = 0;
        this.enemiesKilled = 0;
        this.shotsFired = 0;
        this.fireCooldown = 0;
        this.isRunning = true;
        this.gameOver = false;
        this.cameraX = -CFG.WORLD_WIDTH / 2 + this.width / 2;
        this.cameraY = -CFG.WORLD_HEIGHT / 2 + this.height / 2;
        this.lastTime = 0;
        this.timePlayed = 0;
        this.combo = 0;
        this.maxCombo = 0;
        
        // Reset joystick
        this.joystickActive = false;
        this.joystickX = 0;
        this.joystickY = 0;
        const joystickThumb = document.getElementById('joystick-thumb');
        if (joystickThumb) {
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            joystickThumb.classList.remove('active');
        }
        
        // Stop auto fire
        this.stopAutoFire();
        
        // Hide all tutorial and overlay screens
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('pause-screen').classList.add('hidden');
        for (let i = 1; i <= 3; i++) {
            document.getElementById(`tutorial-${i}`).classList.add('hidden');
        }
        
        // Initial position at world center
        this.player = new Player(0, 0);
        this.spawnTimer = 0;
        this.updateHUD();
        this.updateLevelDisplay();
        this.updateComboDisplay();
        
        this.updateHearts();
        
        // Clean invincibility classes
        this.canvas.classList.remove('player-invincible');
        
        this.canvas.focus();
    },

    generateBackground() {
        // Generate stars
        this.stars = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.stars; i++) {
            this.stars.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: Math.random() * 2.5 + 0.5,
                speed: Math.random() * 0.8 + 0.2,
                opacity: Math.random() * 0.8 + 0.2,
                twinkleSpeed: Math.random() * 0.05 + 0.01,
                twinkleOffset: Math.random() * Math.PI * 2
            });
        }
        
        // Generate nebulas
        this.nebulas = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.nebulas; i++) {
            const size = Math.random() * 600 + 300;
            this.nebulas.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: size,
                color: [CFG.COLORS.nebula1, CFG.COLORS.nebula2, CFG.COLORS.nebula3][Math.floor(Math.random() * 3)],
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: Math.random() * 0.002 - 0.001
            });
        }
        
        // Generate background particles
        this.backgroundParticles = [];
        for (let i = 0; i < CFG.PARTICLE_COUNT.backgroundParticles; i++) {
            this.backgroundParticles.push({
                x: Math.random() * CFG.WORLD_WIDTH - CFG.WORLD_WIDTH/2,
                y: Math.random() * CFG.WORLD_HEIGHT - CFG.WORLD_HEIGHT/2,
                size: Math.random() * 3 + 1,
                color: [CFG.COLORS.player, CFG.COLORS.enemyCircle, CFG.COLORS.enemyStar][Math.floor(Math.random() * 3)],
                speed: Math.random() * 2 + 0.5,
                direction: Math.random() * Math.PI * 2,
                opacity: Math.random() * 0.3 + 0.1
            });
        }
    },

    canSpawnEnemyAt(x, y, size) {
        if (!this.player) return true;
        
        const playerDist = Math.sqrt(
            Math.pow(x - this.player.x, 2) + 
            Math.pow(y - this.player.y, 2)
        );
        if (playerDist < 250) return false;
        
        for (const enemy of this.enemies) {
            const dist = Math.sqrt(
                Math.pow(x - enemy.x, 2) + 
                Math.pow(y - enemy.y, 2)
            );
            const minDist = (size/2) + (enemy.size/2) + 25;
            if (dist < minDist) {
                return false;
            }
        }
        return true;
    },

    spawnEnemy() {
        const edge = Math.floor(Math.random() * 4);
        let baseX, baseY, vx, vy;
        
        const spawnMargin = 150;
        const worldLeft = -CFG.WORLD_WIDTH/2;
        const worldRight = CFG.WORLD_WIDTH/2;
        const worldTop = -CFG.WORLD_HEIGHT/2;
        const worldBottom = CFG.WORLD_HEIGHT/2;
        
        switch(edge) {
            case 0: // Top
                baseX = Math.random() * CFG.WORLD_WIDTH + worldLeft;
                baseY = worldTop - spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = Math.random() * 2 + 1;
                break;
            case 1: // Right
                baseX = worldRight + spawnMargin;
                baseY = Math.random() * CFG.WORLD_HEIGHT + worldTop;
                vx = -Math.random() * 2 - 1;
                vy = (Math.random() - 0.5) * 2;
                break;
            case 2: // Bottom
                baseX = Math.random() * CFG.WORLD_WIDTH + worldLeft;
                baseY = worldBottom + spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = -Math.random() * 2 - 1;
                break;
            case 3: // Left
                baseX = worldLeft - spawnMargin;
                baseY = Math.random() * CFG.WORLD_HEIGHT + worldTop;
                vx = Math.random() * 2 + 1;
                vy = (Math.random() - 0.5) * 2;
                break;
        }
        
        const enemyTypes = ['circle', 'triangle', 'square', 'star', 'hexagon', 'spiral', 'drone'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const size = 20 + Math.random() * 15 + this.level * 1.5;
        const x = baseX;
        const y = baseY;
        
        if (this.canSpawnEnemyAt(x, y, size)) {
            this.enemies.push(new Enemy(x, y, vx, vy, type, size));
            this.enemyCount++;
            return true;
        }
        return false;
    },

    updateHUD() {
        document.getElementById('score-display').textContent = this.score;
    },

    updateLevelDisplay() {
        document.getElementById('lvl-display').textContent = `LVL ${this.level}`;
    },

    updateComboDisplay() {
        const comboDisplay = document.getElementById('combo-display');
        comboDisplay.textContent = `COMBO x${this.combo}`;
        
        if (this.combo > 1) {
            comboDisplay.classList.add('active');
        } else {
            comboDisplay.classList.remove('active');
        }
    },

    incrementCombo() {
        this.combo++;
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
        }
        
        this.updateComboDisplay();
        
        if (this.comboTimeout) {
            clearTimeout(this.comboTimeout);
        }
        
        this.comboTimeout = setTimeout(() => {
            if (this.combo > 3) {
                this.createComboText();
            }
            this.combo = 0;
            this.updateComboDisplay();
        }, 3000);
    },

    createComboText() {
        if (!this.player) return;
        
        for (let i = 0; i < 8; i++) {
            this.particles.push(new Particle(
                this.player.x,
                this.player.y,
                CFG.COLORS.enemyStar,
                (Math.random() - 0.5) * 6,
                (Math.random() - 0.5) * 6,
                15,
                true
            ));
        }
    },

    updateHearts() {
        for (let i = 1; i <= 3; i++) {
            const heart = document.getElementById(`heart-${i}`);
            if (i <= this.lives) {
                heart.classList.remove('lost');
                if (i === this.lives) {
                    heart.classList.add('pulse');
                    setTimeout(() => heart.classList.remove('pulse'), 500);
                }
            } else {
                heart.classList.add('lost');
                heart.classList.remove('pulse');
            }
        }
    },

    createShipExplosion(x, y) {
        for (let i = 0; i < 60; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 5;
            const size = 3 + Math.random() * 5;
            
            this.explosionParticles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: size,
                life: 1.0,
                color: CFG.COLORS.player,
                decay: 0.015 + Math.random() * 0.015
            });
        }
        
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 40;
            const size = 2 + Math.random() * 3;
            
            setTimeout(() => {
                const ex = x + Math.cos(angle) * distance;
                const ey = y + Math.sin(angle) * distance;
                
                for (let j = 0; j < 10; j++) {
                    const a = Math.random() * Math.PI * 2;
                    const s = 1 + Math.random() * 2.5;
                    
                    this.explosionParticles.push({
                        x: ex,
                        y: ey,
                        vx: Math.cos(a) * s,
                        vy: Math.sin(a) * s,
                        size: size,
                        life: 0.8,
                        color: '#ff5500',
                        decay: 0.02 + Math.random() * 0.02
                    });
                }
            }, Math.random() * 400);
        }
        
        this.screenShake(8, 400);
    },

    screenShake(intensity, duration) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
    },

    die() {
        if (this.gameOver || !this.player) return;
        
        if (this.player.invincible) return;
        
        this.lives--;
        this.updateHearts();
        
        if (this.lives > 0) {
            this.spawnExplosion(this.player.x, this.player.y, CFG.COLORS.enemyCircle);
            
            this.player.invincible = true;
            this.player.invincibleTimer = 120;
            
            this.player.x = 0;
            this.player.y = 0;
            this.player.vx = 0;
            this.player.vy = 0;
            
            this.canvas.classList.add('player-invincible');
            
            this.combo = 0;
            this.updateComboDisplay();
            
            this.stopAutoFire();
        } else {
            this.gameOver = true;
            this.isRunning = false;
            
            this.createShipExplosion(this.player.x, this.player.y);
            
            this.canvas.classList.remove('player-invincible');
            
            this.stopAutoFire();
            
            setTimeout(() => {
                this.player = null;
                
                this.saveBestScore();
                
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('best-score').textContent = this.bestScore;
                document.getElementById('final-level').textContent = this.level;
                document.getElementById('final-combo').textContent = `x${this.maxCombo}`;
                document.getElementById('final-kills').textContent = this.enemiesKilled;
                
                setTimeout(() => document.getElementById('restart-btn').focus(), 100);
            }, 1200);
        }
    },

    spawnExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    },

    findNearestEnemy() {
        let nearest = null;
        let nearestDist = Infinity;
        
        for (const enemy of this.enemies) {
            const dx = enemy.x - this.player.x;
            const dy = enemy.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist) {
                nearestDist = dist;
                nearest = enemy;
            }
        }
        
        return nearest;
    },

    loop(timestamp) {
        this.deltaTime = Math.min(timestamp - this.lastTime, 32);
        this.lastTime = timestamp;
        
        if (this.isRunning) {
            this.timePlayed += this.deltaTime;
        }
        
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        if (this.isMobile && !this.isPortrait) {
            requestAnimationFrame((t) => this.loop(t));
            return;
        }
        
        if(this.isRunning && this.player) {
            this.update();
            this.draw();
        } else if (this.gameOver) {
            this.updateExplosionParticles();
            this.drawBackground();
            this.draw();
        } else {
            this.drawBackground();
        }
        
        requestAnimationFrame((t) => this.loop(t));
    },

    update() {
        if (!this.player || !this.isRunning) return;
        
        if (this.fireCooldown > 0) {
            this.fireCooldown -= 1;
        }
        
        if (!this.joystickActive) {
            this.joystickX *= 0.7;
            this.joystickY *= 0.7;
            
            if (Math.abs(this.joystickX) < 0.01) this.joystickX = 0;
            if (Math.abs(this.joystickY) < 0.01) this.joystickY = 0;
        }
        
        if ((this.keys['Space'] || this.keys['ShiftLeft']) && this.fireCooldown <= 0 && !this.player.invincible) {
            this.player.fire();
            this.fireCooldown = CFG.FIRE_RATE;
        }
        
        this.spawnTimer++;
        const spawnRate = Math.max(6, 45 - this.level * 2);
        if(this.spawnTimer >= spawnRate) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }
        
        this.player.update();
        
        if (this.player && !this.player.invincible) {
            let targetCamX = this.player.x - this.width / 2;
            let targetCamY = this.player.y - this.height / 2;
            
            const maxCamX = CFG.WORLD_WIDTH/2 - this.width;
            const maxCamY = CFG.WORLD_HEIGHT/2 - this.height;
            const minCamX = -CFG.WORLD_WIDTH/2;
            const minCamY = -CFG.WORLD_HEIGHT/2;
            
            targetCamX = Math.max(minCamX, Math.min(targetCamX, maxCamX));
            targetCamY = Math.max(minCamY, Math.min(targetCamY, maxCamY));
            
            this.cameraX += (targetCamX - this.cameraX) * 0.08;
            this.cameraY += (targetCamY - this.cameraY) * 0.08;
        }
        
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            enemy.update();
            
            if(this.player && !this.player.invincible && this.circleIntersect(this.player, enemy)) {
                this.die();
                enemy.markForRemoval = true;
            }
            
            if (enemy.x < -CFG.WORLD_WIDTH/2 - 200 || enemy.x > CFG.WORLD_WIDTH/2 + 200 ||
                enemy.y < -CFG.WORLD_HEIGHT/2 - 200 || enemy.y > CFG.WORLD_HEIGHT/2 + 200) {
                enemy.markForRemoval = true;
            }
        }
        
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.update();
            
            for (let j = this.enemies.length - 1; j >= 0; j--) {
                const enemy = this.enemies[j];
                if (this.circleIntersect(proj, enemy)) {
                    this.score += 100 * this.combo;
                    this.enemiesKilled++;
                    this.incrementCombo();
                    this.spawnExplosion(enemy.x, enemy.y, enemy.color);
                    enemy.markForRemoval = true;
                    this.projectiles.splice(i, 1);
                    this.enemyCount--;
                    this.updateHUD();
                    this.screenShake(2, 80);
                    break;
                }
            }
            
            if (proj.life <= 0) {
                this.projectiles.splice(i, 1);
            }
        }
        
        this.enemies = this.enemies.filter(en => !en.markForRemoval);
        
        this.particles = this.particles.filter(p => p.update());
        
        this.updateBackgroundParticles();
        
        if (this.shakeDuration > 0) {
            this.shakeDuration -= this.deltaTime;
        } else {
            this.shakeIntensity = 0;
        }
        
        if(this.score >= this.level * 1200) {
            this.level++;
            this.updateLevelDisplay();
            this.screenShake(4, 150);
            
            for (let i = 0; i < 25; i++) {
                this.particles.push(new Particle(
                    this.player ? this.player.x : 0,
                    this.player ? this.player.y : 0,
                    CFG.COLORS.nebula2,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    20,
                    true
                ));
            }
        }
    },

    updateBackgroundParticles() {
        for (const p of this.backgroundParticles) {
            p.x += Math.cos(p.direction) * p.speed;
            p.y += Math.sin(p.direction) * p.speed;
            
            if (p.x < -CFG.WORLD_WIDTH/2 || p.x > CFG.WORLD_WIDTH/2) {
                p.direction = Math.PI - p.direction;
            }
            if (p.y < -CFG.WORLD_HEIGHT/2 || p.y > CFG.WORLD_HEIGHT/2) {
                p.direction = -p.direction;
            }
        }
    },

    updateExplosionParticles() {
        for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
            const p = this.explosionParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= p.decay;
            
            if (p.life <= 0) {
                this.explosionParticles.splice(i, 1);
            }
        }
    },

    circleIntersect(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius1 = obj1.size ? obj1.size/2 : (obj1.radius || 0);
        const radius2 = obj2.size ? obj2.size/2 : (obj2.radius || 0);
        return distance < radius1 + radius2;
    },

    drawBackground() {
        const gradient = this.ctx.createRadialGradient(
            this.width/2, this.height/2, 0,
            this.width/2, this.height/2, Math.max(this.width, this.height)/2
        );
        gradient.addColorStop(0, '#050510');
        gradient.addColorStop(0.5, '#03031a');
        gradient.addColorStop(1, '#010125');
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        if (this.shakeIntensity > 0) {
            const shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
            const shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
            this.ctx.translate(shakeX, shakeY);
        }
        
        this.ctx.save();
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        this.nebulas.forEach(nebula => {
            this.ctx.save();
            this.ctx.translate(nebula.x, nebula.y);
            this.ctx.rotate(nebula.rotation);
            
            const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, nebula.size);
            gradient.addColorStop(0, nebula.color);
            gradient.addColorStop(1, 'transparent');
            
            this.ctx.fillStyle = gradient;
            this.ctx.globalAlpha = 0.25;
            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, nebula.size, nebula.size * 0.5, 0, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.restore();
            
            nebula.rotation += nebula.rotationSpeed;
        });
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        this.stars.forEach(star => {
            const twinkle = Math.sin(this.timePlayed * 0.001 * star.twinkleSpeed + star.twinkleOffset) * 0.3 + 0.7;
            this.ctx.globalAlpha = star.opacity * twinkle;
            const x = star.x - this.cameraX * star.speed * 0.05;
            const y = star.y - this.cameraY * star.speed * 0.05;
            
            if (x > -100 && x < this.width + 100 && y > -100 && y < this.height + 100) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
        
        this.backgroundParticles.forEach(p => {
            this.ctx.globalAlpha = p.opacity;
            this.ctx.fillStyle = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        this.ctx.globalAlpha = 1;
        this.ctx.restore();
        
        if (this.shakeIntensity > 0) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
    },

    draw() {
        this.drawBackground();
        
        this.ctx.save();
        
        if (this.shakeIntensity > 0) {
            const shakeX = (Math.random() - 0.5) * this.shakeIntensity * 2;
            const shakeY = (Math.random() - 0.5) * this.shakeIntensity * 2;
            this.ctx.translate(shakeX, shakeY);
        }
        
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        this.drawGrid();
        
        this.projectiles.forEach(p => p.draw(this.ctx));
        
        this.enemies.forEach(en => en.draw(this.ctx));
        
        this.particles.forEach(p => p.draw(this.ctx));
        
        this.explosionParticles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.shadowBlur = p.life * 12;
            this.ctx.shadowColor = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1;
            this.ctx.shadowBlur = 0;
        });
        
        if (this.player) {
            this.player.draw(this.ctx);
        }
        
        this.ctx.restore();
    },

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.04)';
        this.ctx.lineWidth = 1;
        let step = 120;
        let startX = Math.floor((this.cameraX - this.width) / step) * step;
        let startY = Math.floor((this.cameraY - this.height) / step) * step;
        
        for(let x = startX; x < startX + this.width * 2 + step; x += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);
            this.ctx.lineTo(x, startY + this.height * 2 + step);
            this.ctx.stroke();
        }
        
        for(let y = startY; y < startY + this.height * 2 + step; y += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(startX, y);
            this.ctx.lineTo(startX + this.width * 2 + step, y);
            this.ctx.stroke();
        }
        
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.15)';
        this.ctx.lineWidth = 1.5;
        this.ctx.beginPath();
        this.ctx.arc(0, 0, 400, 0, Math.PI * 2);
        this.ctx.stroke();
    }
};

/**
 * GAME OBJECT CLASSES
 */
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.size = Game.isMobile ? CFG.PLAYER_SIZE * 0.85 : CFG.PLAYER_SIZE;
        this.angle = 0;
        this.engineParticles = 0;
        this.wingFlap = 0;
        this.autoRotateSpeed = 0.1;
        
        this.invincible = false;
        this.invincibleTimer = 0;
        
        this.engineGlow = 0;
        this.trail = [];
        
        this.centerForce = 0.0008;
    }

    updateInvincibility() {
        if (this.invincible) {
            this.invincibleTimer--;
            
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
                this.invincibleTimer = 0;
                Game.canvas.classList.remove('player-invincible');
            }
        }
    }

    fire() {
        if (this.invincible) return;
        
        Game.shotsFired++;
        const proj = new Projectile(
            this.x + Math.cos(this.angle) * this.size/2,
            this.y + Math.sin(this.angle) * this.size/2,
            Math.cos(this.angle) * CFG.PROJECTILE_SPEED,
            Math.sin(this.angle) * CFG.PROJECTILE_SPEED,
            this.angle
        );
        Game.projectiles.push(proj);
        Game.updateHUD();
        
        this.vx -= Math.cos(this.angle) * 1;
        this.vy -= Math.sin(this.angle) * 1;
        
        Game.screenShake(1, 40);
    }

    update() {
        this.updateInvincibility();
        
        if(Game.keys['ArrowLeft'] || Game.keys['KeyA']) this.vx -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowRight'] || Game.keys['KeyD']) this.vx += CFG.SPEED * 0.2;
        if(Game.keys['ArrowUp'] || Game.keys['KeyW']) this.vy -= CFG.SPEED * 0.2;
        if(Game.keys['ArrowDown'] || Game.keys['KeyS']) this.vy += CFG.SPEED * 0.2;
        
        if (Game.joystickActive || Math.abs(Game.joystickX) > 0.01 || Math.abs(Game.joystickY) > 0.01) {
            const sensitivity = 0.35;
            const joyX = Game.joystickX;
            const joyY = Game.joystickY;
            
            const force = (joyX * joyX + joyY * joyY) * 1.5;
            
            this.vx += joyX * CFG.SPEED * sensitivity * force;
            this.vy += joyY * CFG.SPEED * sensitivity * force;
        }
        
        this.wingFlap += 0.2;
        this.engineGlow = (this.engineGlow + 0.1) % (Math.PI * 2);
        
        const nearestEnemy = Game.findNearestEnemy();
        if (nearestEnemy) {
            const dx = nearestEnemy.x - this.x;
            const dy = nearestEnemy.y - this.y;
            const targetAngle = Math.atan2(dy, dx);
            
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            this.angle += angleDiff * this.autoRotateSpeed;
        }
        
        const centerX = Game.cameraX + Game.width / 2;
        const centerY = Game.cameraY + Game.height / 2;
        const cdx = centerX - this.x;
        const cdy = centerY - this.y;
        const distance = Math.sqrt(cdx * cdx + cdy * cdy);
        
        if(distance > 600) {
            this.vx += cdx * this.centerForce;
            this.vy += cdy * this.centerForce;
        }
        
        this.vx *= CFG.FRICTION;
        this.vy *= CFG.FRICTION;
        
        this.x += this.vx;
        this.y += this.vy;
        
        const maxX = CFG.WORLD_WIDTH/2 - 80;
        const maxY = CFG.WORLD_HEIGHT/2 - 80;
        this.x = Math.max(-maxX, Math.min(this.x, maxX));
        this.y = Math.max(-maxY, Math.min(this.y, maxY));
        
        this.trail.push({x: this.x, y: this.y, angle: this.angle});
        if (this.trail.length > 12) this.trail.shift();
        
        this.engineParticles++;
        if(this.engineParticles > 3 && (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1)) {
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            for(let i = 0; i < 2; i++) {
                const angle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                const power = Math.random() * speed * 0.5;
                Game.particles.push(new Particle(
                    this.x - Math.cos(this.angle) * this.size/2,
                    this.y - Math.sin(this.angle) * this.size/2,
                    CFG.COLORS.player,
                    Math.cos(angle) * power,
                    Math.sin(angle) * power,
                    12
                ));
            }
            this.engineParticles = 0;
        }
    }

    draw(ctx) {
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.25;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            ctx.rotate(point.angle);
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = CFG.COLORS.player;
            
            ctx.beginPath();
            ctx.moveTo(this.size/4, 0);
            ctx.lineTo(-this.size/4, -this.size/4);
            ctx.lineTo(-this.size/4, this.size/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        const wingOffset = Math.sin(this.wingFlap) * 3;
        const enginePulse = Math.sin(this.engineGlow) * 0.2 + 0.8;
        
        if (!this.invincible) {
            ctx.shadowBlur = 30;
            ctx.shadowColor = CFG.COLORS.player;
        } else {
            ctx.shadowBlur = 45;
            ctx.shadowColor = '#ffffff';
        }
        
        const gradient = ctx.createLinearGradient(-this.size/2, 0, this.size/2, 0);
        gradient.addColorStop(0, '#0088ff');
        gradient.addColorStop(0.5, CFG.COLORS.player);
        gradient.addColorStop(1, '#00aaff');
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1.5;
        
        ctx.beginPath();
        
        ctx.moveTo(this.size/2, 0);
        ctx.lineTo(this.size/4, -this.size/3);
        ctx.lineTo(-this.size/4, -this.size/2 + wingOffset);
        ctx.lineTo(-this.size/2, -this.size/4);
        ctx.lineTo(-this.size/2, this.size/4);
        ctx.lineTo(-this.size/4, this.size/2 - wingOffset);
        ctx.lineTo(this.size/4, this.size/3);
        ctx.closePath();
        
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(0, 100, 255, 0.5)';
        ctx.beginPath();
        ctx.ellipse(this.size/6, 0, this.size/3, this.size/4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(150, 220, 255, 0.3)';
        ctx.beginPath();
        ctx.ellipse(this.size/3, -this.size/8, this.size/6, this.size/8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255, ${100 + Math.floor(enginePulse * 155)}, 0, 0.8)`;
        ctx.fillRect(-this.size/2, -this.size/8, this.size/6, this.size/4);
        ctx.fillRect(-this.size/2 + this.size/5, -this.size/8, this.size/6, this.size/4);
        
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.size/2 - 8, -this.size/10, 12, this.size/5);
        
        if (Game.fireCooldown > CFG.FIRE_RATE - 5) {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(this.size/2, -this.size/12, 6, this.size/6);
        }
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, vx, vy, angle) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = Game.isMobile ? 4 : 5;
        this.life = 120;
        this.angle = angle;
        this.trail = [];
        this.sparkleTimer = 0;
    }
    
    update() {
        this.sparkleTimer++;
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 6) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        if (Math.random() < 0.7) {
            Game.particles.push(new Particle(
                this.x,
                this.y,
                CFG.COLORS.projectile,
                -this.vx * 0.2 + (Math.random() - 0.5) * 0.5,
                -this.vy * 0.2 + (Math.random() - 0.5) * 0.5,
                6
            ));
        }
        
        return this.life > 0;
    }
    
    draw(ctx) {
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.5;
            const size = this.radius * (i / this.trail.length);
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.fillStyle = `rgba(255, 150, 50, ${alpha})`;
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = CFG.COLORS.projectile;
        
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 2);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.3, '#ffaa00');
        gradient.addColorStop(0.7, CFG.COLORS.projectile);
        gradient.addColorStop(1, '#990000');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, -this.radius);
        ctx.lineTo(this.radius * 3.5, 0);
        ctx.lineTo(0, this.radius);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.radius, 0, this.radius/2, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.sparkleTimer % 4 === 0) {
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(-this.radius, (Math.random() - 0.5) * this.radius, this.radius/3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, vx, vy, type, size) {
        this.x = x;
        this.y = y;
        this.vx = vx * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.07);
        this.vy = vy * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.07);
        this.type = type;
        this.size = Game.isMobile ? size * 0.8 : size;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.06;
        this.markForRemoval = false;
        this.pulse = 0;
        this.animationTime = 0;
        this.color = CFG.COLORS[`enemy${type.charAt(0).toUpperCase() + type.slice(1)}`] || CFG.COLORS.enemyCircle;
        this.hitFlash = 0;
        this.trail = [];
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.pulse += 0.05;
        this.animationTime += 0.1;
        
        if (this.hitFlash > 0) this.hitFlash--;
        
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 8) this.trail.shift();
        
        if (Game.player && !Game.player.invincible) {
            const dx = Game.player.x - this.x;
            const dy = Game.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if(distance < 600) {
                this.vx += dx * 0.00015 * Game.level;
                this.vy += dy * 0.00015 * Game.level;
                
                if (distance < 150) {
                    this.vx -= dx * 0.0003;
                    this.vy -= dy * 0.0003;
                }
            }
        }
        
        Game.enemies.forEach(other => {
            if (other !== this) {
                const odx = other.x - this.x;
                const ody = other.y - this.y;
                const odist = Math.sqrt(odx * odx + ody * ody);
                const minDist = (this.size/2) + (other.size/2) + 15;
                
                if (odist < minDist && odist > 0) {
                    const force = 0.08;
                    this.vx -= (odx / odist) * force;
                    this.vy -= (ody / odist) * force;
                }
            }
        });
        
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        const maxSpeed = 3.5 + Game.level * 0.12;
        if(speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
        }
    }

    draw(ctx) {
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = (i / this.trail.length) * 0.3;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.size/4 * (i/this.trail.length), 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        if (this.hitFlash > 0) {
            ctx.shadowBlur = 40;
            ctx.shadowColor = 'white';
        } else {
            ctx.shadowBlur = 25;
            ctx.shadowColor = this.color;
        }
        
        ctx.rotate(this.rotation);
        
        const pulseSize = 1 + Math.sin(this.pulse) * 0.12;
        ctx.scale(pulseSize, pulseSize);
        
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1.5;
        
        switch(this.type) {
            case 'circle':
                this.drawCircleEnemy(ctx);
                break;
            case 'triangle':
                this.drawTriangleEnemy(ctx);
                break;
            case 'square':
                this.drawSquareEnemy(ctx);
                break;
            case 'star':
                this.drawStarEnemy(ctx);
                break;
            case 'hexagon':
                this.drawHexagonEnemy(ctx);
                break;
            case 'spiral':
                this.drawSpiralEnemy(ctx);
                break;
            case 'drone':
                this.drawDroneEnemy(ctx);
                break;
        }
        
        ctx.restore();
    }
    
    drawCircleEnemy(ctx) {
        for(let i = 0; i < 6; i++) {
            const segmentAngle = (i / 6) * Math.PI * 2 + this.rotation * 2;
            ctx.save();
            ctx.rotate(segmentAngle);
            
            const segmentPulse = Math.sin(this.animationTime * 2 + i) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)}, ${parseInt(this.color.slice(3,5),16)}, ${parseInt(this.color.slice(5,7),16)}, ${0.3 + segmentPulse * 0.3})`;
            
            ctx.beginPath();
            ctx.arc(0, this.size/2.8, this.size/5 * (0.5 + segmentPulse * 0.4), 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#111';
        const mouthOpen = Math.sin(this.animationTime * 2.5) * 0.4 + 0.6;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/3.5, 0, Math.PI * mouthOpen);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        const eyeSize = this.size/7 * (0.8 + Math.sin(this.animationTime * 3) * 0.2);
        ctx.beginPath();
        ctx.arc(-this.size/4, -this.size/8, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.size/4, -this.size/8, eyeSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    drawTriangleEnemy(ctx) {
        const trianglePulse = Math.sin(this.animationTime * 2) * 0.2;
        
        ctx.beginPath();
        ctx.moveTo(0, -this.size/2 * (1 + trianglePulse));
        ctx.lineTo(this.size/2, this.size/2 * (1 - trianglePulse/2));
        ctx.lineTo(-this.size/2, this.size/2 * (1 - trianglePulse/2));
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
        ctx.beginPath();
        ctx.moveTo(0, -this.size/3);
        ctx.lineTo(this.size/3, this.size/4);
        ctx.lineTo(-this.size/3, this.size/4);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'white';
        const blink = Math.sin(this.animationTime * 3) > 0 ? 1 : 0;
        if(blink) {
            ctx.beginPath();
            ctx.arc(-this.size/4, -this.size/10, this.size/9, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.size/4, -this.size/10, this.size/9, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    drawSquareEnemy(ctx) {
        const squareWobble = Math.sin(this.animationTime * 2.5) * 0.2;
        
        ctx.save();
        ctx.scale(1 + squareWobble, 1 - squareWobble);
        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
        ctx.restore();
        
        ctx.save();
        ctx.rotate(this.animationTime);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        const patternSize = this.size/3 * (0.8 + Math.sin(this.animationTime * 2) * 0.2);
        ctx.fillRect(-patternSize/2, -patternSize/2, patternSize, patternSize);
        ctx.restore();
    }
    
    drawStarEnemy(ctx) {
        const spikes = 6;
        const outerRadius = this.size/2;
        const innerRadius = this.size/3.5;
        const starPulse = Math.sin(this.animationTime * 1.8) * 0.3 + 0.65;
        
        ctx.beginPath();
        for(let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius * starPulse : innerRadius;
            const angle = (Math.PI * i) / spikes + this.animationTime;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.save();
        ctx.rotate(this.animationTime * 1.5);
        ctx.fillStyle = 'white';
        const centerPulse = Math.sin(this.animationTime * 2.5) * 0.15 + 0.8;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/6 * centerPulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    
    drawHexagonEnemy(ctx) {
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            const angle = (Math.PI * i) / 3 + Math.sin(this.animationTime + i) * 0.25;
            const radius = this.size/2 * (1 + Math.cos(this.animationTime * 2 + i) * 0.12);
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.save();
        ctx.rotate(-this.animationTime);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            const angle = (Math.PI * i) / 3;
            const radius = this.size/3.5;
            ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    
    drawSpiralEnemy(ctx) {
        ctx.beginPath();
        for(let i = 0; i < 20; i++) {
            const angle = i * 0.25 + this.animationTime * 1.5;
            const radius = (i / 20) * (this.size/2);
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            if(i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.save();
        ctx.rotate(this.animationTime * 2);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/3.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        for(let i = 0; i < 3; i++) {
            const angle = (Math.PI * 2 * i) / 3;
            const radius = this.size/7;
            ctx.beginPath();
            ctx.arc(Math.cos(angle) * radius/2, Math.sin(angle) * radius/2, radius/2.5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    drawDroneEnemy(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/3, 0, Math.PI * 2);
        ctx.fill();
        
        for(let i = 0; i < 3; i++) {
            const angle = (Math.PI * 2 * i) / 3;
            ctx.save();
            ctx.rotate(angle);
            
            ctx.fillStyle = this.color;
            ctx.fillRect(0, -this.size/25, this.size/2.5, this.size/12);
            
            ctx.save();
            ctx.translate(this.size/2.5, 0);
            ctx.rotate(this.animationTime * 4);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for(let j = 0; j < 2; j++) {
                const bladeAngle = (Math.PI * j);
                ctx.save();
                ctx.rotate(bladeAngle);
                ctx.fillRect(-this.size/35, -this.size/3.5, this.size/18, this.size/1.8);
                ctx.restore();
            }
            ctx.restore();
            
            ctx.restore();
        }
        
        ctx.fillStyle = 'white';
        const eyePulse = Math.sin(this.animationTime * 3) * 0.25 + 0.7;
        ctx.beginPath();
        ctx.arc(0, 0, this.size/7 * eyePulse, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color, vx = 0, vy = 0, life = 25, special = false) {
        this.x = x; this.y = y;
        this.vx = vx || (Math.random() - 0.5) * 5;
        this.vy = vy || (Math.random() - 0.5) * 5;
        this.life = life;
        this.maxLife = life;
        this.color = color;
        this.size = Math.random() * (Game.isMobile ? 2.5 : 3) + 1.5;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.15;
        this.special = special;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 1;
        this.rotation += this.rotationSpeed;
        
        this.size *= 0.97;
        
        return this.life > 0;
    }
    
    draw(ctx) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        
        if (this.special) {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 8;
            ctx.shadowColor = this.color;
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5;
                const radius = this.size;
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                
                const innerAngle = angle + Math.PI / 5;
                const innerRadius = this.size / 2;
                ctx.lineTo(Math.cos(innerAngle) * innerRadius, Math.sin(innerAngle) * innerRadius);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        } else {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 4;
            ctx.shadowColor = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
    }
}

// Launch
window.addEventListener('DOMContentLoaded', () => {
    Game.init();
    
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) e.preventDefault();
    }, { passive: false });
});
</script>
</body>
</html>
