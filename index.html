<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Neon Devil - Shooter Edition</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff007a;
            --neon-purple: #bc13fe;
            --neon-green: #39ff14;
            --neon-yellow: #ffd700;
            --neon-red: #ff3333;
            --bg-dark: #050505;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
        }

        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: var(--bg-dark);
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg-dark);
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #080810, #00051a);
        }

        /* UI Styles */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: opacity 0.3s;
            padding: 20px;
            padding-top: calc(20px + var(--safe-area-top));
            padding-bottom: calc(20px + var(--safe-area-bottom));
        }

        /* HUD r√©vis√© pour √©viter la superposition */
        .hud {
            position: fixed;
            top: max(15px, var(--safe-area-top));
            left: max(15px, var(--safe-area-left));
            right: max(15px, var(--safe-area-right));
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0 15px;
        }

        .score-display {
            font-size: 28px;
            font-weight: bold;
            color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .lives-container {
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 10px;
            border: 2px solid rgba(0, 242, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .heart {
            width: 30px;
            height: 30px;
            position: relative;
        }

        .heart svg {
            width: 100%;
            height: 100%;
            fill: var(--neon-blue);
            filter: drop-shadow(0 0 5px var(--neon-blue));
            transition: all 0.3s;
        }

        .heart.lost svg {
            fill: #333;
            filter: none;
        }

        /* Bouton triangle pour jouer */
        .play-triangle {
            width: 0;
            height: 0;
            border-left: 50px solid var(--neon-green);
            border-top: 30px solid transparent;
            border-bottom: 30px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            margin: 30px;
            filter: drop-shadow(0 0 15px var(--neon-green));
            background: none;
            border-right: none;
        }

        .play-triangle:hover {
            transform: scale(1.1);
            border-left-color: var(--neon-blue);
            filter: drop-shadow(0 0 25px var(--neon-blue));
        }

        .play-triangle:active {
            transform: scale(0.95);
        }

        /* Contr√¥les mobiles - TOUJOURS VISIBLES */
        #mobile-controls {
            position: fixed;
            bottom: max(20px, var(--safe-area-bottom));
            width: 100vw;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 60;
            gap: 20px;
            pointer-events: none;
        }

        .control-group {
            pointer-events: auto;
        }

        .joystick-container {
            position: relative;
            width: 150px;
            height: 150px;
            touch-action: none;
        }

        .joystick-boundary {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--neon-blue);
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(0, 242, 255, 0.3),
                inset 0 0 20px rgba(0, 242, 255, 0.1);
            backdrop-filter: blur(5px);
            pointer-events: none;
        }

        .joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            background: linear-gradient(45deg, var(--neon-blue), #00a8ff);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(0, 242, 255, 0.8),
                inset 0 0 10px rgba(255, 255, 255, 0.5);
            transition: transform 0.08s ease-out;
            pointer-events: none;
            z-index: 2;
        }

        .joystick-thumb.active {
            box-shadow: 
                0 0 30px rgba(0, 242, 255, 1),
                inset 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .action-btn {
            width: clamp(70px, 20vw, 100px);
            height: clamp(70px, 20vw, 100px);
            background: rgba(0, 100, 255, 0.3);
            border: 3px solid var(--neon-green);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            box-shadow: 
                0 0 20px rgba(57, 255, 20, 0.5),
                inset 0 0 10px rgba(57, 255, 20, 0.2);
            transition: all 0.1s;
            align-self: flex-end;
            margin-bottom: 20px;
            position: relative;
            cursor: pointer;
        }

        .action-btn.active {
            background: rgba(0, 100, 255, 0.5);
            transform: scale(0.95);
            box-shadow: 
                0 0 30px rgba(57, 255, 20, 0.8),
                inset 0 0 15px rgba(57, 255, 20, 0.3);
        }

        .target-icon {
            width: 70%;
            height: 70%;
            position: relative;
        }

        .target-icon::before,
        .target-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 2px solid var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
        }

        .target-icon::before {
            width: 80%;
            height: 80%;
        }

        .target-icon::after {
            width: 40%;
            height: 40%;
        }

        .target-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20%;
            height: 20%;
            background: var(--neon-green);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .target-cross {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 80%;
            background: var(--neon-green);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px var(--neon-green);
        }

        .target-cross::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 2px;
            background: var(--neon-green);
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px var(--neon-green);
        }

        /* Orientation d√©tection - MODE PORTRAIT */
        .orientation-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }

        .orientation-warning h2 {
            color: var(--neon-pink);
            margin-bottom: 20px;
            font-size: clamp(1.5rem, 5vw, 2rem);
        }

        .orientation-warning p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 4vw, 1.2rem);
        }

        /* Style pour l'√©cran de d√©marrage */
        .start-content {
            text-align: center;
            max-width: min(800px, 90vw);
            padding: 0 20px;
        }
        
        .start-content h1 {
            font-size: clamp(2.5rem, 10vw, 4rem);
            color: var(--neon-pink);
            text-shadow: 0 0 20px var(--neon-pink);
            margin-bottom: clamp(10px, 3vw, 20px);
            line-height: 1.2;
        }
        
        .start-content p {
            color: var(--neon-blue);
            font-size: clamp(1rem, 4vw, 1.2rem);
            margin-bottom: clamp(20px, 5vw, 30px);
            line-height: 1.5;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .score-display {
                font-size: 24px;
                padding: 4px 12px;
            }
            
            .heart {
                width: 25px;
                height: 25px;
            }
            
            .joystick-container {
                width: 120px;
                height: 120px;
            }

            .joystick-thumb {
                width: 60px;
                height: 60px;
            }
            
            .play-triangle {
                border-left-width: 40px;
                border-top-width: 25px;
                border-bottom-width: 25px;
            }
            
            /* Sur mobile, on cache les contr√¥les si on est en paysage (car on veut portrait) */
            @media (orientation: landscape) {
                #mobile-controls {
                    opacity: 0.7;
                }
            }
            
            /* Sur mobile portrait, les contr√¥les sont pleinement visibles */
            @media (orientation: portrait) {
                #mobile-controls {
                    opacity: 1;
                }
            }
        }

        @media (min-width: 1200px) {
            .score-display {
                font-size: 32px;
            }
            
            .heart {
                width: 35px;
                height: 35px;
            }
            
            .play-triangle {
                border-left-width: 60px;
                border-top-width: 35px;
                border-bottom-width: 35px;
            }
            
            /* Sur desktop, les contr√¥les sont semi-transparents */
            #mobile-controls {
                opacity: 0.4;
                transition: opacity 0.3s;
            }
            
            #mobile-controls:hover {
                opacity: 0.8;
            }
        }

        /* MODE PORTRAIT OBLIGATOIRE SUR MOBILE */
        @media (orientation: landscape) and (max-width: 768px) {
            .orientation-warning {
                display: flex;
            }
            
            #game-container:not(.allow-portrait) {
                display: none;
            }
            
            #mobile-controls {
                opacity: 0.3;
            }
        }

        @media (orientation: portrait) and (max-width: 768px) {
            /* En mode portrait, ajuster la taille des contr√¥les */
            .joystick-container {
                width: 140px;
                height: 140px;
            }
            
            .joystick-thumb {
                width: 65px;
                height: 65px;
            }
            
            .action-btn {
                width: 90px;
                height: 90px;
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .score-display {
                font-size: 20px;
            }
            
            .heart {
                width: 20px;
                height: 20px;
            }
        }

        /* Support pour √©crans tr√®s larges (TV) */
        @media (min-aspect-ratio: 16/9) {
            canvas {
                object-fit: cover;
            }
        }

        .hidden { display: none !important; }

        /* Animation d'invincibilit√© */
        .player-invincible {
            animation: playerBlink 0.3s infinite alternate;
        }

        @keyframes playerBlink {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* √âcran Mission Failed */
        .mission-failed {
            text-align: center;
            max-width: min(600px, 90vw);
        }

        .mission-failed h1 {
            font-size: clamp(2.5rem, 8vw, 4rem);
            color: var(--neon-red);
            text-shadow: 0 0 20px var(--neon-red);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .score-results {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid rgba(255, 51, 51, 0.3);
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.2);
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            font-size: 1.2rem;
        }

        .score-label {
            color: #ddd;
        }

        .score-value {
            color: var(--neon-yellow);
            font-weight: bold;
            font-size: 1.4rem;
        }

        .highscore-value {
            color: var(--neon-green);
            font-weight: bold;
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--neon-green);
        }
    </style>
</head>
<body>

<div class="orientation-warning">
    <div>
        <h2>üîÑ Tournez votre appareil</h2>
        <p>Pour une meilleure exp√©rience de jeu, veuillez utiliser votre appareil en mode portrait.</p>
    </div>
</div>

<div id="game-container">
    <div class="hud">
        <div class="score-display" id="score-display">0</div>
        <div class="lives-container" id="lives-container">
            <div class="heart" id="heart-1">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-2">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
            <div class="heart" id="heart-3">
                <svg viewBox="0 0 32 29.6">
                    <path d="M23.6,0c-3.4,0-6.3,2.7-7.6,5.6C14.7,2.7,11.8,0,8.4,0C3.8,0,0,3.8,0,8.4c0,9.4,9.5,11.9,16,21.2
                    c6.1-9.3,16-12.1,16-21.2C32,3.8,28.2,0,23.6,0z"/>
                </svg>
            </div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <div class="start-content">
            <h1>NEON DEVIL<br>SHOOTER</h1>
            <p>Destroy aliens! Survive as long as possible.</p>
            <button class="play-triangle" onclick="Game.start()" id="play-triangle-btn" aria-label="Jouer"></button>
        </div>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <div class="mission-failed">
            <h1>MISSION FAILED</h1>
            <div class="score-results">
                <div class="score-item">
                    <span class="score-label">SCORE:</span>
                    <span class="score-value" id="final-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">BEST SCORE:</span>
                    <span class="highscore-value" id="best-score">0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">LEVEL:</span>
                    <span class="score-value" id="final-level">1</span>
                </div>
                <div class="score-item">
                    <span class="score-label">SHOTS FIRED:</span>
                    <span class="score-value" id="final-shots">0</span>
                </div>
            </div>
            <button class="play-triangle" onclick="Game.start()" id="restart-btn" aria-label="Recommencer"></button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- CONTROLES TOUJOURS VISIBLES -->
    <div id="mobile-controls">
        <div class="control-group">
            <div class="joystick-container" id="joystick-container">
                <div class="joystick-boundary"></div>
                <div class="joystick-thumb" id="joystick-thumb"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="action-btn" id="btn-fire">
                <div class="target-icon">
                    <div class="target-cross"></div>
                    <div class="target-center"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Class to handle 2D vector operations
class Vector2 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    // Add two vectors
    add(vector) {
        return new Vector2(this.x + vector.x, this.y + vector.y);
    }

    // Subtract two vectors
    sub(vector) {
        return new Vector2(this.x - vector.x, this.y - vector.y);
    }

    // Multiply vector by a scalar
    mul(n) {
        return new Vector2(this.x * n, this.y * n);
    }

    // Divide vector by a scalar
    div(n) {
        return new Vector2(this.x / n, this.y / n);
    }

    // Calculate the magnitude (length) of the vector
    mag() {
        return Math.sqrt(this.x ** 2 + this.y ** 2);
    }

    // Normalize the vector (make its magnitude 1)
    normalize() {
        return this.mag() === 0 ? new Vector2(0, 0) : this.div(this.mag());
    }
}

/**
 * CONFIGURATION & CONSTANTES - OPTIMIS√âES POUR MOBILE PORTRAIT
 */
const CFG = {
    GRAVITY: 0.15,
    FRICTION: 0.92,
    SPEED: 4.5,
    PLAYER_SIZE: 40,
    ENEMY_SPEED_MULTIPLIER: 0.7,
    PROJECTILE_SPEED: 16,
    FIRE_RATE: 4,
    JOYSTICK_RADIUS: 55,
    JOYSTICK_DEADZONE: 0.15,
    COLORS: {
        player: '#00f2ff',
        enemyCircle: '#ff007a',
        enemyTriangle: '#bc13fe',
        enemySquare: '#ffd700',
        enemyStar: '#39ff14',
        enemyHexagon: '#ff00ff',
        enemySpiral: '#ff5500',
        enemyDrone: '#aa00ff',
        projectile: '#ff3333'
    }
};

/**
 * MOTEUR DE JEU - AM√âLIOR√â POUR MOBILE PORTRAIT
 */
const Game = {
    canvas: document.getElementById('canvas'),
    ctx: null,
    width: 0,
    height: 0,
    player: null,
    enemies: [],
    projectiles: [],
    particles: [],
    stars: [],
    level: 1,
    score: 0,
    lives: 3,
    keys: {},
    cameraX: 0,
    cameraY: 0,
    isRunning: false,
    spawnTimer: 0,
    enemyCount: 0,
    shotsFired: 0,
    fireCooldown: 0,
    isMobile: false,
    isPortrait: false,
    joystickActive: false,
    joystickX: 0,
    joystickY: 0,
    joystickOrigin: {x: 0, y: 0},
    joystickMaxRadius: CFG.JOYSTICK_RADIUS,
    joystickTouchId: null,
    bestScore: 0,
    gameOver: false,
    explosionParticles: [],
    lastTime: 0,
    deltaTime: 0,
    touchEvents: [],

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.detectDevice();
        this.resize();
        
        // Charger le meilleur score
        this.loadBestScore();
        
        // √âv√©nements de redimensionnement
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('orientationchange', () => {
            setTimeout(() => this.resize(), 100);
        });
        
        // Input Listeners
        this.setupInput();
        this.setupMobileControls();
        this.generateStars();
        
        // Focus sur le triangle de d√©marrage
        document.getElementById('play-triangle-btn').focus();
        
        this.loop(0);
    },

    loadBestScore() {
        const savedScore = localStorage.getItem('neonDevilBestScore');
        this.bestScore = savedScore ? parseInt(savedScore) : 0;
        this.updateBestScoreDisplay();
    },

    saveBestScore() {
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('neonDevilBestScore', this.bestScore.toString());
        }
    },

    updateBestScoreDisplay() {
        document.getElementById('best-score').textContent = this.bestScore;
    },

    detectDevice() {
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isPortrait = window.innerHeight > window.innerWidth;
        
        // Ajuster les param√®tres selon l'appareil
        if (this.isMobile) {
            CFG.SPEED = 4.0;
            CFG.PLAYER_SIZE = 35;
            CFG.JOYSTICK_RADIUS = 50;
            CFG.PROJECTILE_SPEED = 14;
        }
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        
        this.isPortrait = this.height > this.width;
        
        // Recalculer la position du joystick
        this.calculateJoystickOrigin();
    },

    calculateJoystickOrigin() {
        const joystickContainer = document.querySelector('.joystick-container');
        if (!joystickContainer) return;
        
        const rect = joystickContainer.getBoundingClientRect();
        this.joystickOrigin.x = rect.left + rect.width / 2;
        this.joystickOrigin.y = rect.top + rect.height / 2;
        this.joystickMaxRadius = Math.min(rect.width / 2 - 35, CFG.JOYSTICK_RADIUS);
    },

    setupInput() {
        // Clavier
        window.addEventListener('keydown', e => {
            if (!this.isRunning) return;
            
            this.keys[e.code] = true;
            if (e.code === 'Space' && this.fireCooldown <= 0) {
                e.preventDefault();
                if (this.player && !this.player.invincible) {
                    this.player.fire();
                    this.fireCooldown = CFG.FIRE_RATE;
                }
            }
            if (e.code === 'Escape') {
                if (this.isRunning) {
                    this.togglePause();
                }
            }
            if (e.code === 'Enter' || e.code === 'NumpadEnter') {
                if (!this.isRunning && !document.getElementById('game-over-screen').classList.contains('hidden')) {
                    this.start();
                }
            }
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        
        // Touch pour d√©marrer
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!this.isRunning && !this.gameOver) {
                this.start();
            }
        }, { passive: false });
    },

    setupMobileControls() {
        const joystickContainer = document.getElementById('joystick-container');
        const fireBtn = document.getElementById('btn-fire');
        
        if (!joystickContainer) return;
        
        this.calculateJoystickOrigin();
        
        // Gestion du joystick am√©lior√©e
        const handleJoystickStart = (clientX, clientY, touchId = null) => {
            if (!this.isRunning) return;
            
            this.joystickActive = true;
            if (touchId !== null) this.joystickTouchId = touchId;
            document.getElementById('joystick-thumb').classList.add('active');
            this.updateJoystickPosition(clientX, clientY);
        };
        
        const handleJoystickMove = (clientX, clientY) => {
            if (!this.joystickActive || !this.isRunning) return;
            this.updateJoystickPosition(clientX, clientY);
        };
        
        const handleJoystickEnd = (touchId = null) => {
            if (touchId !== null && this.joystickTouchId !== touchId) return;
            
            this.joystickActive = false;
            this.joystickX = 0;
            this.joystickY = 0;
            this.joystickTouchId = null;
            document.getElementById('joystick-thumb').classList.remove('active');
            document.getElementById('joystick-thumb').style.transform = 'translate(-50%, -50%)';
        };
        
        // Touch events optimis√©s pour mobile
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleJoystickStart(touch.clientX, touch.clientY, touch.identifier);
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (!this.joystickActive || !this.joystickTouchId) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === this.joystickTouchId) {
                    e.preventDefault();
                    handleJoystickMove(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        });
        
        document.addEventListener('touchcancel', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystickTouchId) {
                    handleJoystickEnd(this.joystickTouchId);
                    break;
                }
            }
        });
        
        // Mouse events pour desktop
        joystickContainer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleJoystickStart(e.clientX, e.clientY);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!this.joystickActive) return;
            e.preventDefault();
            handleJoystickMove(e.clientX, e.clientY);
        });
        
        document.addEventListener('mouseup', (e) => {
            if (this.joystickActive) {
                handleJoystickEnd();
            }
        });
        
        // Bouton de tir
        const handleFireStart = () => {
            if (!this.isRunning) return;
            
            if (this.fireCooldown <= 0 && this.player && !this.player.invincible) {
                this.player.fire();
                this.fireCooldown = CFG.FIRE_RATE;
            }
            fireBtn.classList.add('active');
        };
        
        const handleFireEnd = () => {
            fireBtn.classList.remove('active');
        };
        
        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleFireStart();
        }, { passive: false });
        
        fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mousedown', (e) => {
            e.preventDefault();
            handleFireStart();
        });
        
        fireBtn.addEventListener('mouseup', (e) => {
            e.preventDefault();
            handleFireEnd();
        });
        
        fireBtn.addEventListener('mouseleave', handleFireEnd);
        
        // Emp√™cher le contexte menu sur les contr√¥les
        joystickContainer.addEventListener('contextmenu', (e) => e.preventDefault());
        fireBtn.addEventListener('contextmenu', (e) => e.preventDefault());
    },

    updateJoystickPosition(clientX, clientY) {
        const joystickThumb = document.getElementById('joystick-thumb');
        
        // Recalculer l'origine √† chaque mise √† jour pour compenser le d√©filement
        this.calculateJoystickOrigin();
        
        let deltaX = clientX - this.joystickOrigin.x;
        let deltaY = clientY - this.joystickOrigin.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Limiter le mouvement au rayon maximum
        if (distance > this.joystickMaxRadius) {
            deltaX = (deltaX / distance) * this.joystickMaxRadius;
            deltaY = (deltaY / distance) * this.joystickMaxRadius;
        }
        
        // Appliquer une zone morte pour √©viter les mouvements involontaires
        const effectiveDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (effectiveDistance < this.joystickMaxRadius * CFG.JOYSTICK_DEADZONE) {
            deltaX = 0;
            deltaY = 0;
            joystickThumb.style.transform = `translate(-50%, -50%)`;
        } else {
            joystickThumb.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
        }
        
        // Normaliser les valeurs entre -1 et 1
        this.joystickX = deltaX / this.joystickMaxRadius;
        this.joystickY = deltaY / this.joystickMaxRadius;
    },

    togglePause() {
        if (this.isRunning) {
            this.isRunning = false;
            document.getElementById('start-screen').classList.remove('hidden');
            document.getElementById('start-screen').innerHTML = `
                <div class="start-content">
                    <h1>PAUSE</h1>
                    <p>Score: ${this.score} | Level: ${this.level}</p>
                    <button class="play-triangle" onclick="Game.resume()" aria-label="Reprendre"></button>
                </div>
            `;
        }
    },

    resume() {
        this.isRunning = true;
        document.getElementById('start-screen').classList.add('hidden');
    },

    start() {
        console.log("Jeu d√©marre!");
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.enemies = [];
        this.projectiles = [];
        this.particles = [];
        this.explosionParticles = [];
        this.enemyCount = 0;
        this.shotsFired = 0;
        this.fireCooldown = 0;
        this.isRunning = true;
        this.gameOver = false;
        this.cameraX = 0;
        this.cameraY = 0;
        this.lastTime = 0;
        
        // R√©initialiser le joystick
        this.joystickActive = false;
        this.joystickX = 0;
        this.joystickY = 0;
        const joystickThumb = document.getElementById('joystick-thumb');
        if (joystickThumb) {
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            joystickThumb.classList.remove('active');
        }
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        // Position initiale au centre
        this.player = new Player(this.width / 2, this.height / 2);
        this.spawnTimer = 0;
        this.updateHUD();
        
        this.updateHearts();
        
        // Nettoyer les classes d'invincibilit√©
        this.canvas.classList.remove('player-invincible');
        
        this.canvas.focus();
    },

    generateStars() {
        this.stars = [];
        const starCount = this.isMobile ? 150 : 250;
        for (let i = 0; i < starCount; i++) {
            this.stars.push({
                x: Math.random() * 4000 - 2000,
                y: Math.random() * 6000 - 3000,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 0.5 + 0.1,
                opacity: Math.random() * 0.5 + 0.3
            });
        }
    },

    canSpawnEnemyAt(x, y, size) {
        if (!this.player) return true;
        
        const playerDist = Math.sqrt(
            Math.pow(x - this.player.x, 2) + 
            Math.pow(y - this.player.y, 2)
        );
        if (playerDist < 250) return false;
        
        for (const enemy of this.enemies) {
            const dist = Math.sqrt(
                Math.pow(x - enemy.x, 2) + 
                Math.pow(y - enemy.y, 2)
            );
            const minDist = (size/2) + (enemy.size/2) + 25;
            if (dist < minDist) {
                return false;
            }
        }
        return true;
    },

    spawnEnemy() {
        const edge = Math.floor(Math.random() * 4);
        let baseX, baseY, vx, vy;
        
        const spawnMargin = Math.max(this.width, this.height) * 0.15;
        const cameraOffsetX = this.cameraX;
        const cameraOffsetY = this.cameraY;
        
        switch(edge) {
            case 0:
                baseX = Math.random() * this.width;
                baseY = -spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = Math.random() * 1 + 0.5;
                break;
            case 1:
                baseX = this.width + spawnMargin;
                baseY = Math.random() * this.height;
                vx = -Math.random() * 1 - 0.5;
                vy = (Math.random() - 0.5) * 2;
                break;
            case 2:
                baseX = Math.random() * this.width;
                baseY = this.height + spawnMargin;
                vx = (Math.random() - 0.5) * 2;
                vy = -Math.random() * 1 - 0.5;
                break;
            case 3:
                baseX = -spawnMargin;
                baseY = Math.random() * this.height;
                vx = Math.random() * 1 + 0.5;
                vy = (Math.random() - 0.5) * 2;
                break;
        }
        
        const enemyTypes = ['circle', 'triangle', 'square', 'star', 'hexagon', 'spiral', 'drone'];
        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        const size = 20 + Math.random() * 15;
        const x = baseX + cameraOffsetX;
        const y = baseY + cameraOffsetY;
        
        if (this.canSpawnEnemyAt(x, y, size)) {
            this.enemies.push(new Enemy(x, y, vx, vy, type, size));
            this.enemyCount++;
            return true;
        }
        return false;
    },

    updateHUD() {
        document.getElementById('score-display').textContent = this.score;
    },

    updateHearts() {
        for (let i = 1; i <= 3; i++) {
            const heart = document.getElementById(`heart-${i}`);
            if (i <= this.lives) {
                heart.classList.remove('lost');
            } else {
                heart.classList.add('lost');
            }
        }
    },

    createShipExplosion(x, y) {
        for (let i = 0; i < 50; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 4;
            const size = 3 + Math.random() * 4;
            
            this.explosionParticles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: size,
                life: 1.0,
                color: CFG.COLORS.player,
                decay: 0.02 + Math.random() * 0.02
            });
        }
        
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            const size = 2 + Math.random() * 3;
            
            this.explosionParticles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: size,
                life: 1.0,
                color: '#ff5500',
                decay: 0.015 + Math.random() * 0.015
            });
        }
    },

    die() {
        if (this.gameOver || !this.player) return;
        
        if (this.player.invincible) return;
        
        this.lives--;
        this.updateHearts();
        
        if (this.lives > 0) {
            this.spawnExplosion(this.player.x, this.player.y, CFG.COLORS.enemyCircle);
            
            // Invincibilit√© temporaire (2 secondes)
            this.player.invincible = true;
            this.player.invincibleTimer = 120;
            
            // Position de respawn
            this.player.x = this.cameraX + this.width / 2;
            this.player.y = this.cameraY + this.height / 2;
            this.player.vx = 0;
            this.player.vy = 0;
            
            // Ajouter la classe d'invincibilit√©
            this.canvas.classList.add('player-invincible');
        } else {
            this.gameOver = true;
            this.isRunning = false;
            
            this.createShipExplosion(this.player.x, this.player.y);
            
            // Nettoyer la classe d'invincibilit√©
            this.canvas.classList.remove('player-invincible');
            
            setTimeout(() => {
                this.player = null;
                
                this.saveBestScore();
                
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('best-score').textContent = this.bestScore;
                document.getElementById('final-level').textContent = this.level;
                document.getElementById('final-shots').textContent = this.shotsFired;
                
                setTimeout(() => document.getElementById('restart-btn').focus(), 100);
            }, 1000);
        }
    },

    spawnExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    },

    findNearestEnemy() {
        if (!this.player) return null;
        
        let nearest = null;
        let nearestDist = Infinity;
        
        for (const enemy of this.enemies) {
            const dx = enemy.x - this.player.x;
            const dy = enemy.y - this.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist) {
                nearestDist = dist;
                nearest = enemy;
            }
        }
        
        return nearest;
    },

    loop(timestamp) {
        // Ne pas ex√©cuter le jeu si on est en paysage sur mobile (on veut portrait)
        if (!this.isPortrait && this.isMobile && window.innerWidth > window.innerHeight) {
            requestAnimationFrame((t) => this.loop(t));
            return;
        }
        
        this.deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;
        
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        if(this.isRunning && this.player) {
            this.update();
            this.draw();
        } else if (this.gameOver) {
            this.updateExplosionParticles();
            this.draw();
        } else {
            this.drawBackground();
        }
        
        requestAnimationFrame((t) => this.loop(t));
    },

    update() {
        if (!this.player || !this.isRunning) return;
        
        if (this.fireCooldown > 0) {
            this.fireCooldown -= 1;
        }
        
        // Mise √† jour du joystick
        if (!this.joystickActive) {
            this.joystickX = 0;
            this.joystickY = 0;
        }
        
        // Contr√¥les clavier
        if ((this.keys['Space'] || this.keys['ShiftLeft']) && this.fireCooldown <= 0 && !this.player.invincible) {
            this.player.fire();
            this.fireCooldown = CFG.FIRE_RATE;
        }
        
        // G√©n√©ration d'ennemis
        this.spawnTimer++;
        const spawnRate = Math.max(10, 60 - this.level * 3);
        if(this.spawnTimer >= spawnRate) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }
        
        this.player.update();
        
        // Mise √† jour de la cam√©ra
        if (this.player && !this.player.invincible) {
            let targetCamX = this.player.x - this.width / 2;
            let targetCamY = this.player.y - this.height / 2;
            this.cameraX += (targetCamX - this.cameraX) * 0.05;
            this.cameraY += (targetCamY - this.cameraY) * 0.05;
        }
        
        // Mettre √† jour les ennemis
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];
            enemy.update();
            
            // V√©rifier la collision avec le joueur
            if(this.player && !this.player.invincible && this.circleIntersect(this.player, enemy)) {
                this.die();
                enemy.markForRemoval = true;
            }
        }
        
        // Mettre √† jour les projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.update();
            
            // V√©rifier les collisions avec les ennemis
            for (let j = this.enemies.length - 1; j >= 0; j--) {
                const enemy = this.enemies[j];
                if (this.circleIntersect(proj, enemy)) {
                    this.score += 100;
                    this.spawnExplosion(enemy.x, enemy.y, enemy.color);
                    enemy.markForRemoval = true;
                    this.projectiles.splice(i, 1);
                    this.enemyCount--;
                    this.updateHUD();
                    break;
                }
            }
            
            // Supprimer les projectiles hors √©cran
            const projScreenX = proj.x - this.cameraX;
            const projScreenY = proj.y - this.cameraY;
            if (projScreenX < -100 || projScreenX > this.width + 100 || 
                projScreenY < -100 || projScreenY > this.height + 100 || 
                proj.life <= 0) {
                this.projectiles.splice(i, 1);
            }
        }
        
        // Nettoyer les ennemis marqu√©s pour suppression
        this.enemies = this.enemies.filter(en => !en.markForRemoval);
        
        // Mettre √† jour les particules
        this.particles = this.particles.filter(p => p.update());
        
        // Augmenter le niveau
        if(this.score >= this.level * 1000) {
            this.level++;
        }
    },

    updateExplosionParticles() {
        for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
            const p = this.explosionParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= p.decay;
            
            if (p.life <= 0) {
                this.explosionParticles.splice(i, 1);
            }
        }
    },

    circleIntersect(obj1, obj2) {
        const dx = obj1.x - obj2.x;
        const dy = obj1.y - obj2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const radius1 = obj1.size ? obj1.size/2 : (obj1.radius || 0);
        const radius2 = obj2.size ? obj2.size/2 : (obj2.radius || 0);
        return distance < radius1 + radius2;
    },

    drawBackground() {
        this.ctx.fillStyle = '#050510';
        this.ctx.fillRect(0, 0, this.width, this.height);
        
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        this.stars.forEach(star => {
            this.ctx.globalAlpha = star.opacity;
            const x = star.x - this.cameraX * star.speed * 0.1;
            const y = star.y - this.cameraY * star.speed * 0.1;
            
            if (x > -100 && x < this.width + 100 && y > -100 && y < this.height + 100) {
                this.ctx.beginPath();
                this.ctx.arc(x, y, star.size, 0, Math.PI * 2);
                this.ctx.fill();
            }
        });
        this.ctx.globalAlpha = 1;
    },

    draw() {
        this.drawBackground();
        
        this.ctx.save();
        this.ctx.translate(-this.cameraX, -this.cameraY);
        
        this.drawGrid();
        
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.1)';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(
            this.cameraX - 100, 
            this.cameraY - 100, 
            this.width + 200, 
            this.height + 200
        );
        
        // Dessiner les projectiles
        this.projectiles.forEach(p => p.draw(this.ctx));
        
        // Dessiner les ennemis
        this.enemies.forEach(en => en.draw(this.ctx));
        
        // Dessiner les particules
        this.particles.forEach(p => p.draw(this.ctx));
        
        // Dessiner les particules d'explosion
        this.explosionParticles.forEach(p => {
            this.ctx.globalAlpha = p.life;
            this.ctx.fillStyle = p.color;
            this.ctx.shadowBlur = p.life * 10;
            this.ctx.shadowColor = p.color;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.globalAlpha = 1;
            this.ctx.shadowBlur = 0;
        });
        
        // Dessiner le joueur
        if (this.player) {
            this.player.draw(this.ctx);
        }
        
        this.ctx.restore();
    },

    drawGrid() {
        this.ctx.strokeStyle = 'rgba(0, 242, 255, 0.03)';
        this.ctx.lineWidth = 1;
        let step = 100;
        let startX = Math.floor(this.cameraX / step) * step - step;
        let startY = Math.floor(this.cameraY / step) * step - step;
        
        for(let x = startX; x < startX + this.width + step * 3; x += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);
            this.ctx.lineTo(x, startY + this.height + step * 3);
            this.ctx.stroke();
        }
        
        for(let y = startY; y < startY + this.height + step * 3; y += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(startX, y);
            this.ctx.lineTo(startX + this.width + step * 3, y);
            this.ctx.stroke();
        }
    }
};

/**
 * CLASSES DES OBJETS - OPTIMIS√âES POUR MOBILE
 */
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.size = Game.isMobile ? CFG.PLAYER_SIZE * 0.9 : CFG.PLAYER_SIZE;
        this.angle = 0;
        this.engineParticles = 0;
        this.wingFlap = 0;
        this.autoRotateSpeed = 0.08;
        
        // Propri√©t√©s d'invincibilit√©
        this.invincible = false;
        this.invincibleTimer = 0;
    }

    updateInvincibility() {
        if (this.invincible) {
            this.invincibleTimer--;
            
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
                this.invincibleTimer = 0;
                Game.canvas.classList.remove('player-invincible');
            }
        }
    }

    fire() {
        if (this.invincible) return;
        
        Game.shotsFired++;
        const proj = new Projectile(
            this.x + Math.cos(this.angle) * this.size/2,
            this.y + Math.sin(this.angle) * this.size/2,
            Math.cos(this.angle) * CFG.PROJECTILE_SPEED,
            Math.sin(this.angle) * CFG.PROJECTILE_SPEED,
            this.angle
        );
        Game.projectiles.push(proj);
        Game.updateHUD();
        
        // Recul
        this.vx -= Math.cos(this.angle) * 1.0;
        this.vy -= Math.sin(this.angle) * 1.0;
    }

    update() {
        this.updateInvincibility();
        
        // Contr√¥les clavier
        if(Game.keys['ArrowLeft'] || Game.keys['KeyA']) this.vx -= CFG.SPEED * 0.15;
        if(Game.keys['ArrowRight'] || Game.keys['KeyD']) this.vx += CFG.SPEED * 0.15;
        if(Game.keys['ArrowUp'] || Game.keys['KeyW']) this.vy -= CFG.SPEED * 0.15;
        if(Game.keys['ArrowDown'] || Game.keys['KeyS']) this.vy += CFG.SPEED * 0.15;
        
        // Contr√¥les joystick - SENSIBILIT√â AM√âLIOR√âE
        if (Game.joystickActive) {
            const sensitivity = 0.4; // Augment√© pour meilleure r√©ponse
            this.vx += Game.joystickX * CFG.SPEED * sensitivity;
            this.vy += Game.joystickY * CFG.SPEED * sensitivity;
        }
        
        this.wingFlap += 0.15;
        
        // Auto-rotation vers l'ennemi le plus proche
        const nearestEnemy = Game.findNearestEnemy();
        if (nearestEnemy) {
            const dx = nearestEnemy.x - this.x;
            const dy = nearestEnemy.y - this.y;
            const targetAngle = Math.atan2(dy, dx);
            
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            this.angle += angleDiff * this.autoRotateSpeed;
        }
        
        // Force de rappel au centre
        const centerX = Game.cameraX + Game.width / 2;
        const centerY = Game.cameraY + Game.height / 2;
        const cdx = centerX - this.x;
        const cdy = centerY - this.y;
        const distance = Math.sqrt(cdx * cdx + cdy * cdy);
        
        if(distance > 800) {
            this.vx += cdx * 0.0008;
            this.vy += cdy * 0.0008;
        }
        
        // Friction
        this.vx *= CFG.FRICTION;
        this.vy *= CFG.FRICTION;
        
        // Mise √† jour de la position
        this.x += this.vx;
        this.y += this.vy;
        
        // Particules de moteur
        this.engineParticles++;
        if(this.engineParticles > 5 && (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1)) {
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            for(let i = 0; i < 2; i++) {
                const angle = this.angle + Math.PI + (Math.random() - 0.5) * 0.4;
                const power = Math.random() * speed * 0.4;
                Game.particles.push(new Particle(
                    this.x - Math.cos(this.angle) * this.size/2,
                    this.y - Math.sin(this.angle) * this.size/2,
                    CFG.COLORS.player,
                    Math.cos(angle) * power,
                    Math.sin(angle) * power
                ));
            }
            this.engineParticles = 0;
        }
    }

    draw(ctx) {
        // Appliquer l'effet d'invincibilit√©
        if (this.invincible) {
            const blink = Math.floor(this.invincibleTimer / 10) % 2 === 0;
            if (blink) return;
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        const wingOffset = Math.sin(this.wingFlap) * 3;
        
        ctx.shadowBlur = 30;
        ctx.shadowColor = CFG.COLORS.player;
        
        // Corps principal
        ctx.fillStyle = CFG.COLORS.player;
        ctx.beginPath();
        
        ctx.moveTo(this.size/2, 0);
        ctx.lineTo(0, -this.size/3);
        ctx.lineTo(-this.size/3, -this.size/4);
        ctx.lineTo(-this.size/2, -this.size/6);
        ctx.lineTo(-this.size/2, -this.size/2 + wingOffset);
        ctx.lineTo(-this.size/4, -this.size/3);
        ctx.lineTo(-this.size/2, 0);
        ctx.lineTo(-this.size/4, this.size/3);
        ctx.lineTo(-this.size/2, this.size/2 - wingOffset);
        ctx.lineTo(-this.size/2, this.size/6);
        ctx.lineTo(-this.size/3, this.size/4);
        ctx.lineTo(0, this.size/3);
        ctx.closePath();
        ctx.fill();
        
        // Cockpit
        ctx.fillStyle = 'rgba(0, 100, 255, 0.7)';
        ctx.beginPath();
        ctx.moveTo(this.size/3, 0);
        ctx.lineTo(-this.size/6, -this.size/4);
        ctx.lineTo(-this.size/3, 0);
        ctx.lineTo(-this.size/6, this.size/4);
        ctx.closePath();
        ctx.fill();
        
        // Fen√™tre
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.beginPath();
        ctx.arc(this.size/6, 0, this.size/4, 0, Math.PI * 2);
        ctx.fill();
        
        // R√©flexion
        ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(this.size/6, 0, this.size/5, 0, Math.PI * 2);
        ctx.fill();
        
        // Propulseurs
        ctx.fillStyle = '#ff5500';
        ctx.fillRect(-this.size/2, -this.size/8, this.size/10, this.size/4);
        ctx.fillRect(-this.size/2 + this.size/6, -this.size/8, this.size/10, this.size/4);
        
        // Canon
        ctx.fillStyle = '#ff3333';
        ctx.fillRect(this.size/2 - 8, -4, 12, 8);
        
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, vx, vy, angle) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = Game.isMobile ? 4 : 5;
        this.life = 100;
        this.angle = angle;
        this.trail = [];
    }
    
    update() {
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 5) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        if (Math.random() < 0.7) {
            Game.particles.push(new Particle(
                this.x,
                this.y,
                CFG.COLORS.projectile,
                -this.vx * 0.1 + (Math.random() - 0.5) * 0.3,
                -this.vy * 0.1 + (Math.random() - 0.5) * 0.3
            ));
        }
        
        return this.life > 0;
    }
    
    draw(ctx) {
        // Tra√Æn√©e
        for (let i = 0; i < this.trail.length; i++) {
            const point = this.trail[i];
            const alpha = i / this.trail.length * 0.5;
            
            ctx.save();
            ctx.translate(point.x, point.y);
            
            ctx.fillStyle = `rgba(255, 100, 50, ${alpha})`;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * (i/this.trail.length), 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Projectile
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = CFG.COLORS.projectile;
        
        const gradient = ctx.createLinearGradient(0, -this.radius, 0, this.radius);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.5, CFG.COLORS.projectile);
        gradient.addColorStop(1, '#ff9900');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, -this.radius);
        ctx.lineTo(this.radius * 3, 0);
        ctx.lineTo(0, this.radius);
        ctx.lineTo(-this.radius, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(this.radius, 0, this.radius/2, this.radius, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, vx, vy, type, size) {
        this.x = x;
        this.y = y;
        this.vx = vx * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.05);
        this.vy = vy * CFG.ENEMY_SPEED_MULTIPLIER * (1 + Game.level * 0.05);
        this.type = type;
        this.size = Game.isMobile ? size * 0.8 : size;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.05;
        this.markForRemoval = false;
        this.pulse = 0;
        this.animationTime = 0;
        this.color = CFG.COLORS[`enemy${type.charAt(0).toUpperCase() + type.slice(1)}`] || CFG.COLORS.enemyCircle;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.pulse += 0.05;
        this.animationTime += 0.1;
        
        // Suivi du joueur
        if (Game.player && !Game.player.invincible) {
            const dx = Game.player.x - this.x;
            const dy = Game.player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if(distance < 600) {
                this.vx += dx * 0.00015 * Game.level;
                this.vy += dy * 0.00015 * Game.level;
            }
        }
        
        // √âviter les autres ennemis
        Game.enemies.forEach(other => {
            if (other !== this) {
                const odx = other.x - this.x;
                const ody = other.y - this.y;
                const odist = Math.sqrt(odx * odx + ody * ody);
                const minDist = (this.size/2) + (other.size/2) + 10;
                
                if (odist < minDist && odist > 0) {
                    const force = 0.08;
                    this.vx -= (odx / odist) * force;
                    this.vy -= (ody / odist) * force;
                }
            }
        });
        
        // Limiter la vitesse
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        const maxSpeed = 3 + Game.level * 0.1;
        if(speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        const pulseSize = 1 + Math.sin(this.pulse) * 0.1;
        ctx.scale(pulseSize, pulseSize);
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        
        switch(this.type) {
            case 'circle':
                // Cercles externes
                for(let i = 0; i < 6; i++) {
                    const segmentAngle = (i / 6) * Math.PI * 2 + this.rotation * 2;
                    ctx.save();
                    ctx.rotate(segmentAngle);
                    
                    const segmentPulse = Math.sin(this.animationTime + i) * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)}, ${parseInt(this.color.slice(3,5),16)}, ${parseInt(this.color.slice(5,7),16)}, ${0.3 + segmentPulse * 0.4})`;
                    
                    ctx.beginPath();
                    ctx.arc(0, this.size/3, this.size/6 * (0.5 + segmentPulse * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Corps principal
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Bouche
                ctx.fillStyle = '#222';
                const mouthOpen = Math.sin(this.animationTime * 3) * 0.3 + 0.7;
                ctx.beginPath();
                ctx.arc(0, 0, this.size/4, 0, Math.PI * mouthOpen);
                ctx.fill();
                break;
                
            case 'triangle':
                const trianglePulse = Math.sin(this.animationTime * 2) * 0.2;
                
                ctx.beginPath();
                ctx.moveTo(0, -this.size/2 * (1 + trianglePulse));
                ctx.lineTo(this.size/2, this.size/2 * (1 - trianglePulse/2));
                ctx.lineTo(-this.size/2, this.size/2 * (1 - trianglePulse/2));
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Yeux qui clignotent
                const blink = Math.sin(this.animationTime * 4) > 0 ? 1 : 0;
                ctx.fillStyle = 'white';
                if(blink) {
                    ctx.beginPath();
                    ctx.arc(-this.size/4, -this.size/8, this.size/10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(this.size/4, -this.size/8, this.size/10, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
                
            case 'square':
                const squareWobble = Math.sin(this.animationTime * 3) * 0.2;
                
                ctx.save();
                ctx.scale(1 + squareWobble, 1 - squareWobble);
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
                
                // Motif int√©rieur
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                const patternSize = this.size/3 * (0.8 + Math.sin(this.animationTime * 2) * 0.2);
                ctx.fillRect(-patternSize/2, -patternSize/2, patternSize, patternSize);
                break;
                
            case 'star':
                const spikes = 5;
                const outerRadius = this.size/2;
                const innerRadius = this.size/4;
                const starPulse = Math.sin(this.animationTime * 2) * 0.3 + 0.7;
                
                ctx.beginPath();
                for(let i = 0; i < spikes * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius * starPulse : innerRadius;
                    const angle = (Math.PI * i) / spikes + this.animationTime;
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Centre rotatif
                ctx.fillStyle = 'white';
                ctx.save();
                ctx.rotate(this.animationTime * 2);
                ctx.beginPath();
                ctx.arc(0, 0, this.size/6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;
                
            case 'hexagon':
                ctx.beginPath();
                for(let i = 0; i < 6; i++) {
                    const angle = (Math.PI * i) / 3 + Math.sin(this.animationTime + i) * 0.2;
                    const radius = this.size/2 * (1 + Math.cos(this.animationTime * 2 + i) * 0.1);
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Hexagone int√©rieur
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                for(let i = 0; i < 6; i++) {
                    const angle = (Math.PI * i) / 3;
                    const radius = this.size/4;
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
                ctx.closePath();
                ctx.fill();
                break;
                
            case 'spiral':
                ctx.beginPath();
                for(let i = 0; i < 20; i++) {
                    const angle = i * 0.3 + this.animationTime * 2;
                    const radius = (i / 20) * (this.size/2);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // Centre
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size/4, 0, Math.PI * 2);
                ctx.fill();
                break;
                
            case 'drone':
                // Corps
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/3, -this.size/3, this.size * 0.66, this.size * 0.66);
                
                // H√©lices
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                const rotorAngle = this.animationTime * 5;
                
                ctx.save();
                ctx.translate(-this.size/2, 0);
                ctx.rotate(rotorAngle);
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size);
                ctx.restore();
                
                ctx.save();
                ctx.translate(this.size/2, 0);
                ctx.rotate(rotorAngle);
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size);
                ctx.restore();
                
                ctx.save();
                ctx.translate(0, -this.size/2);
                ctx.rotate(rotorAngle + Math.PI/2);
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size);
                ctx.restore();
                
                ctx.save();
                ctx.translate(0, this.size/2);
                ctx.rotate(rotorAngle + Math.PI/2);
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size);
                ctx.restore();
                break;
        }
        
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, vx = 0, vy = 0) {
        this.x = x; this.y = y;
        this.vx = vx || (Math.random() - 0.5) * 4;
        this.vy = vy || (Math.random() - 0.5) * 4;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * (Game.isMobile ? 2 : 3) + 1;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.02;
        return this.life > 0;
    }
    
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

// Lancement
window.addEventListener('DOMContentLoaded', () => {
    Game.init();
    
    // Pr√©venir le zoom tactile
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) e.preventDefault();
    }, { passive: false });
    
    // Support PWA (Progressive Web App)
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js').catch(error => {
                console.log('ServiceWorker registration failed:', error);
            });
        });
    }
});
</script>
</body>
</html>
